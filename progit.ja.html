<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pro Git - professional version control</title></head><body><h1>使い始める</h1>

<p>この章は、Gitを使い始めることに関してになります。まずはバージョン管理システムの背景に触れ、その後にGitをあなたのシステムで動かす方法、そしてGitで作業を始めるための設定方法について説明します。この章を読み終えるころには、なぜGitが広まっているか、なぜGitを使うべきなのか、それをするための準備が全て整っているだろうということを、あなたはきっと理解しているでしょう。</p>

<h2>バージョン管理に関して</h2>

<p>バージョン管理とは何でしょうか、また、なぜそれを気にする必要があるのでしょうか？
バージョン管理とは、変更を一つのファイル、もしくは時間を通じたファイルの集合に記録するシステムで、そのため後で特定バージョンを呼び出すことができます。現実にはコンピューター上のほとんどあらゆるファイルのタイプでバージョン管理を行なう事ができますが、本書の中の例では、バージョン管理されるファイルとして、ソフトウェアのソースコードを利用します。</p>

<p>もしあなたが、グラフィックス・デザイナー、もしくはウェブ・デザイナーであって、（あなたが最も確実に望んでいるであろう）画像もしくはレイアウトの全てのバージョンを管理したいのであれば、バージョン管理システム（VCS）はとても賢く利用できるものです｡VCSを使ってできることとしては、ファイルを以前の状態まで戻したり、プロジェクト丸ごとを以前の状態に戻したり、過去の変更を見直したり、誰が最後に問題を引き起こすだろう何かを修正したか、誰が、何時、課題を導入したかを確認したりといった様々なことがあります。VCSを使うということはまた、一般的に、何かをもみくちゃにするか、ファイルを失うとしても、簡単に復活させることができることを意味します。加えて、とても僅かな諸経費で、それら全てを得ることができます。</p>

<h3>ローカル・バージョン管理システム</h3>

<p>多くの人々の選り抜きのバージョン管理手法は、他のディレクトリ（もし彼らが賢いのであれば、恐らく日時が書かれたディレクトリ）にファイルをコピーするというものです。このアプローチは、とても単純なためにすごく一般的ですが、信じられない間違い傾向もあります。どのディレクトリにいるのか忘れやすいですし、偶然に間違ったファイルに書き込んだり、意図しないファイルに上書きしたりします。</p>

<p>この問題を扱うため、大昔にプログラマは、バージョン管理下で全ての変更をファイルに保持するシンプルなデータベースを持つ、ローカルなバージョン管理システムを開発しました（図1-1参照）。</p>

<p><img src="figures/1.1.png" title="1.1 ローカル・バージョン管理図解" alt="1.1 ローカル・バージョン管理図解" /></p>

<p>もっとも有名なVCSツールの一つが、RCSと呼ばれるシステムでした。今日でも依然として多くのコンピューターに入っています。人気のMac OS Xオペレーティング・システムさえも、開発者ツールをインストールしたときは、rcsコマンドを含みます。このツールは基本的に、ディスク上に特殊フォーマットで、一つのリビジョンからもう一つのリビジョンへのパッチ（これはファイル間の差分です）の集合を保持することで稼動します。そういうわけで、全てのパッチを積み上げることで、いつかは、あらゆる時点の、あらゆるファイルのように見えるものを再生成する事ができます。</p>

<h3>集中バージョン管理システム</h3>

<p>次に人々が遭遇した大きな問題は、他のシステムの開発者と共同制作をする必要があることです。この問題に対処するために、集中バージョン管理システム（CVCSs）が開発されました。CVSやSubversion、Perforceのような、これらのシステムは、全てのバージョン管理されたファイルと、その中央の場所からファイルをチェック・アウトする多数のクライアントを含む単一のサーバーを持ちます。長年の間、これはバージョン管理の標準となって来ました（図1-2参照）。</p>

<p><img src="figures/1.2.png" title="1.2 集中バージョン管理図解" alt="1.2 集中バージョン管理図解" /></p>

<p>この構成は、特にローカルVCSと比較して、多くの利点を提供します。例えば、全ての人は、プロジェクトのその他の全ての人々が何をしているのか、一定の程度は知っています。管理者は、誰が何をできるのかについて、きめ細かい統制手段を持ちます。このため、一つのCVCSを管理するということは、全てのクライアントのローカル・データベースを取り扱うより、はるかに容易です。</p>

<p>しかしながら、この構成はまた、深刻な不利益も持ちます。もっとも明白なのは、中央サーバーで発生する単一障害点です。もし、そのサーバーが1時間の間停止すると、その1時間の間は誰も全く、共同作業や、彼らが作業を進めている全てに対してバージョン変更の保存をすることができなくなります。もし中央データベースがのっているハードディスクが破損し、適切なバックアップが保持されていないとすると、人々が偶然にローカル・マシンに持っていた幾らかの単一スナップショット（訳者注：ある時点のファイル、ディレクトリなどの編集対象の状態）を除いた、プロジェクト全体の履歴を失うことになります。ローカルVCSシステムも、これと同じ問題に悩まされます。つまり、単一の場所にプロジェクトの全体の履歴を持っているときはいつでも、全てを失う事を覚悟することになります。</p>

<h3>分散バージョン管理システム</h3>

<p>ここから分散バージョン管理システム(DVCSs)に入ります。DVCS(Git、Mercurial、Bazaar、Darcsのようなもの)では、クライアントはファイルの最新スナップショットをチェックアウト（訳者注：バージョン管理システムから、作業ディレクトリにファイルやディレクトリをコピーすること）するだけではありません。リポジトリ（訳者注：バージョン管理の対象になるファイル、ディレクトリ、更新履歴などの一群）全体をミラーリングします。故にどのサーバーが故障したとして、故障したサーバーを介してそれらのDVCSが共同作業をしていたとしても、あらゆるクライアント・リポジトリは修復のためにサーバーにコピーして戻す事ができます。そのサーバーを介してコラボレーションしていたシステムは, どれか一つのクライアントのリポジトリからサーバー復旧の為バックアップをコピーすることができます. 全てのチェックアウトは、実は全データの完全バックアップなのです(図1-3を参照)。</p>

<p><img src="figures/1.3.png" title="1.3 分散バージョン管理システムの図解" alt="1.3 分散バージョン管理システムの図解" /></p>

<p>そのうえ、これらのDVCSの多くは、 連携する複数のリモート・リポジトリを扱いながら大変よく機能するため、同一のプロジェクト内において、同時に異なった方法で、異なる人々のグループと共同作業が可能です。このことは、集中システムでは不可能であった階層モデルのような、幾つかの様式のワークフローを始めることを許します。</p>

<h2>Git略史</h2>

<p>人生における多くの素晴らしい出来事のように、Gitはわずかな創造的破壊と熱烈な論争から始まりました。Linuxカーネルは、非常に巨大な範囲のオープンソース・ソフトウェア・プロジェクトの一つです。Linuxカーネル保守の大部分の期間（1991-2002）の間は、このソフトウェアに対する変更は、パッチとアーカイブしたファイルとして次々にまわされていました。2002年に、Linuxカーネル・プロジェクトはプロプライエタリのDVCSであるBitKeeperを使い始めました。</p>

<p>2005年に、Linuxカーネルを開発していたコミュニティと、BitKeeperを開発していた営利企業との間の協力関係が崩壊して、課金無しの状態が取り消されました。これは、Linux開発コミュニティ（と、特にLinuxの作者のLinus Torvalds）に、BitKeeperを利用している間に学んだ幾つかの教訓を元に、彼ら独自のツールの開発を促しました。新しいシステムの目標の幾つかは、次の通りでした：</p>

<ul>
<li>スピード</li>
<li>シンプルな設計</li>
<li>ノンリニア開発(数千の並列ブランチ)への強力なサポート</li>
<li>完全な分散</li>
<li>Linux カーネルのような大規模プロジェクトを(スピードとデータサイズで)効率的に取り扱い可能</li>
</ul>


<p>2005年のその誕生から、Gitは使いやすく発展・成熟してきており、さらにその初期の品質を維持しています。とても高速で、巨大プロジェクトではとても効率的で、ノンリニア開発のためのすごい分岐システム（branching system）を備えています（第3章参照）。</p>

<h2>Gitの基本</h2>

<p>では、要するにGitとは何なのでしょうか。これは、Gitを吸収するには重要な節です。なぜならば、もしGitが何かを理解し、Gitがどうやって稼動しているかの根本を理解できれば、Gitを効果的に使う事が恐らくとても容易になるからです。
Gitを学ぶときは、SubversionやPerforceのような他のVCSsに関してあなたが恐らく知っていることは、意識しないでください。このツールを使うときに、ちょっとした混乱を回避することに役立ちます。Gitは、ユーザー・インターフェイスがとてもよく似ているのにも関わらず、それら他のシステムとは大きく異なって、情報を格納して取り扱います（訳者注：「取り扱う」の部分はthinksなので、「見なします」と訳す方が原語に近い）。これらの相違を理解する事は、Gitを扱っている間の混乱を、防いでくれるでしょう。</p>

<h3>スナップショットで、差分ではない</h3>

<p>Gitと他のVCS (Subversionとその類を含む)の主要な相違は、Gitのデータについての考え方です。概念的には、他のシステムのほとんどは、情報をファイルを基本とした変更のリストとして格納します。これらのシステム（CVS、Subversion、Perforce、Bazaar等々）は、図1-4に描かれているように、システムが保持しているファイルの集合と、時間を通じてそれぞれのファイルに加えられた変更の情報を考えます。</p>

<p><img src="figures/1.4.png" title="1.4 他のシステムは、データをそれぞれのファイルの基本バージョンへの変更として格納する傾向があります。" alt="1.4 他のシステムは、データをそれぞれのファイルの基本バージョンへの変更として格納する傾向があります。" /></p>

<p>Gitは、この方法ではデータを考えたり、格納しません。代わりに、Gitはデータをミニ・ファイルシステムのスナップショットの集合のように考えます。Gitで全てのコミット（訳注：commitとは変更を記録・保存するGitの操作。詳細は後の章を参照）をするとき、もしくはプロジェクトの状態を保存するとき、Gitは基本的に、その時の全てのファイルの状態のスナップショットを撮り（訳者注：意訳）、そのスナップショットへの参照を格納するのです。効率化のため、ファイルに変更が無い場合は、Gitはファイルを再格納せず、既に格納してある、以前の同一のファイルへのリンクを格納します。Gitは、むしろデータを図1-5のように考えます。</p>

<p><img src="figures/1.5.png" title="1.5 Gitは時間を通じたプロジェクトのスナップショットとしてデータを格納します。" alt="1.5 Gitは時間を通じたプロジェクトのスナップショットとしてデータを格納します。" /></p>

<p>これが、Gitと類似の全ての他のVCSsとの間の重要な違いです。ほとんどの他のシステムが以前の世代から真似してきた、ほとんど全てのバージョン管理のやり方（訳者注：aspectを意訳）を、Gitに見直させます。これは、Gitを、単純にVCSと言うより、その上に組み込まれた幾つかの途方も無くパワフルなツールを備えたミニ・ファイルシステムにしています。このやり方でデータを考えることで得られる利益の幾つかを、第3章のGit branchingを扱ったときに探求します。</p>

<h3>ほとんど全ての操作がローカル</h3>

<p>Gitのほとんどの操作は、ローカル・ファイルと操作する資源だけ必要とします。大体はネットワークの他のコンピューターからの情報は必要ではありません。ほとんどの操作がネットワーク遅延損失を伴うCVCSに慣れているのであれば、もっさりとしたCVCSに慣れているのであれば、このGitの速度は神業のように感じるでしょう（訳者注：直訳は「このGitの側面はスピードの神様がこの世のものとは思えない力でGitを祝福したと考えさせるでしょう」）。プロジェクトの履歴は丸ごとすぐそこのローカル・ディスクに保持しているので、大概の操作はほぼ瞬時のように見えます。</p>

<p>例えば、プロジェクトの履歴を閲覧するために、Gitはサーバーに履歴を取得しに行って表示する必要がありません。直接にローカル・データベースからそれを読むだけです。これは、プロジェクトの履歴をほとんど即座に知るということです。もし、あるファイルの現在のバージョンと、そのファイルの1ヶ月前の間に導入された変更点を知りたいのであれば、Gitは、遠隔のサーバーに差分を計算するように問い合わせたり、ローカルで差分を計算するために遠隔サーバーからファイルの古いバージョンを持ってくる代わりに、1か月前のファイルを調べてローカルで差分の計算を行なえます。</p>

<p>これはまた、オフラインであるか、VPNから切り離されていたとしても、出来ない事は非常に少ないことを意味します。もし、飛行機もしくは列車に乗ってちょっとした仕事をしたいとしても、アップロードするためにネットワーク接続し始めるまで、楽しくコミットできます。もし、帰宅してVPNクライアントを適切に作動させられないとしても、さらに作業ができます。多くの他のシステムでは、それらを行なう事は、不可能であるか苦痛です。例えばPerforceにおいては、サーバーに接続できないときは、多くの事が行なえません。SubversionとCVSにおいては、ファイルの編集はできますが、データベースに変更をコミットできません（なぜならば、データベースがオフラインだからです）。このことは巨大な問題に思えないでしょうが、実に大きな違いを生じうることに驚くでしょう。</p>

<h3>Gitは完全性を持つ</h3>

<p>Gitの全てのものは、格納される前にチェックサムが取られ、その後、そのチェックサムで照合されます。これは、Gitがそれに関して感知することなしに、あらゆるファイルの内容を変更することが不可能であることを意味します。この機能は、Gitの最下層に組み込まれ、またGitの哲学に不可欠です。Gitがそれを感知できない状態で、転送中に情報を失う、もしくは壊れたファイルを取得することはありません。</p>

<p>Gitがチェックサム生成に用いる機構は、SHA-1ハッシュと呼ばれます。これは、16進数の文字（0-9とa-f）で構成された40文字の文字列で、ファイルの内容もしくはGit内のディレクトリ構造を元に計算されます。SHA-1ハッシュは、このようなもののように見えます:</p>

<pre><code>24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre>

<p>Gitはハッシュ値を大変よく利用するので、Gitのいたるところで、これらのハッシュ値を見ることでしょう。事実、Gitはファイル名ではなく、ファイル内容のハッシュ値によってアドレスが呼び出されるGitデータベースの中に全てを格納しています。</p>

<h3>Gitは通常はデータを追加するだけ</h3>

<p>Gitで行動するとき、ほとんど全てはGitデータベースにデータを追加するだけです。システムにいかなる方法でも、UNDO不可能なこと、もしくはデータを消させることをさせるのは、大変難しいです。あらゆるVCSと同様に、まだコミットしていない変更は失ったり、台無しにできたりします。しかし、スナップショットをGitにコミットした後は、特にもし定期的にデータベースを他のリポジトリにプッシュ（訳注：pushはGitで管理するあるリポジトリのデータを、他のリポジトリに転送する操作。詳細は後の章を参照）していれば、変更を失うことは大変難しくなります。</p>

<p>激しく物事をもみくちゃにする危険なしに試行錯誤を行なえるため、これはGitの利用を喜びに変えます。Gitがデータをどのように格納しているのかと失われたように思えるデータをどうやって回復できるのかについての、より詳細な解説に関しては、第9章を参照してください。</p>

<h3>三つの状態</h3>

<p>今、注意してください。もし学習プロセスの残りをスムーズに進めたいのであれば、これはGitに関して覚えておく主要な事です。Gitは、ファイルが帰属する、コミット済、修正済、ステージ済の、三つの主要な状態を持ちます。コミット済は、ローカル・データベースにデータが安全に格納されていることを意味します。修正済は、ファイルに変更を加えていますが、データベースにそれがまだコミットされていないことを意味します。ステージ済は、次のスナップショットのコミットに加えるために、現在のバージョンの修正されたファイルに印をつけている状態を意味します。</p>

<p>このことは、Gitプロジェクト（訳者注：ディレクトリ内）の、Gitディレクトリ、作業ディレクトリ、ステージング・エリアの三つの主要な部分（訳者注：の理解）に導きます。</p>

<p><img src="figures/1.6.png" title="1.6 作業ディレクトリ、ステージング・エリア、Gitディレクトリ" alt="1.6 作業ディレクトリ、ステージング・エリア、Gitディレクトリ" /></p>

<p>Gitディレクトリは、プロジェクトのためのメタデータ（訳者注：Gitが管理するファイルやディレクトリなどのオブジェクトの要約）とオブジェクトのデータベースがあるところです。これは、Gitの最も重要な部分で、他のコンピューターからリポジトリをクローン（訳者注：コピー元の情報を記録した状態で、Gitリポジトリをコピーすること）したときに、コピーされるものです。</p>

<p>作業ディレクトリは、プロジェクトの一つのバージョンの単一チェックアウトです。これらのファイルはGitディレクトリの圧縮されたデータベースから引き出されて、利用するか修正するためにディスクに配置されます。</p>

<p>ステージング・エリアは、普通はGitディレクトリに含まれる、次のコミットに何が含まれるかに関しての情報を蓄えた一つの単純なファイルです。ときどきインデックスのように引き合いにだされますが、ステージング・エリアとして呼ばれることが基本になりつつあります。</p>

<p>基本的なGitのワークフローは、このような風に進みます：</p>

<ol>
<li>作業ディレクトリのファイルを修正します。</li>
<li>修正されたファイルのスナップショットをステージング・エリアに追加して、ファイルをステージします。</li>
<li>コミットします。（訳者注：Gitでは）これは、ステージング・エリアにあるファイルを取得し、永久不変に保持するスナップショットとしてGitディレクトリに格納することです。</li>
</ol>


<p>もしファイルの特定のバージョンがGitディレクトリの中にあるとしたら、コミット済だと見なされます。もし修正されていて、ステージング・エリアに加えられていれば、ステージ済です。そして、チェックアウトされてから変更されましたが、ステージされていないとするなら、修正済です。第2章では、これらの状態と、どうやってこれらを利用をするか、もしくは完全にステージ化部分を省略するかに関してより詳しく学習します。</p>

<h2>Gitのインストール</h2>

<p>少しGitを使う事に入りましょう。何よりも最初に、Gitをインストールしなければなりません。幾つもの経路で入手することができ、主要な二つの方法のうちの一つはソースからインストールすることで、もう一つはプラットフォームに応じて存在するパッケージをインストールすることです。</p>

<h3>ソースからのインストール</h3>

<p>もし可能であれば、もっとも最新のバージョンを入手できるので、一般的にソースからGitをインストールするのが便利です。Gitのそれぞれのバージョンは、実用的なユーザー・インターフェイスの向上が含まれており、もしソースからソフトウェアをコンパイルすることに違和感を感じないのであれば、最新バージョンを入手することは、大抵は最も良い経路になります。また、多くのLinuxディストリビューションがとても古いパッケージを収録している事は良くあることであり、最新のディストリビューションを使っているか、バックポート（訳者注：最新のパッケージを古いディストリビューションで使えるようにする事）をしていない限りは、ソースからのインストールがベストな選択になるでしょう。</p>

<p>Gitをインストールするためには、Gitが依存するライブラリーである、curl、zlib、openssl、expat、libiconvを入手する必要があります。例えば、もし（Fedoraなどで）yumか（Debianベースのシステムなどで）apt-getが入ったシステムを使っているのであれば、これらのコマンドの一つを依存対象の全てをインストールするのに使う事ができます：</p>

<pre><code>$ yum install curl-devel expat-devel gettext-devel \
  openssl-devel zlib-devel

$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \
  libz-dev libssl-dev
</code></pre>

<p>全ての必要な依存対象を持っているのであれば、先に進んでGitのウェブサイトから最新版のスナップショットを持ってくる事ができます：</p>

<pre><code>http://git-scm.com/download
</code></pre>

<p>そして、コンパイルしてインストールします：</p>

<pre><code>$ tar -zxf git-1.7.2.2.tar.gz
$ cd git-1.7.2.2
$ make prefix=/usr/local all
$ sudo make prefix=/usr/local install
</code></pre>

<p>また、Gitのインストール後、アップデートでGitを通して最新版のGitを得ることができます。</p>

<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git
</code></pre>

<h3>Linuxにインストール</h3>

<p>バイナリのインストーラーを通じてLinux上にGitをインストールしたいのであれば、大抵はディストリビューションに付属する基本的なパッケージ・マネジメント・ツールを使って、それを行なう事ができます。もしFedoraを使っているのであれば、yumを使う事が出来ます：</p>

<pre><code>$ yum install git-core
</code></pre>

<p>もしくは、もしUbuntuのようなDebianベースのディストリュビューションを使っているのであれば、apt-getをやってみましょう：</p>

<pre><code>$ apt-get install git
</code></pre>

<h3>Macにインストール</h3>

<p>MacにGitをインストールするには2つの簡単な方法があります。もっとも簡単な方法は、グラフィカルなGitインストーラーを使うことで、このGitインストーラーはSourceForgeのページ（図1-7参照）からダウンロードすることができます：</p>

<pre><code>http://sourceforge.net/projects/git-osx-installer/
</code></pre>

<p><img src="figures/1.7.png" title="1.7 Git OS X installer" alt="1.7 Git OS X installer" /></p>

<p>もう一つの主要な方法は、MacPorts (<code>http://www.macports.org</code>) からGitをインストールすることです。MacPortsをインストールした状態であれば、Gitを以下のようにインストールできます。</p>

<pre><code>$ sudo port install git-core +svn +doc +bash_completion +gitweb
</code></pre>

<p>全てのvariantsを追加する必要はありませんが、SubversionのリポジトリでGitを使う必要がまだあるなら、恐らく+svnを含めないといけないでしょう（第8章参照）。</p>

<h3>Windowsにインストール</h3>

<p>WindowsにGitをインストールするのはとても簡単です。msysGitプロジェクトは、より簡単なインストール手続きの一つを備えています。GitHubのページから、単純にインストーラーのexeファイルをダウンロードをし、実行してください：</p>

<pre><code>http://msysgit.github.com/
</code></pre>

<p>インストール後、コマンドライン版（後で役に立つSSHクライアントを含む）とスタンダードGUI版の両方を使う事ができます。</p>

<p>Windows利用時の注意点: この本で紹介されている複雑なコマンドを使えるので､GitはmsysGit shell(Unixスタイル)で使うようにしましょう｡Windowsのシェル/コマンドラインコンソールを使わざるを得ない場合､空白を含むパラメーターを囲むための記号はダブルクオーテーション(シングルクォーテーションは使えない)を使用する必要があります｡同様に､サーカムフレックス記号(^)が行末に来る場合はダブルクオーテーションで囲まなければなりません｡同記号はWindowsにおいて｢次行に続く｣を意味する記号だからです｡</p>

<h2>最初のGitの構成</h2>

<p>今や、Gitがシステムにあります。Git環境をカスタマイズするためにしたい事が少しはあることでしょう。アップグレードの度についてまわるので、たった一度でそれらを終わらすべきでしょう。またそれらは、またコマンドを実行することによっていつでも変更することができます。</p>

<p>Gitには、<code>git config</code>と呼ばれるツールが付属します。これで、どのようにGitが見えて機能するかの全ての面を制御できる設定変数を取得し、設定することができます。これらの変数は三つの異なる場所に格納されうります：</p>

<ul>
<li><code>/etc/gitconfig</code> file: システム上の全てのユーザーと全てのリポジトリに対する設定値を保持します。もし<code>--system</code>オプションを<code>git config</code>に指定すると、明確にこのファイルに読み書きを行ないます。</li>
<li><code>~/.gitconfig</code> file: 特定のユーザーに対する設定値を保持します. <code>--global</code>オプションを指定することで、Gitに、明確にこのファイルに読み書きを行なわせることができます。</li>
<li>現在使っている、あらゆるリポジトリのGitディレクトリの設定ファイル(<code>.git/config</code>のことです): 特定の単一リポジトリに対する設定値を保持します。それぞれのレベルの値は以前のレベルの値を上書きするため、<code>.git/config</code>の中の設定値は<code>/etc/gitconfig</code>の設定値に優先されます。</li>
</ul>


<p>Windows環境下では､Gitは<code>$HOME</code>ディレクトリ（環境変数<code>USERPROFILE</code>で指定)の中の<code>.gitconfig</code>ファイルを検索に行きます。<code>$HOME</code>ディレクトリはほとんどの場合 <code>C:\Documents and Settings\$USER</code> か <code>C:\Users\$USER</code> のいずれかです($USERは環境変数<code>USERNAME</code>で指定)｡また、インストーラー時にWindowsシステムにGitをインストールすると決めたところにある、MSysのルートとの相対位置であったとしても、 /etc/gitconfigも見に行きます。</p>

<h3>個人の識別情報</h3>

<p>Gitをインストールしたときに最初にすべきことは、ユーザー名とE-mailアドレスを設定することです。全てのGitのコミットはこの情報を用いるため、これは重要で、次々とまわすコミットに永続的に焼き付けられます：</p>

<pre><code>$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
</code></pre>

<p>また、もし<code>--global</code>オプションを指定するのであれば、Gitはその後、そのシステム上で行なう（訳者注：あるユーザーの）全ての操作に対して常にこの情報を使うようになるため、この操作を行なう必要はたった一度だけです。もし、違う名前とE-mailアドレスを特定のプロジェクトで上書きしたいのであれば、そのプロジェクトの（訳者注：Gitディレクトリの）中で、<code>--global</code>オプション無しでこのコマンドを実行することができます。</p>

<h3>エディター</h3>

<p>今や、個人の識別情報が設定され、Gitがメッセージのタイプをさせる必要があるときに使う、標準のテキストエディターを設定できます。標準では、Gitはシステムのデフォルト・エディターを使います。これは大抵の場合、ViかVimです。Emacsのような違うテキスト・エディターを使いたい場合は、次のようにします：</p>

<pre><code>$ git config --global core.editor emacs
</code></pre>

<h3>diffツール</h3>

<p>設定したいと思われる、その他の便利なオプションは、マージ（訳者注：複数のリポジトリを併合すること）時の衝突を解決するために使う、標準のdiffツールです。vimdiffを使いたいとします：</p>

<pre><code>$ git config --global merge.tool vimdiff
</code></pre>

<p>Gitはkdiff3、tkdiff、meld、xxdiff、emerge、vimdiff、gvimdiff、ecmerge、opendiffを確かなマージ・ツールとして扱えます。カスタム・ツールもまた設定できますが、これをする事に関しての詳細な情報は第7章を参照してください。</p>

<h3>設定の確認</h3>

<p>設定を確認したい場合は、その時点でGitが見つけられる全ての設定を一覧するコマンドである<code>git config --list</code>を使う事ができます：</p>

<pre><code>$ git config --list
user.name=Scott Chacon
user.email=schacon@gmail.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...
</code></pre>

<p>Gitは異なったファイル(例えば<code>/etc/gitconfig</code>と<code>~/.gitconfig</code>)から同一のキーを読み込むため、同一のキーを1度以上見ることになるでしょう。この場合、Gitは見つけたそれぞれ同一のキーに対して最後の値を用います。</p>

<p>また、Gitに設定されている特定のキーの値を、<code>git config {key}</code>をタイプすることで確認することができます：</p>

<pre><code>$ git config user.name
Scott Chacon
</code></pre>

<h2>ヘルプを見る</h2>

<p>もし、Gitを使っている間は助けがいつも必要なら、あらゆるGitコマンドのヘルプのマニュアル・ページ（manpage）を参照する3種類の方法があります。</p>

<pre><code>$ git help &lt;verb&gt;
$ git &lt;verb&gt; --help
$ man git-&lt;verb&gt;
</code></pre>

<p>例えば、configコマンドのヘルプのmanpageを次のコマンドを走らせることで見ることができます。</p>

<pre><code>$ git help config
</code></pre>

<p>これらのコマンドは、オフラインのときでさえ、どこでも見る事ができるので、すばらしいです。
もしmanpageとこの本が十分でなく、人の助けが必要であれば、フリーノードIRCサーバー（irc.freenode.net）の<code>#git</code>もしくは<code>#github</code>チャンネルにアクセスしてみてください。これらのチャンネルはいつも、全員がGitに関してとても知識があり、よく助けてくれようとする数百人の人々でいっぱいです。</p>

<h2>まとめ</h2>

<p>Gitとは何か、どのように今まで使われてきた他のCVCSと異なるのかについて、基本的な理解ができたはずです。また、今や個人情報の設定ができた、システムに稼動するバージョンのGitがあるはずです。今や、本格的にGitの基本を学習するときです。</p>
<h1>Git の基本</h1>

<p>Git を使い始めるにあたってどれかひとつの章だけしか読めないとしたら、読むべきは本章です。この章では、あなたが実際に Git を使う際に必要となる基本コマンドをすべて取り上げています。本章を最後まで読めば、リポジトリの設定や初期化、ファイルの追跡、そして変更内容のステージやコミットなどができるようになるでしょう。また、Git で特定のファイル (あるいは特定のファイルパターン) を無視させる方法やミスを簡単に取り消す方法、プロジェクトの歴史や各コミットの変更内容を見る方法、リモートリポジトリとの間でのプッシュやプルを行う方法についても説明します。</p>

<h2>Git リポジトリの取得</h2>

<p>Git プロジェクトを取得するには、大きく二通りの方法があります。ひとつは既存のプロジェクトやディレクトリを Git にインポートする方法、そしてもうひとつは既存の Git リポジトリを別のサーバーからクローンする方法です。</p>

<h3>既存のディレクトリでのリポジトリの初期化</h3>

<p>既存のプロジェクトを Git で管理し始めるときは、そのプロジェクトのディレクトリに移動して次のように打ち込みます。</p>

<pre><code>$ git init
</code></pre>

<p>これを実行すると <code>.git</code> という名前の新しいサブディレクトリが作られ、リポジトリに必要なすべてのファイル (Git リポジトリのスケルトン) がその中に格納されます。この時点では、まだプロジェクト内のファイルは一切管理対象になっていません (今作った <code>.git</code> ディレクトリに実際のところどんなファイルが含まれているのかについての詳細な情報は、<em>第 9 章</em> を参照ください)。</p>

<p>空のディレクトリではなくすでに存在するファイルのバージョン管理を始めたい場合は、まずそのファイルを監視対象に追加してから最初のコミットをすることになります。この場合は、追加したいファイルについて <code>git add</code> コマンドを実行したあとでコミットを行います。</p>

<pre><code>$ git add *.c
$ git add README
$ git commit -m 'initial project version'
</code></pre>

<p>これが実際のところどういう意味なのかについては後で説明します。ひとまずこの時点で、監視対象のファイルを持つ Git リポジトリができあがり最初のコミットまで済んだことになります。</p>

<h3>既存のリポジトリのクローン</h3>

<p>既存の Git リポジトリ (何か協力したいと思っているプロジェクトなど) のコピーを取得したい場合に使うコマンドが、<code>git clone</code> です。Subversion などの他の VCS を使っている人なら「<code>checkout</code> じゃなくて <code>clone</code> なのか」と気になることでしょう。これは重要な違いです。Git は、サーバーが保持しているデータをほぼすべてコピーするのです。そのプロジェクトのすべてのファイルのすべての歴史が、<code>git clone</code> で手元にやってきます。実際、もし仮にサーバーのディスクが壊れてしまったとしても、どこかのクライアントに残っているクローンをサーバーに戻せばクローンした時点まで復元することができます (サーバーサイドのフックなど一部の情報は失われてしまいますが、これまでのバージョン管理履歴はすべてそこに残っています。<em>第 4 章</em> で詳しく説明します)。</p>

<p>リポジトリをクローンするには <code>git clone [url]</code> とします。たとえば、Ruby の Git ライブラリである Grit をクローンする場合は次のようになります。</p>

<pre><code>$ git clone git://github.com/schacon/grit.git
</code></pre>

<p>これは、まず <code>grit</code> というディレクトリを作成してその中で <code>.git</code> ディレクトリを初期化し、リポジトリのすべてのデータを引き出し、そして最新バージョンの作業コピーをチェックアウトします。新しくできた <code>grit</code> ディレクトリに入ると、プロジェクトのファイルをごらんいただけます。もし grit ではない別の名前のディレクトリにクローンしたいのなら、コマンドラインオプションでディレクトリ名を指定します。</p>

<pre><code>$ git clone git://github.com/schacon/grit.git mygrit
</code></pre>

<p>このコマンドは先ほどと同じ処理をしますが、ディレクトリ名は <code>mygrit</code> となります。</p>

<p>Git では、さまざまな転送プロトコルを使用することができます。先ほどの例では <code>git://</code> プロトコルを使用しましたが、<code>http(s)://</code> や <code>user@server:/path.git</code> といった形式を使うこともできます。これらは SSH プロトコルを使用します。<em>第 4 章</em> で、サーバー側で準備できるすべてのアクセス方式についての利点と欠点を説明します。</p>

<h2>変更内容のリポジトリへの記録</h2>

<p>これで、れっきとした Git リポジトリを準備して、そのプロジェクト内のファイルの作業コピーを取得することができました。次は、そのコピーに対して何らかの変更を行い、適当な時点で変更内容のスナップショットをリポジトリにコミットすることになります。</p>

<p>作業コピー内の各ファイルには <em>追跡されている(tracked)</em> ものと <em>追跡されてない(untracked)</em> ものの二通りがあることを知っておきましょう。<em>追跡されている</em> ファイルとは、直近のスナップショットに存在したファイルのことです。これらのファイルについては変更されていない(unmodified)」「変更されている(modified)」「ステージされている(staged)」の三つの状態があります。追跡されていないファイルは、そのどれでもありません。直近のスナップショットには存在せず、ステージングエリアにも存在しないファイルのことです。最初にプロジェクトをクローンした時点では、すべてのファイルは「追跡されている」かつ「変更されていない」状態となります。チェックアウトしただけで何も編集していない状態だからです。</p>

<p>ファイルを編集すると、Git はそれを「変更された」とみなします。直近のコミットの後で変更が加えられたからです。変更されたファイルを <em>ステージ</em> し、それをコミットする。この繰り返しです。ここまでの流れを図 2-1 にまとめました。</p>

<p><img src="figures/2.1.png" title="2.1 ファイルの状態の流れ" alt="2.1 ファイルの状態の流れ" /></p>

<h3>ファイルの状態の確認</h3>

<p>どのファイルがどの状態にあるのかを知るために主に使うツールが <code>git status</code> コマンドです。このコマンドをクローン直後に実行すると、このような結果となるでしょう。</p>

<pre><code>$ git status
On branch master
nothing to commit, working directory clean
</code></pre>

<p>これは、クリーンな作業コピーである (つまり、追跡されているファイルの中に変更されているものがない) ことを意味します。また、追跡されていないファイルも存在しません (もし追跡されていないファイルがあれば、Git はそれを表示します)。最後に、このコマンドを実行するとあなたが今どのブランチにいるのかを知ることができます。現時点では常に <code>master</code> となります。これはデフォルトであり、ここでは特に気にする必要はありません。ブランチについては次の章で詳しく説明します。</p>

<p>ではここで、新しいファイルをプロジェクトに追加してみましょう。シンプルに、<code>README</code> ファイルを追加してみます。それ以前に README ファイルがなかった場合、<code>git status</code> を実行すると次のように表示されます。</p>

<pre><code>$ vim README
$ git status
On branch master
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

        README

nothing added to commit but untracked files present (use "git add" to track)
</code></pre>

<p>出力結果の “Untracked files” 欄に <code>README</code> ファイルがあることから、このファイルが追跡されていないということがわかります。これは、Git が「前回のスナップショット (コミット) にはこのファイルが存在しなかった」とみなしたということです。明示的に指示しない限り、Git はコミット時にこのファイルを含めることはありません。自動生成されたバイナリファイルなど、コミットしたくないファイルを間違えてコミットしてしまう心配はないということです。今回は README をコミットに含めたいわけですから、まずファイルを追跡対象に含めるようにしましょう。</p>

<h3>新しいファイルの追跡</h3>

<p>新しいファイルの追跡を開始するには <code>git add</code> コマンドを使用します。<code>README</code> ファイルの追跡を開始する場合はこのようになります。</p>

<pre><code>$ git add README
</code></pre>

<p>再び status コマンドを実行すると、<code>README</code> ファイルが追跡対象となり、ステージされていることがわかるでしょう。</p>

<pre><code>$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        new file:   README
</code></pre>

<p>ステージされていると判断できるのは、“Changes to be committed” 欄に表示されているからです。ここでコミットを行うと、<code>git add</code> した時点の状態のファイルがスナップショットとして歴史に書き込まれます。先ほど <code>git init</code> をしたときに、ディレクトリ内のファイルを追跡するためにその後 <code>git add (ファイル)</code> としたことを思い出すことでしょう。<code>git add</code> コマンドには、ファイルあるいはディレクトリのパスを指定します。ディレクトリを指定した場合は、そのディレクトリ以下にあるすべてのファイルを再帰的に追加します。</p>

<h3>変更したファイルのステージング</h3>

<p>すでに追跡対象となっているファイルを変更してみましょう。たとえば、すでに追跡対象となっているファイル <code>benchmarks.rb</code> を変更して <code>status</code> コマンドを実行すると、結果はこのようになります。</p>

<pre><code>$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   benchmarks.rb
</code></pre>

<p><code>benchmarks.rb</code> ファイルは “Changes not staged for commit” という欄に表示されます。これは、追跡対象のファイルが作業ディレクトリ内で変更されたけれどもまだステージされていないという意味です。ステージするには <code>git add</code> コマンドを実行します (このコマンドにはいろんな意味合いがあり、新しいファイルの追跡開始・ファイルのステージング・マージ時に衝突が発生したファイルに対する「解決済み」マーク付けなどで使用します)。では、<code>git add</code> で <code>benchmarks.rb</code> をステージしてもういちど <code>git status</code> を実行してみましょう。</p>

<pre><code>$ git add benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        new file:   README
        modified:   benchmarks.rb
</code></pre>

<p>両方のファイルがステージされました。これで、次回のコミットに両方のファイルが含まれるようになります。ここで、さらに <code>benchmarks.rb</code> にちょっとした変更を加えてからコミットしたくなったとしましょう。ファイルを開いて変更を終え、コミットの準備が整いました。しかし、<code>git status</code> を実行してみると何か変です。</p>

<pre><code>$ vim benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        new file:   README
        modified:   benchmarks.rb

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   benchmarks.rb
</code></pre>

<p>これはどういうことでしょう? <code>benchmarks.rb</code> が、ステージされているほうにもステージされていないほうにも登場しています。こんなことってありえるんでしょうか? 要するに、Git は「<code>git add</code> コマンドを実行した時点の状態のファイル」をステージするということです。ここでコミットをすると、実際にコミットされるのは <code>git add</code> を実行した時点の <code>benchmarks.rb</code> であり、<code>git commit</code> した時点の作業ディレクトリにある内容とは違うものになります。<code>git add</code> した後にファイルを変更した場合に、最新版のファイルをステージしなおすにはもう一度 <code>git add</code> を実行します。</p>

<pre><code>$ git add benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        new file:   README
        modified:   benchmarks.rb
</code></pre>

<h3>ファイルの無視</h3>

<p>ある種のファイルについては、Git で自動的に追加してほしくないしそもそも「追跡されていない」と表示されるのも気になる。そんなことがよくあります。たとえば、ログファイルやビルドシステムが生成するファイルなどの自動生成されるファイルがそれにあたるでしょう。そんな場合は、無視させたいファイルのパターンを並べた <code>.gitignore</code> というファイルを作成します。<code>.gitignore</code> ファイルは、たとえばこのようになります。</p>

<pre><code>$ cat .gitignore
*.[oa]
*~
</code></pre>

<p>最初の行は <code>.o</code> あるいは <code>.a</code> で終わる名前のファイル (コードをビルドする際にできるであろうオブジェクトファイルとアーカイブファイル) を無視するよう Git に伝えています。次の行で Git に無視させているのは、チルダ (<code>~</code>) で終わる名前のファイルです。Emacs をはじめとする多くのエディタが、この形式の一時ファイルを作成します。これ以外には、たとえば <code>log</code>、<code>tmp</code>、<code>pid</code> といった名前のディレクトリや自動生成されるドキュメントなどもここに含めることになるでしょう。実際に作業を始める前に <code>.gitignore</code> ファイルを準備しておくことをお勧めします。そうすれば、予期せぬファイルを間違って Git リポジトリにコミットしてしまう事故を防げます。</p>

<p><code>.gitignore</code> ファイルに記述するパターンの規則は、次のようになります。</p>

<ul>
<li>空行あるいは <code>#</code> で始まる行は無視される</li>
<li>標準の glob パターンを使用可能</li>
<li>ディレクトリを指定するには、パターンの最後にスラッシュ (<code>/</code>) をつける</li>
<li>パターンを逆転させるには、最初に感嘆符 (<code>!</code>) をつける</li>
</ul>


<p>glob パターンとは、シェルで用いる簡易正規表現のようなものです。アスタリスク (<code>*</code>) は、ゼロ個以上の文字にマッチします。<code>[abc]</code> は、角括弧内の任意の文字 (この場合は <code>a</code>、<code>b</code> あるいは <code>c</code>) にマッチします。疑問符 (<code>?</code>) は一文字にマッチします。また、ハイフン区切りの文字を角括弧で囲んだ形式 (<code>[0-9]</code>) は、ふたつの文字の間の任意の文字 (この場合は 0 から 9 までの間の文字) にマッチします。</p>

<p>では、<code>.gitignore</code> ファイルの例をもうひとつ見てみましょう。</p>

<pre><code># コメント。これは無視されます
# .a ファイルは無視
*.a
# しかし、lib.a ファイルだけは .a であっても追跡対象とします
!lib.a
# ルートディレクトリの TODO ファイルだけを無視し、サブディレクトリの TODO は無視しません
/TODO
# build/ ディレクトリのすべてのファイルを無視します
build/
# doc/notes.txt は無視しますが、doc/server/arch.txt は無視しません
doc/*.txt
# doc/ ディレクトリの .txt ファイル全てを無視します
doc/**/*.txt
</code></pre>

<p><code>**/</code> 形式は 1.8.2 以降のGitで利用可能です｡</p>

<h3>ステージされている変更 / されていない変更の閲覧</h3>

<p><code>git status</code> コマンドだけではよくわからない (どのファイルが変更されたのかだけではなく、実際にどのように変わったのかが知りたい) という場合は <code>git diff</code> コマンドを使用します。<code>git diff</code> コマンドについては後で詳しく解説します。おそらく、最もよく使う場面としては次の二つの問いに答えるときになるでしょう。「変更したけどまだステージしていない変更は?」「コミット対象としてステージした変更は?」もちろん <code>git status</code> でもこれらの質問に対するおおまかな答えは得られますが、<code>git diff</code> の場合は追加したり削除したりした正確な行をパッチ形式で表示します。</p>

<p>先ほどの続きで、ふたたび <code>README</code> ファイルを編集してステージし、一方 <code>benchmarks.rb</code> ファイルは編集だけしてステージしない状態にあると仮定しましょう。ここで <code>status</code> コマンドを実行すると、次のような結果となります。</p>

<pre><code>$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   benchmarks.rb
</code></pre>

<p>変更したけれどもまだステージしていない内容を見るには、引数なしで <code>git diff</code> を実行します。</p>

<pre><code>$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..da65585 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
           @commit.parents[0].parents[0].parents[0]
         end

+        run_code(x, 'commits 1') do
+          git.commits.size
+        end
+
         run_code(x, 'commits 2') do
           log = git.commits('master', 15)
           log.size
</code></pre>

<p>このコマンドは、作業ディレクトリの内容とステージングエリアの内容を比較します。この結果を見れば、あなたが変更した内容のうちまだステージされていないものを知ることができます。</p>

<p>次のコミットに含めるべくステージされた内容を知りたい場合は、<code>git diff --cached</code> を使用します (Git バージョン 1.6.1 以降では <code>git diff --staged</code> も使えます。こちらのほうが覚えやすいでしょう)。このコマンドは、ステージされている変更と直近のコミットの内容を比較します。</p>

<pre><code>$ git diff --cached
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README2
@@ -0,0 +1,5 @@
+grit
+ by Tom Preston-Werner, Chris Wanstrath
+ http://github.com/mojombo/grit
+
+Grit is a Ruby library for extracting information from a Git repository
</code></pre>

<p><code>git diff</code> 自体は、直近のコミット以降のすべての変更を表示するわけではないことに注意しましょう。あくまでもステージされていない変更だけの表示となります。これにはすこし戸惑うかもしれません。変更内容をすべてステージしてしまえば <code>git diff</code> は何も出力しなくなるわけですから。</p>

<p>もうひとつの例を見てみましょう。benchmarks.rb ファイルをいったんステージした後に編集してみましょう。<code>git diff</code> を使用すると、ステージされたファイルの変更とまだステージされていないファイルの変更を見ることができます。</p>

<pre><code>$ git add benchmarks.rb
$ echo '# test line' &gt;&gt; benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   benchmarks.rb

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   benchmarks.rb
</code></pre>

<p>ここで <code>git diff</code> を使うと、まだステージされていない内容を知ることができます。</p>

<pre><code>$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index e445e28..86b2f7c 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -127,3 +127,4 @@ end
 main()

 ##pp Grit::GitRuby.cache_client.stats
+# test line
</code></pre>

<p>そして <code>git diff --cached</code> を使うと、これまでにステージした内容を知ることができます。</p>

<pre><code>$ git diff --cached
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..e445e28 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
          @commit.parents[0].parents[0].parents[0]
        end

+        run_code(x, 'commits 1') do
+          git.commits.size
+        end
+
        run_code(x, 'commits 2') do
          log = git.commits('master', 15)
          log.size
</code></pre>

<h3>変更のコミット</h3>

<p>ステージングエリアの準備ができたら、変更内容をコミットすることができます。コミットの対象となるのはステージされたものだけ、つまり追加したり変更したりしただけでまだ <code>git add</code> を実行していないファイルはコミットされないことを覚えておきましょう。そういったファイルは、変更されたままの状態でディスク上に残ります。今回の場合は、最後に <code>git status</code> を実行したときにすべてがステージされていることを確認しています。つまり、変更をコミットする準備ができた状態です。コミットするための最もシンプルな方法は <code>git commit</code> と打ち込むことです。</p>

<pre><code>$ git commit
</code></pre>

<p>これを実行すると、指定したエディタが立ち上がります (シェルの <code>$EDITOR</code> 環境変数で設定されているエディタ。通常は vim あるいは emacs でしょう。しかし、それ以外にも <em>第 1 章</em> で説明した <code>git config --global core.editor</code> コマンドでお好みのエディタを指定することもできます)。</p>

<p>エディタには次のようなテキストが表示されています (これは Vim の画面の例です)。</p>

<pre><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#       new file:   README
#       modified:   benchmarks.rb
#
~
~
~
".git/COMMIT_EDITMSG" 10L, 283C
</code></pre>

<p>デフォルトのコミットメッセージとして、直近の <code>git status</code> コマンドの結果がコメントアウトして表示され、先頭に空行があることがわかるでしょう。このコメントを消して自分でコミットメッセージを書き入れていくこともできますし、何をコミットしようとしているのかの確認のためにそのまま残しておいてもかまいません (何を変更したのかをより明確に知りたい場合は、<code>git commit</code> に <code>-v</code> オプションを指定します。そうすると、diff の内容がエディタに表示されるので何を行ったのかが正確にわかるようになります)。エディタを終了させると、Git はそのメッセージつきのコミットを作成します (コメントおよび diff は削除されます)。</p>

<p>あるいは、コミットメッセージをインラインで記述することもできます。その場合は、<code>commit</code> コマンドの後で <code>-m</code> フラグに続けて次のように記述します。</p>

<pre><code>$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 3 insertions(+)
 create mode 100644 README
</code></pre>

<p>これではじめてのコミットができました! 今回のコミットについて、「どのブランチにコミットしたのか (<code>master</code>)」「そのコミットの SHA-1 チェックサム (<code>463dc4f</code>)」「変更されたファイルの数」「そのコミットで追加されたり削除されたりした行数」といった情報が表示されているのがわかるでしょう。</p>

<p>コミットが記録するのは、ステージングエリアのスナップショットであることを覚えておきましょう。ステージしていない情報については変更された状態のまま残っています。別のコミットで歴史にそれを書き加えるには、改めて add する必要があります。コミットするたびにプロジェクトのスナップショットが記録され、あとからそれを取り消したり参照したりできるようになります。</p>

<h3>ステージングエリアの省略</h3>

<p>コミットの内容を思い通りに作り上げることができるという点でステージングエリアは非常に便利なのですが、普段の作業においては必要以上に複雑に感じられることもあるでしょう。ステージングエリアを省略したい場合のために、Git ではシンプルなショートカットを用意しています。<code>git commit</code> コマンドに <code>-a</code> オプションを指定すると、追跡対象となっているファイルを自動的にステージしてからコミットを行います。つまり <code>git add</code> を省略できるというわけです。</p>

<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   benchmarks.rb

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 files changed, 5 insertions(+)
</code></pre>

<p>この場合、コミットする前に <code>benchmarks.rb</code> を <code>git add</code> する必要がないことに注意しましょう。</p>

<h3>ファイルの削除</h3>

<p>ファイルを Git から削除するには、追跡対象からはずし (より正確に言うとステージングエリアから削除し)、そしてコミットします。<code>git rm</code> コマンドは、この作業を行い、そして作業ディレクトリからファイルを削除します。つまり、追跡されていないファイルとして残り続けることはありません。</p>

<p>単に作業ディレクトリからファイルを削除しただけの場合は、<code>git status</code> の出力の中では “Changes not staged for commit” (つまり <em>ステージされていない</em>) 欄に表示されます。</p>

<pre><code>$ rm grit.gemspec
$ git status
On branch master
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        deleted:    grit.gemspec

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre>

<p><code>git rm</code> を実行すると、ファイルの削除がステージされます。</p>

<pre><code>$ git rm grit.gemspec
rm 'grit.gemspec'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        deleted:    grit.gemspec
</code></pre>

<p>次にコミットするときにファイルが削除され、追跡対象外となります。変更したファイルをすでにステージしている場合は、<code>-f</code> オプションで強制的に削除しなければなりません。まだスナップショットに記録されていないファイルを誤って削除してしまうと Git で復旧することができなくなってしまうので、それを防ぐための安全装置です。</p>

<p>ほかに「こんなことできたらいいな」と思われるであろう機能として、ファイル自体は作業ツリーに残しつつステージングエリアからの削除だけを行うこともできます。つまり、ハードディスク上にはファイルを残しておきたいけれど、もう Git では追跡させたくないというような場合のことです。これが特に便利なのは、<code>.gitignore</code> ファイルに書き足すのを忘れたために巨大なログファイルや大量の <code>.a</code> ファイルがステージされてしまったなどというときです。そんな場合は <code>--cached</code> オプションを使用します。</p>

<pre><code>$ git rm --cached readme.txt
</code></pre>

<p>ファイル名やディレクトリ名、そしてファイル glob パターンを <code>git rm</code> コマンドに渡すことができます。つまり、このようなこともできるということです。</p>

<pre><code>$ git rm log/\*.log
</code></pre>

<p><code>*</code> の前にバックスラッシュ (<code>\</code>) があることに注意しましょう。これが必要なのは、シェルによるファイル名の展開だけでなく Git が自前でファイル名の展開を行うからです。ただしWindowsのコマンドプロンプトの場合は､バックスラッシュは取り除かなければなりません｡このコマンドは、<code>log/</code> ディレクトリにある拡張子 <code>.log</code> のファイルをすべて削除します。あるいは、このような書き方もできます。</p>

<pre><code>$ git rm \*~
</code></pre>

<p>このコマンドは、<code>~</code> で終わるファイル名のファイルをすべて削除します。</p>

<h3>ファイルの移動</h3>

<p>他の多くの VCS とは異なり、Git はファイルの移動を明示的に追跡することはありません。Git の中でファイル名を変更しても、「ファイル名を変更した」というメタデータは Git には保存されないのです。しかし Git は賢いので、ファイル名が変わったことを知ることができます。ファイルの移動を検出する仕組みについては後ほど説明します。</p>

<p>しかし Git には <code>mv</code> コマンドがあります。ちょっと混乱するかもしれませんね。Git の中でファイル名を変更したい場合は次のようなコマンドを実行します。</p>

<pre><code>$ git mv file_from file_to
</code></pre>

<p>このようなコマンドを実行してから status を確認すると、Git はそれをファイル名が変更されたと解釈していることがわかるでしょう。</p>

<pre><code>$ git mv README.txt README
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        renamed:    README.txt -&gt; README
</code></pre>

<p>しかし、実際のところこれは、次のようなコマンドを実行するのと同じ意味となります。</p>

<pre><code>$ mv README.txt README
$ git rm README.txt
$ git add README
</code></pre>

<p>Git はこれが暗黙的なファイル名の変更であると理解するので、この方法であろうが <code>mv</code> コマンドを使おうがどちらでもかまいません。唯一の違いは、この方法だと 3 つのコマンドが必要になるかわりに <code>mv</code> だとひとつのコマンドだけで実行できるという点です。より重要なのは、ファイル名の変更は何でもお好みのツールで行えるということです。あとでコミットする前に add/rm を指示してやればいいのです。</p>

<h2>コミット履歴の閲覧</h2>

<p>何度かコミットを繰り返すと、あるいはコミット履歴つきの既存のリポジトリをクローンすると、過去に何が起こったのかを振り返りたくなることでしょう。そのために使用するもっとも基本的かつパワフルな道具が <code>git log</code> コマンドです。</p>

<p>ここからの例では、<code>simplegit</code> という非常にシンプルなプロジェクトを使用します。これは、私が説明用によく用いているプロジェクトで、次のようにして取得できます。</p>

<pre><code>git clone git://github.com/schacon/simplegit-progit.git
</code></pre>

<p>このプロジェクトで <code>git log</code> を実行すると、このような結果が得られます。</p>

<pre><code>$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit
</code></pre>

<p>デフォルトで引数を何も指定しなければ、<code>git log</code> はそのリポジトリでのコミットを新しい順に表示します。つまり、直近のコミットが最初に登場するということです。ごらんのとおり、このコマンドは各コミットについて SHA-1 チェックサム・作者の名前とメールアドレス・コミット日時・コミットメッセージを一覧表示します。</p>

<p><code>git log</code> コマンドには数多くのバラエティに富んだオプションがあり、あなたが本当に見たいものを表示させることができます。ここでは、よく用いられるオプションのいくつかをご覧に入れましょう。</p>

<p>もっとも便利なオプションのひとつが <code>-p</code> で、これは各コミットの diff を表示します。また <code>-2</code> は、直近の 2 エントリだけを出力します。</p>

<pre><code>$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,5 +5,5 @@ require 'rake/gempackagetask'
 spec = Gem::Specification.new do |s|
     s.name      =   "simplegit"
-    s.version   =   "0.1.0"
+    s.version   =   "0.1.1"
     s.author    =   "Scott Chacon"
     s.email     =   "schacon@gee-mail.com

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
\ No newline at end of file
</code></pre>

<p>このオプションは、先ほどと同じ情報を表示するとともに、各エントリの直後にその diff を表示します。これはコードレビューのときに非常に便利です。また、他のメンバーが一連のコミットで何を行ったのかをざっと眺めるのにも便利でしょう。</p>

<p>コードレビューの際､行単位ではなく単語単位でレビューするほうが容易な場合もあるでしょう｡<code>git log -p</code> コマンドのオプション <code>--word-diff</code> を使えば､通常の行単位diffではなく､単語単位のdiffを表示させることができます｡単語単位のdiffはソースコードのレビューに用いても役に立ちませんが､書籍や論文など､長文テキストファイルのレビューを行う際は便利です｡こんな風に使用します｡</p>

<pre><code>$ git log -U1 --word-diff
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -7,3 +7,3 @@ spec = Gem::Specification.new do |s|
    s.name      =   "simplegit"
    s.version   =   [-"0.1.0"-]{+"0.1.1"+}
    s.author    =   "Scott Chacon"
</code></pre>

<p>ご覧のとおり､通常のdiffにある｢追加行や削除行の表示｣はありません｡その代わりに､変更点はインラインで表示されることになります｡追加された単語は <code>{+ +}</code> で､削除された単語は <code>[- -]</code> で囲まれます｡また､着目すべき点が行ではなく単語なので､diffの出力を通常の｢変更行前後3行ずつ｣から｢変更行前後1行ずつ｣に減らしたほうがよいかもしれません｡上記の例で使用した <code>-U1</code> オプションを使えば行数を減らせます｡</p>

<p>また、<code>git log</code> では「まとめ」系のオプションを使うこともできます。たとえば、各コミットに関するちょっとした統計情報を見たい場合は <code>--stat</code> オプションを使用します。</p>

<pre><code>$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

 lib/simplegit.rb |    5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |    6 ++++++
 Rakefile         |   23 +++++++++++++++++++++++
 lib/simplegit.rb |   25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)
</code></pre>

<p>ごらんの通り <code>--stat</code> オプションは、各コミットエントリに続けて変更されたファイルの一覧と変更されたファイルの数、追加・削除された行数が表示されます。また、それらの情報のまとめを最後に出力します。もうひとつの便利なオプションが <code>--pretty</code> です。これは、ログをデフォルトの書式以外で出力します。あらかじめ用意されているいくつかのオプションを指定することができます。<code>oneline</code> オプションは、各コミットを一行で出力します。これは、大量のコミットを見る場合に便利です。さらに <code>short</code> や <code>full</code> そして <code>fuller</code> といったオプションもあり、これは標準とほぼ同じ書式だけれども情報量がそれぞれ少なめあるいは多めになります。</p>

<pre><code>$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
</code></pre>

<p>もっとも興味深いオプションは <code>format</code> で、これは独自のログ出力フォーマットを指定することができます。これは、出力結果を機械にパースさせる際に非常に便利です。自分でフォーマットを指定しておけば、将来 Git をアップデートしても結果が変わらないようにできるからです。</p>

<pre><code>$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 11 months ago : changed the version number
085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code
a11bef0 - Scott Chacon, 11 months ago : first commit
</code></pre>

<p>表 2-1 は、format で使用できる便利なオプションをまとめたものです。</p>

<!-- Attention to translators: this is a table declaration.
The lines must be formatted as follows
<TAB><First column text><TAB><Second column text>
-->


<pre><code>オプション 出力される内容
%H  コミットのハッシュ
%h  コミットのハッシュ (短縮版)
%T  ツリーのハッシュ
%t  ツリーのハッシュ (短縮版)
%P  親のハッシュ
%p  親のハッシュ (短縮版)
%an Author の名前
%ae Author のメールアドレス
%ad Author の日付 (--date= オプションに従った形式)
%ar Author の相対日付
%cn Committer の名前
%ce Committer のメールアドレス
%cd Committer の日付
%cr Committer の相対日付
%s  件名
</code></pre>

<p><em>author</em> と <em>committer</em> は何が違うのか気になる方もいるでしょう。<em>author</em> とはその作業をもともと行った人、<em>committer</em> とはその作業を適用した人のことを指します。あなたがとあるプロジェクトにパッチを送り、コアメンバーのだれかがそのパッチを適用したとしましょう。この場合、両方がクレジットされます (あなたが author、コアメンバーが committer です)。この区別については <em>第 5 章</em> でもう少し詳しく説明します。</p>

<p>oneline オプションおよび format オプションは、<code>log</code> のもうひとつのオプションである <code>--graph</code> と組み合わせるとさらに便利です。このオプションは、ちょっといい感じのアスキーグラフでブランチやマージの歴史を表示します。Grit プロジェクトのリポジトリならこのようになります。</p>

<pre><code>$ git log --pretty=format:"%h %s" --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch 'defunkt' into local
</code></pre>

<p>これらは <code>git log</code> の出力フォーマット指定のほんの一部でしかありません。まだまだオプションはあります。表 2-2 に、今まで取り上げたオプションとそれ以外によく使われるオプション、そしてそれぞれが<code>log</code>の出力をどのように変えるのかをまとめました。</p>

<!-- Attention to translators: this is a table declaration.
The lines must be formatted as follows
<TAB><First column text><TAB><Second column text>
-->


<pre><code>オプション 説明
-p  各コミットのパッチを表示する
--word-diff 変更点を単語単位で表示する
--stat  各コミットで変更されたファイルの統計情報を表示する
--shortstat --stat コマンドのうち、変更/追加/削除 の行だけを表示する
--name-only コミット情報の後に変更されたファイルの一覧を表示する
--name-status   変更されたファイルと 追加/修正/削除 情報を表示する
--abbrev-commit SHA-1 チェックサムの全体 (40文字) ではなく最初の数文字のみを表示する
--relative-date 完全な日付フォーマットではなく、相対フォーマット (“2 weeks ago” など) で日付を表示する
--graph ブランチやマージの歴史を、ログ出力とともにアスキーグラフで表示する
--pretty    コミットを別のフォーマットで表示する。オプションとして oneline, short, full, fuller そして format (独自フォーマットを設定する) を指定可能
--oneline   `--pretty=oneline --abbrev-commit`と同じ意味の便利なオプション
</code></pre>

<h3>ログ出力の制限</h3>

<p>出力のフォーマット用オプションだけでなく、 <code>git log</code> にはログの制限用の便利なオプションもあります。コミットの一部だけを表示するようなオプションのことです。既にひとつだけ紹介していますね。<code>-2</code> オプション、これは直近のふたつのコミットだけを表示するものです。実は <code>-&lt;n&gt;</code> の <code>n</code> には任意の整数値を指定することができ、直近の <code>n</code> 件のコミットだけを表示させることができます。ただ、実際のところはこれを使うことはあまりないでしょう。というのも、Git はデフォルトですべての出力をページャにパイプするので、ログを一度に 1 ページだけ見ることになるからです。</p>

<p>しかし <code>--since</code> や <code>--until</code> のような時間制限のオプションは非常に便利です。たとえばこのコマンドは、過去二週間のコミットの一覧を取得します。</p>

<pre><code>$ git log --since=2.weeks
</code></pre>

<p>このコマンドはさまざまな書式で動作します。特定の日を指定する (“2008-01-15”) こともできますし、相対日付を“2 years 1 day 3 minutes ago”のように指定することも可能です。</p>

<p>コミット一覧から検索条件にマッチするものだけを取り出すこともできます。<code>--author</code> オプションは特定の author のみを抜き出し、<code>--grep</code> オプションはコミットメッセージの中のキーワードを検索します (author と grep を両方指定すると、両方にマッチするものだけが対象になります)。</p>

<p>grep を複数指定したい場合は、<code>--all-match</code> を追加しないといけません。そうしないと、どちらか一方にだけマッチするものも対象になってしまいます。</p>

<p>最後に紹介する <code>git log</code> のフィルタリング用オプションは、パスです。ディレクトリ名あるいはファイル名を指定すると、それを変更したコミットのみが対象となります。このオプションは常に最後に指定し、一般にダブルダッシュ (<code>--</code>) の後に記述します。このダブルダッシュが他のオプションとパスの区切りとなります。</p>

<p>表 2-3 に、これらのオプションとその他の一般的なオプションをまとめました。</p>

<!-- Attention to translators: this is a table declaration.
The lines must be formatted as follows
<TAB><First column text><TAB><Second column text>
-->


<pre><code>オプション 説明
-(n)    直近の n 件のコミットのみを表示する
--since, --after    指定した日付/時刻以降のCommitDateのコミットのみに制限する
--until, --before    指定した日付/時刻以前のCommitDateのコミットのみに制限する
--author    エントリが指定した文字列にマッチするコミットのみを表示する
--committer エントリが指定した文字列にマッチするコミットのみを表示する
</code></pre>

<h3>日時にもとづくログ出力の制限</h3>

<p>Git のリポジトリ(git://git.kernel.org/pub/scm/git/git.git)からCommitDateを使ってコミットを検索してみましょう。パソコンに設定されたタイムゾーンにおける2014/04/29のコミットを検索するには、以下のコマンドを実行します。</p>

<pre><code>$ git log --after="2014-04-29 00:00:00" --before="2014-04-29 23:59:59" \
  --pretty=fuller
</code></pre>

<p>この場合、コマンドの結果はパソコンのタイムゾーン設定ごとに異なってしまいます。それを避けるには、タイムゾーンを含むISO 8601フォーマットのような日時を <code>--after</code> や <code>--before</code> の引数に指定するといいでしょう。そうすれば、上述のケースのようにコマンド実行結果が異なる可能性がなくなります。</p>

<p>特定日時(例として、中央ヨーロッパ時間で2013/04/29 17:07:22)を指定してコミットを検索するには、以下のコマンドを使います。</p>

<pre><code>$ git log  --after="2013-04-29T17:07:22+0200"      \
          --before="2013-04-29T17:07:22+0200" --pretty=fuller

commit de7c201a10857e5d424dbd8db880a6f24ba250f9
Author:     Ramkumar Ramachandra &lt;artagnon@gmail.com&gt;
AuthorDate: Mon Apr 29 18:19:37 2013 +0530
Commit:     Junio C Hamano &lt;gitster@pobox.com&gt;
CommitDate: Mon Apr 29 08:07:22 2013 -0700

    git-completion.bash: lexical sorting for diff.statGraphWidth

    df44483a (diff --stat: add config option to limit graph width,
    2012-03-01) added the option diff.startGraphWidth to the list of
    configuration variables in git-completion.bash, but failed to notice
    that the list is sorted alphabetically.  Move it to its rightful place
    in the list.

    Signed-off-by: Ramkumar Ramachandra &lt;artagnon@gmail.com&gt;
    Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
</code></pre>

<p>これらの日時(<code>AuthorDate</code> と <code>CommitDate</code>)はGitのデフォルトフォーマット(<code>--date=default</code> オプション相当)です。作者とコミッター、それぞれのタイムゾーン情報を表示します。</p>

<p>日時フォーマットの指定は他にも <code>--date=iso</code> (ISO 8601)、<code>--date=rfc</code> (RFC 2822)、<code>--date=raw</code> (Unix時間)、<code>--date=local</code> (端末のタイムゾーン)、<code>--date=relative</code>("2 hours ago"のように相対的な指定)などがあります。</p>

<p>また、 <code>git log</code> 実行時に日時指定を省略すると、パソコンの時計をもとにコマンド実行日時を指定日時として使用します(協定標準時からの時差も同一になります)。</p>

<p>具体的には、仮にパソコンの時計が09:00を指していて、かつタイムゾーン設定が協定標準時プラス3時間の場合、以下の <code>git log</code> コマンドの日時指定は同一として扱われます。</p>

<pre><code>$ git log --after=2008-06-01 --before=2008-07-01
$ git log --after="2008-06-01T09:00:00+0300" \
    --before="2008-07-01T09:00:00+0300"
</code></pre>

<p>もう一つ例を挙げておきましょう。Git ソースツリーのテストファイルに対する変更があったコミットのうち、Junio Hamano がコミットしたもの (マージは除く) で 2008 年 10 月(ニューヨークのタイムゾーン)に行われたものを知りたければ次のように指定します。</p>

<pre><code>$ git log --pretty="%h - %s" --author=gitster \
   --after="2008-10-01T00:00:00-0400"         \
  --before="2008-10-31T23:59:59-0400" --no-merges -- t/
5610e3b - Fix testcase failure when extended attribute
acd3b9e - Enhance hold_lock_file_for_{update,append}()
f563754 - demonstrate breakage of detached checkout wi
d1a43f2 - reset --hard/read-tree --reset -u: remove un
51a94af - Fix "checkout --track -b newbranch" on detac
b0ad11e - pull: allow "git pull origin $something:$cur
</code></pre>

<p>約 36,000 件におよぶ Git ソースコードのコミットの歴史の中で、このコマンドの条件にマッチするのは 6 件となります。</p>

<h3>GUI による歴史の可視化</h3>

<p>もう少しグラフィカルなツールでコミットの歴史を見たい場合は、Tcl/Tk のプログラムである <code>gitk</code> を見てみましょう。これは Git に同梱されています。gitk は、簡単に言うとビジュアルな <code>git log</code> ツールです。<code>git log</code> で使えるフィルタリングオプションにはほぼすべて対応しています。プロジェクトのコマンドラインで <code>gitk</code> と打ち込むと、図 2-2 のような画面があらわれるでしょう。</p>

<p><img src="figures/2.2.png" title="2.2 gitk history visualizer" alt="2.2 gitk history visualizer" /></p>

<p>ウィンドウの上半分に、コミットの歴史がきれいな家系図とともに表示されます。ウィンドウの下半分には diff ビューアがあり、任意のコミットをクリックしてその変更内容を確認することができます。</p>

<h2>作業のやり直し</h2>

<p>どんな場面であっても、何かをやり直したくなることはあります。ここでは、行った変更を取り消すための基本的なツールについて説明します。注意点は、ここで扱う内容の中には「やり直しの取り消し」ができないものもあるということです。Git で何か間違えたときに作業内容を失ってしまう数少ない例がここにあります。</p>

<h3>直近のコミットの変更</h3>

<p>やり直しを行う場面としてもっともよくあるのは、「コミットを早まりすぎて追加すべきファイルを忘れてしまった」「コミットメッセージが変になってしまった」などです。そのコミットをもう一度やりなおす場合は、<code>--amend</code> オプションをつけてもう一度コミットします。</p>

<pre><code>$ git commit --amend
</code></pre>

<p>このコマンドは、ステージングエリアの内容をコミットに使用します。直近のコミット以降に何も変更をしていない場合 (たとえば、コミットの直後にこのコマンドを実行したような場合)、スナップショットの内容はまったく同じでありコミットメッセージを変更することになります。</p>

<p>コミットメッセージのエディタが同じように立ち上がりますが、既に前回のコミット時のメッセージが書き込まれた状態になっています。ふだんと同様にメッセージを編集できますが、前回のコミット時のメッセージがその内容で上書きされます。</p>

<p>たとえば、いったんコミットした後、何かのファイルをステージするのを忘れていたのに気づいたとしましょう。そんな場合はこのようにします。</p>

<pre><code>$ git commit -m '初期コミット'
$ git add 忘れてたファイル
$ git commit --amend
</code></pre>

<p>これら 3 つのコマンドの実行後、最終的にできあがるのはひとつのコミットです。二番目のコミットが、最初のコミットの結果を上書きするのです。</p>

<h3>ステージしたファイルの取り消し</h3>

<p>続くふたつのセクションでは、ステージングエリアと作業ディレクトリの変更に関する作業を扱います。すばらしいことに、これらふたつの場所の状態を表示するコマンドを使用すると、変更内容を取り消す方法も同時に表示されます。たとえば、ふたつのファイルを変更し、それぞれを別のコミットとするつもりだったのに間違えて <code>git add *</code> と打ち込んでしまったときのことを考えましょう。ファイルが両方ともステージされてしまいました。ふたつのうちの一方だけのステージを解除するにはどうすればいいでしょう? <code>git status</code> コマンドが教えてくれます。</p>

<pre><code>$ git add .
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   README.txt
        modified:   benchmarks.rb
</code></pre>

<p>“Changes to be committed” の直後に、"use <code>git reset HEAD &lt;file&gt;...</code> to unstage" と書かれています。では、アドバイスに従って <code>benchmarks.rb</code> ファイルのステージを解除してみましょう。</p>

<pre><code>$ git reset HEAD benchmarks.rb
Unstaged changes after reset:
M       benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   README.txt

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   benchmarks.rb
</code></pre>

<p>ちょっと奇妙に見えるコマンドですが、きちんと動作します。<code>benchmarks.rb</code> ファイルは、変更されたもののステージされていない状態に戻りました。</p>

<h3>ファイルへの変更の取り消し</h3>

<p><code>benchmarks.rb</code> に加えた変更が、実は不要なものだったとしたらどうしますか? 変更を取り消す (直近のコミット時点の状態、あるいは最初にクローンしたり最初に作業ディレクトリに取得したときの状態に戻す) 最も簡単な方法は? 幸いなことに、またもや <code>git status</code> がその方法を教えてくれます。先ほどの例の出力結果で、ステージされていないファイル一覧の部分を見てみましょう。</p>

<pre><code>Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        modified:   benchmarks.rb
</code></pre>

<p>とても明確に、変更を取り消す方法が書かれています (少なくとも、バージョン 1.6.1 以降の新しい Git ではこのようになります。もし古いバージョンを使用しているのなら、アップグレードしてこのすばらしい機能を活用することをおすすめします)。ではそのとおりにしてみましょう。</p>

<pre><code>$ git checkout -- benchmarks.rb
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   README.txt
</code></pre>

<p>変更が取り消されたことがわかります。また、これが危険なコマンドであることも知っておかねばなりません。あなたがファイルに加えた変更はすべて消えてしまいます。変更した内容を、別のファイルで上書きしたのと同じことになります。そのファイルが不要であることが確実にわかっているとき以外は、このコマンドを使わないようにしましょう。単にファイルを片付けたいだけなら、次の章で説明する stash やブランチを調べてみましょう。一般にこちらのほうがおすすめの方法です。</p>

<p>Git にコミットした内容のすべては、ほぼ常に取り消しが可能であることを覚えておきましょう。削除したブランチへのコミットや <code>--amend</code> コミットで上書きされた元のコミットでさえも復旧することができます (データの復元方法については <em>第 9 章</em> を参照ください)。しかし、まだコミットしていない内容を失ってしまうと、それは二度と取り戻せません。</p>

<h2>リモートでの作業</h2>

<p>Git を使ったプロジェクトで共同作業を進めていくには、リモートリポジトリの扱い方を知る必要があります。リモートリポジトリとは、インターネット上あるいはその他ネットワーク上のどこかに存在するプロジェクトのことです。複数のリモートリポジトリを持つこともできますし、それぞれを読み込み専用にしたり読み書き可能にしたりすることもできます。他のメンバーと共同作業を進めていくにあたっては、これらのリモートリポジトリを管理し、必要に応じてデータのプル・プッシュを行うことで作業を分担していくことになります。リモートリポジトリの管理には「リモートリポジトリの追加」「不要になったリモートリポジトリの削除」「リモートブランチの管理や追跡対象/追跡対象外の設定」などさまざまな作業が含まれます。このセクションでは、これらの作業について説明します。</p>

<h3>リモートの表示</h3>

<p>今までにどのリモートサーバーを設定したのかを知るには <code>git remote</code> コマンドを実行します。これは、今までに設定したリモートハンドルの名前を一覧表示します。リポジトリをクローンしたのなら、少なくとも <em>origin</em> という名前が見えるはずです。これは、クローン元のサーバーに対して Git がデフォルトでつける名前です。</p>

<pre><code>$ git clone git://github.com/schacon/ticgit.git
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 193.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
</code></pre>

<p><code>-v</code> を指定すると、その名前に対応する URL を表示します。</p>

<pre><code>$ git remote -v
origin  git://github.com/schacon/ticgit.git (fetch)
origin  git://github.com/schacon/ticgit.git (push)
</code></pre>

<p>複数のリモートを設定している場合は、このコマンドはそれをすべて表示します。たとえば、私の Grit リポジトリの場合はこのようになっています。</p>

<pre><code>$ cd grit
$ git remote -v
bakkdoor  git://github.com/bakkdoor/grit.git
cho45     git://github.com/cho45/grit.git
defunkt   git://github.com/defunkt/grit.git
koke      git://github.com/koke/grit.git
origin    git@github.com:mojombo/grit.git
</code></pre>

<p>つまり、これらのユーザーによる変更を容易にプルして取り込めるということです。ここで、origin リモートだけが SSH の URL であることに注目しましょう。私がプッシュできるのは origin だけだということになります (なぜそうなるのかについては <em>第 4 章</em> で説明します)。</p>

<h3>リモートリポジトリの追加</h3>

<p>これまでのセクションでも何度かリモートリポジトリの追加を行ってきましたが、ここで改めてその方法をきちんと説明しておきます。新しいリモート Git リポジトリにアクセスしやすいような名前をつけて追加するには、<code>git remote add [shortname] [url]</code> を実行します。</p>

<pre><code>$ git remote
origin
$ git remote add pb git://github.com/paulboone/ticgit.git
$ git remote -v
origin  git://github.com/schacon/ticgit.git
pb  git://github.com/paulboone/ticgit.git
</code></pre>

<p>これで、コマンドラインに URL を全部打ち込むかわりに <code>pb</code> という文字列を指定するだけでよくなりました。たとえば、Paul が持つ情報の中で自分のリポジトリにまだ存在しないものをすべて取得するには、<code>git fetch pb</code> を実行すればよいのです。</p>

<pre><code>$ git fetch pb
remote: Counting objects: 58, done.
remote: Compressing objects: 100% (41/41), done.
remote: Total 44 (delta 24), reused 1 (delta 0)
Unpacking objects: 100% (44/44), done.
From git://github.com/paulboone/ticgit
 * [new branch]      master     -&gt; pb/master
 * [new branch]      ticgit     -&gt; pb/ticgit
</code></pre>

<p>Paul の master ブランチは、ローカルでは <code>pb/master</code> としてアクセスできます。これを自分のブランチにマージしたり、ローカルブランチとしてチェックアウトして中身を調べたりといったことが可能となります。</p>

<h3>リモートからのフェッチ、そしてプル</h3>

<p>ごらんいただいたように、データをリモートリポジトリから取得するには次のコマンドを実行します。</p>

<pre><code>$ git fetch [remote-name]
</code></pre>

<p>このコマンドは、リモートプロジェクトのすべてのデータの中からまだあなたが持っていないものを引き出します。実行後は、リモートにあるすべてのブランチを参照できるようになり、いつでもそれをマージしたり中身を調べたりすることが可能となります (ブランチとは何なのか、どのように使うのかについては、<em>第 3 章</em> でより詳しく説明します)。</p>

<p>リポジトリをクローンしたときには、リモートリポジトリに対して自動的に <em>origin</em> という名前がつけられます。つまり、<code>git fetch origin</code> とすると、クローンしたとき (あるいは直近でフェッチを実行したとき) 以降にサーバーにプッシュされた変更をすべて取得することができます。ひとつ注意すべき点は、<code>fetch</code> コマンドはデータをローカルリポジトリに引き出すだけだということです。ローカルの環境にマージされたり作業中の内容を書き換えたりすることはありません。したがって、必要に応じて自分でマージをする必要があります。</p>

<p>リモートブランチを追跡するためのブランチを作成すれば (次のセクションと <em>第 3 章</em> で詳しく説明します)、<code>git pull</code> コマンドを使うことができます。これは、自動的にフェッチを行い、リモートブランチの内容を現在のブランチにマージします。おそらくこのほうが、よりお手軽で使いやすいことでしょう。またデフォルトで、<code>git clone</code> コマンドはローカルの master ブランチが (取得元サーバー上の) リモートの master ブランチを追跡するよう自動設定します (リモートに master ブランチが存在することを前提としています)。<code>git pull</code> を実行すると、通常は最初にクローンしたサーバーからデータを取得し、現在作業中のコードへのマージを試みます。</p>

<h3>リモートへのプッシュ</h3>

<p>あなたのプロジェクトがみんなと共有できる状態に達したら、それを上流にプッシュしなければなりません。そのためのコマンドが <code>git push [remote-name] [branch-name]</code> です。master ブランチの内容を <code>origin</code> サーバー (何度も言いますが、クローンした地点でこのブランチ名とサーバー名が自動設定されます) にプッシュしたい場合は、このように実行します。</p>

<pre><code>$ git push origin master
</code></pre>

<p>このコマンドが動作するのは、自分が書き込みアクセス権を持つサーバーからクローンし、かつその後だれもそのサーバーにプッシュしていない場合のみです。あなた以外の誰かが同じサーバーからクローンし、誰かが上流にプッシュした後で自分がプッシュしようとすると、それは拒否されます。拒否された場合は、まず誰かがプッシュした作業内容を引き出してきてローカル環境で調整してからでないとプッシュできません。リモートサーバーへのプッシュ方法の詳細については <em>第 3 章</em> を参照ください。</p>

<h3>リモートの調査</h3>

<p>特定のリモートの情報をより詳しく知りたい場合は <code>git remote show [remote-name]</code> コマンドを実行します。たとえば <code>origin</code> のように名前を指定すると、このような結果が得られます。</p>

<pre><code>$ git remote show origin
* remote origin
  URL: git://github.com/schacon/ticgit.git
  Remote branch merged with 'git pull' while on branch master
    master
  Tracked remote branches
    master
    ticgit
</code></pre>

<p>リモートリポジトリの URL と、追跡対象になっているブランチの情報が表示されます。また、ご丁寧にも「master ブランチ上で <code>git pull</code> すると、リモートの情報を取得した後で自動的にリモートの master ブランチの内容をマージする」という説明があります。また、引き出してきたすべてのリモート情報も一覧表示されます。</p>

<p>Git をもっと使い込むようになると、<code>git remote show</code> で得られる情報はどんどん増えていきます。たとえば次のような結果を得ることになるかもしれません。</p>

<pre><code>$ git remote show origin
* remote origin
  URL: git@github.com:defunkt/github.git
  Remote branch merged with 'git pull' while on branch issues
    issues
  Remote branch merged with 'git pull' while on branch master
    master
  New remote branches (next fetch will store in remotes/origin)
    caching
  Stale tracking branches (use 'git remote prune')
    libwalker
    walker2
  Tracked remote branches
    acl
    apiv2
    dashboard2
    issues
    master
    postgres
  Local branch pushed with 'git push'
    master:master
</code></pre>

<p>このコマンドは、特定のブランチ上で <code>git push</code> したときにどのブランチに自動プッシュされるのかを表示しています。また、サーバー上のリモートブランチのうちまだ手元に持っていないもの、手元にあるブランチのうちすでにサーバー上では削除されているもの、<code>git pull</code> を実行したときに自動的にマージされるブランチなども表示されています。</p>

<h3>リモートの削除・リネーム</h3>

<p>リモートを参照する名前を変更したい場合、新しいバージョンの Git では <code>git remote rename</code> を使うことができます。たとえば <code>pb</code> を <code>paul</code> に変更したい場合は <code>git remote rename</code> をこのように実行します。</p>

<pre><code>$ git remote rename pb paul
$ git remote
origin
paul
</code></pre>

<p>これは、リモートブランチ名も変更することを付け加えておきましょう。これまで <code>pb/master</code> として参照していたブランチは、これからは <code>paul/master</code> となります。</p>

<p>何らかの理由でリモートの参照を削除したい場合 (サーバーを移動したとか特定のミラーを使わなくなったとか、あるいはプロジェクトからメンバーが抜けたとかいった場合) は <code>git remote rm</code> を使用します。</p>

<pre><code>$ git remote rm paul
$ git remote
origin
</code></pre>

<h2>タグ</h2>

<p>多くの VCS と同様に Git にもタグ機能があり、歴史上の重要なポイントに印をつけることができます。一般に、この機能は (<code>v 1.0</code> など) リリースポイントとして使われています。このセクションでは、既存のタグ一覧の取得や新しいタグの作成、さまざまなタグの形式などについて扱います。</p>

<h3>タグの一覧表示</h3>

<p>Git で既存のタグの一覧を表示するのは簡単で、単に <code>git tag</code> と打ち込むだけです。</p>

<pre><code>$ git tag
v0.1
v1.3
</code></pre>

<p>このコマンドは、タグをアルファベット順に表示します。この表示順に深い意味はありません。</p>

<p>パターンを指定してタグを検索することもできます。Git のソースリポジトリを例にとると、240 以上のタグが登録されています。その中で 1.4.2 系のタグのみを見たい場合は、このようにします。</p>

<pre><code>$ git tag -l 'v1.4.2.*'
v1.4.2.1
v1.4.2.2
v1.4.2.3
v1.4.2.4
</code></pre>

<h3>タグの作成</h3>

<p>Git のタグには、軽量 (lightweight) 版と注釈付き (annotated) 版の二通りがあります。軽量版のタグは、変更のないブランチのようなものです。特定のコミットに対する単なるポインタでしかありません。しかし注釈付きのタグは、Git データベース内に完全なオブジェクトとして格納されます。チェックサムが付き、タグを作成した人の名前・メールアドレス・作成日時・タグ付け時のメッセージなども含まれます。また、署名をつけて GNU Privacy Guard (GPG) で検証することもできます。一般的には、これらの情報を含められる注釈付きのタグを使うことをおすすめします。しかし、一時的に使うだけのタグである場合や何らかの理由で情報を含めたくない場合は、軽量版のタグも使用可能です。</p>

<h3>注釈付きのタグ</h3>

<p>Git では、注釈付きのタグをシンプルな方法で作成できます。もっとも簡単な方法は、<code>tag</code> コマンドの実行時に <code>-a</code> を指定することです。</p>

<pre><code>$ git tag -a v1.4 -m 'my version 1.4'
$ git tag
v0.1
v1.3
v1.4
</code></pre>

<p><code>-m</code> で、タグ付け時のメッセージを指定します。これはタグとともに格納されます。注釈付きタグの作成時にメッセージを省略すると、エディタが立ち上がるのでそこでメッセージを記入します。</p>

<p>タグのデータとそれに関連づけられたコミットを見るには <code>git show</code> コマンドを使用します。</p>

<pre><code>$ git show v1.4
tag v1.4
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb 9 14:45:11 2009 -0800

my version 1.4

commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch 'experiment'
</code></pre>

<p>タグ付けした人の情報とその日時、そして注釈メッセージを表示したあとにコミットの情報が続きます。</p>

<h3>署名付きのタグ</h3>

<p>GPG 秘密鍵を持っていれば、タグに署名をすることができます。その場合は <code>-a</code> の代わりに <code>-s</code> を指定すればいいだけです。</p>

<pre><code>$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon &lt;schacon@gee-mail.com&gt;"
1024-bit DSA key, ID F721C45A, created 2009-02-09
</code></pre>

<p>このタグに対して <code>git show</code> を実行すると、あなたの GPG 署名が表示されます。</p>

<pre><code>$ git show v1.5
tag v1.5
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb 9 15:22:20 2009 -0800

my signed 1.5 tag
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.8 (Darwin)

iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN
Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/
=WryJ
-----END PGP SIGNATURE-----
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch 'experiment'
</code></pre>

<p>タグの署名を検証する方法については後ほど説明します。</p>

<h3>軽量版のタグ</h3>

<p>コミットにタグをつけるもうひとつの方法が、軽量版のタグです。これは基本的に、コミットのチェックサムだけを保持するもので、それ以外の情報は含まれません。軽量版のタグを作成するには <code>-a</code>、<code>-s</code> あるいは <code>-m</code> といったオプションをつけずにコマンドを実行します。</p>

<pre><code>$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5
</code></pre>

<p>このタグに対して <code>git show</code> を実行しても、先ほどのような追加情報は表示されません。単に、対応するコミットの情報を表示するだけです。</p>

<pre><code>$ git show v1.4-lw
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch 'experiment'
</code></pre>

<h3>タグの検証</h3>

<p>署名付きのタグを検証するには <code>git tag -v [tag-name]</code> を使用します。このコマンドは、GPG を使って署名を検証します。これを正しく実行するには、署名者の公開鍵があなたの鍵リングに含まれている必要があります。</p>

<pre><code>$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700

GIT 1.4.2.1

Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from "Junio C Hamano &lt;junkio@cox.net&gt;"
gpg:                 aka "[jpeg image of size 1513]"
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A
</code></pre>

<p>署名者の公開鍵を持っていない場合は、このようなメッセージが表示されます。</p>

<pre><code>gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Can't check signature: public key not found
error: could not verify the tag 'v1.4.2.1'
</code></pre>

<h3>後からのタグ付け</h3>

<p>過去にさかのぼってコミットにタグ付けすることもできます。仮にあなたのコミットの歴史が次のようなものであったとしましょう。</p>

<pre><code>$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme
</code></pre>

<p>今になって、このプロジェクトに <code>v1.2</code> のタグをつけるのを忘れていたことに気づきました。本来なら "updated rakefile" のコミットにつけておくべきだったものです。しかし今からでも遅くありません。特定のコミットにタグをつけるには、そのコミットのチェックサム (あるいはその一部) をコマンドの最後に指定します。</p>

<pre><code>$ git tag -a v1.2 -m 'version 1.2' 9fceb02
</code></pre>

<p>これで、そのコミットにタグがつけられたことが確認できます。</p>

<pre><code>$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

$ git show v1.2
tag v1.2
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile
...
</code></pre>

<h3>タグの共有</h3>

<p>デフォルトでは、<code>git push</code> コマンドはタグ情報をリモートに送りません。タグを作ったら、タグをリモートサーバーにプッシュするよう明示する必要があります。その方法は、リモートブランチを共有するときと似ています。<code>git push origin [tagname]</code> を実行するのです。</p>

<pre><code>$ git push origin v1.5
Counting objects: 50, done.
Compressing objects: 100% (38/38), done.
Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
* [new tag]         v1.5 -&gt; v1.5
</code></pre>

<p>多くのタグを一度にプッシュしたい場合は、<code>git push</code> コマンドのオプション <code>--tags</code> を使用します。これは、手元にあるタグのうちまだリモートサーバーに存在しないものをすべて転送します。</p>

<pre><code>$ git push origin --tags
Counting objects: 50, done.
Compressing objects: 100% (38/38), done.
Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
 * [new tag]         v0.1 -&gt; v0.1
 * [new tag]         v1.2 -&gt; v1.2
 * [new tag]         v1.4 -&gt; v1.4
 * [new tag]         v1.4-lw -&gt; v1.4-lw
 * [new tag]         v1.5 -&gt; v1.5
</code></pre>

<p>これで、誰か他の人がリポジトリのクローンやプルを行ったときにすべてのタグを取得できるようになりました。</p>

<h2>ヒントと裏技</h2>

<p>Git の基本を説明した本章を終える前に、ほんの少しだけヒントと裏技を披露しましょう。これを知っておけば、Git をよりシンプルかつお手軽に使えるようになり、Git になじみやすくなることでしょう。ほとんどの人はこれらのことを知らずに Git を使っています。別にどうでもいいことですし本書の後半でこれらの技を使うわけでもないのですが、その方法ぐらいは知っておいたほうがよいでしょう。</p>

<h3>自動補完</h3>

<p>Bash シェルを使っているのなら、Git にはよくできた自動補完スクリプトが付属しています。Git のソースコードをダウンロードし、<code>contrib/completion</code> ディレクトリを見てみましょう。<code>git-completion.bash</code> というファイルがあるはずです。このファイルをホームディレクトリにコピーし、それを <code>.bashrc</code> ファイルに追加しましょう。</p>

<pre><code>source ~/.git-completion.bash
</code></pre>

<p>すべてのユーザーに対して Git 用の Bash シェル補完を使わせたい場合は、Mac なら <code>/opt/local/etc/bash_completion.d</code> ディレクトリ、Linux 系なら <code>/etc/bash_completion.d/</code> ディレクトリにこのスクリプトをコピーします。Bash は、これらのディレクトリにあるスクリプトを自動的に読み込んでシェル補完を行います。</p>

<p>Windows で Git Bash を使用している人は、msysGit で Windows 版 Git をインストールした際にデフォルトでこの機能が有効になっています。</p>

<p>Git コマンドの入力中にタブキーを押せば、補完候補があらわれて選択できるようになります。</p>

<pre><code>$ git co&lt;tab&gt;&lt;tab&gt;
commit config
</code></pre>

<p>ここでは、<code>git co</code> と打ち込んだ後にタブキーを二度押してみました。すると commit と config という候補があらわれました。さらに <code>m&lt;tab&gt;</code> と入力すると、自動的に <code>git commit</code> と補完されます。</p>

<p>これは、コマンドのオプションに対しても機能します。おそらくこっちのほうがより有用でしょう。たとえば、<code>git log</code> を実行しようとしてそのオプションを思い出せなかった場合、タブキーを押せばどんなオプションを使えるのかがわかります。</p>

<pre><code>$ git log --s&lt;tab&gt;
--shortstat  --since=  --src-prefix=  --stat   --summary
</code></pre>

<p>この裏技を使えば、ドキュメントを調べる時間を節約できることでしょう。</p>

<h3>Git エイリアス</h3>

<p>Git は、コマンドの一部だけが入力された状態でそのコマンドを推測することはありません。Git の各コマンドをいちいち全部入力するのがいやなら、<code>git config</code> でコマンドのエイリアスを設定することができます。たとえばこんなふうに設定すると便利かもしれません。</p>

<pre><code>$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
</code></pre>

<p>こうすると、たとえば <code>git commit</code> と同じことが単に <code>git ci</code> と入力するだけでできるようになります。Git を使い続けるにつれて、よく使うコマンドがさらに増えてくることでしょう。そんな場合は、きにせずどんどん新しいエイリアスを作りましょう。</p>

<p>このテクニックは、「こんなことできたらいいな」というコマンドを作る際にも便利です。たとえば、ステージを解除するときにどうしたらいいかいつも迷うという人なら、こんなふうに自分で unstage エイリアスを追加してしまえばいいのです。</p>

<pre><code>$ git config --global alias.unstage 'reset HEAD --'
</code></pre>

<p>こうすれば、次のふたつのコマンドが同じ意味となります。</p>

<pre><code>$ git unstage fileA
$ git reset HEAD fileA
</code></pre>

<p>少しはわかりやすくなりましたね。あるいは、こんなふうに <code>last</code> コマンドを追加することもできます。</p>

<pre><code>$ git config --global alias.last 'log -1 HEAD'
</code></pre>

<p>こうすれば、直近のコミットの情報を見ることができます。</p>

<pre><code>$ git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &lt;dreamer3@example.com&gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;
</code></pre>

<p>Git が単に新しいコマンドをエイリアスで置き換えていることがわかります。しかし、時には Git のサブコマンドではなく外部コマンドを実行したくなることもあるでしょう。そんな場合は、コマンドの先頭に <code>!</code> をつけます。これは、Git リポジトリ上で動作する自作のツールを書くときに便利です。例として、<code>git visual</code> で <code>gitk</code> が起動するようにしてみましょう。</p>

<pre><code>$ git config --global alias.visual '!gitk'
</code></pre>

<h2>まとめ</h2>

<p>これで、ローカルでの Git の基本的な操作がこなせるようになりました。リポジトリの作成やクローン、リポジトリへの変更・ステージ・コミット、リポジトリのこれまでの変更履歴の閲覧などです。次は、Git の強力な機能であるブランチモデルについて説明しましょう。</p>
<h1>Git のブランチ機能</h1>

<p>ほぼすべてと言っていいほどの VCS が、何らかの形式でブランチ機能に対応しています。ブランチとは、開発の本流から分岐し、本流の開発を邪魔することなく作業を続ける機能のことです。多くの VCS ツールでは、これは多少コストのかかる処理になっています。ソースコードディレクトリを新たに作る必要があるなど、巨大なプロジェクトでは非常に時間がかかってしまうことがよくあります。</p>

<p>Git のブランチモデルは、Git の機能の中でもっともすばらしいものだという人もいるほどです。そしてこの機能こそが Git を他の VCS とは一線を画すものとしています。何がそんなにすばらしいのでしょう? Git のブランチ機能は圧倒的に軽量です。ブランチの作成はほぼ一瞬で完了しますし、ブランチの切り替えも高速に行えます。その他大勢の VCS とは異なり、Git では頻繁にブランチ作成とマージを繰り返すワークフローを推奨しています。一日に複数のブランチを切ることさえ珍しくありません。この機能を理解して身につけることで、あなたはパワフルで他に類を見ないツールを手に入れることになります。これは、あなたの開発手法を文字通り一変させてくれるでしょう。</p>

<h2>ブランチとは</h2>

<p>Git のブランチの仕組みについてきちんと理解するには、少し後戻りして Git がデータを格納する方法を知っておく必要があります。第 1 章で説明したように、Git はチェンジセットや差分としてデータを保持しているのではありません。そうではなく、スナップショットとして保持しています。</p>

<p>Git にコミットすると、Git はコミットオブジェクトを作成して格納します。このオブジェクトには、あなたがステージしたスナップショットへのポインタや作者・メッセージのメタデータ、そしてそのコミットの直接の親となるコミットへのポインタが含まれています。最初のコミットの場合は親はいません。通常のコミットの場合は親がひとつ存在します。複数のブランチからマージした場合は、親も複数となります。</p>

<p>これを視覚化して考えるために、ここに 3 つのファイルを含むディレクトリがあると仮定しましょう。3 つのファイルをすべてステージしてコミットしたところです。ステージしたファイルについてチェックサム (第 1 章で説明した SHA-1 ハッシュ) を計算し、そのバージョンのファイルを Git ディレクトリに格納し (Git はファイルを blob として扱います)、そしてそのチェックサムをステージングエリアに追加します。</p>

<pre><code>$ git add README test.rb LICENSE
$ git commit -m 'initial commit of my project'
</code></pre>

<p><code>git commit</code> を実行すると、プロジェクト内全ディレクトリのチェックサムが計算され、<code>tree</code> オブジェクトとして Git リポジトリに格納されます。続いて、メタデータおよびさきほどの <code>tree</code> オブジェクトへのポインタを含むコミットオブジェクトを作成します。これで、必要に応じてこのスナップショットを再作成できるようになります。</p>

<p>この時点で、Git リポジトリには 5 つのオブジェクトが含まれています。3 つのファイルそれぞれの中身をあらわす blob オブジェクト、ディレクトリの中身の一覧とどのファイルがどの blob に対応するかをあらわすツリーオブジェクト、そしてそのルートツリーおよびすべてのメタデータへのポインタを含むコミットオブジェクトです。Git リポジトリ内のデータを概念図であらわすと、図 3-1 のようになります。</p>

<p><img src="figures/3.1.png" title="3.1 ひとつのコミットをあらわすリポジトリ上のデータ" alt="3.1 ひとつのコミットをあらわすリポジトリ上のデータ" /></p>

<p>なんらかの変更を終えて再びコミットすると、次のコミットには直近のコミットへのポインタが格納されます。さらに 2 回のコミットを終えた後の履歴は、図 3-2 のようになるでしょう。</p>

<p><img src="figures/3.2.png" title="3.2 複数のコミットに対応する Git オブジェクト" alt="3.2 複数のコミットに対応する Git オブジェクト" /></p>

<p>Git におけるブランチとは、単にこれら三つのコミットを指す軽量なポインタに過ぎません。Git のデフォルトのブランチ名は master です。最初にコミットした時点で、直近のコミットを指す <code>master</code> ブランチが作られます。その後コミットを繰り返すたびに、このポインタは自動的に進んでいきます。</p>

<p><img src="figures/3.3.png" title="3.3 コミットデータの歴史を指すブランチ" alt="3.3 コミットデータの歴史を指すブランチ" /></p>

<p>新しいブランチを作成したら、いったいどうなるのでしょうか? 単に新たな移動先を指す新しいポインタが作られるだけです。では、新しい testing ブランチを作ってみましょう。次の <code>git branch</code> コマンドを実行します。</p>

<pre><code>$ git branch testing
</code></pre>

<p>これで、新しいポインタが作られます。現時点ではふたつのポインタは同じ位置を指しています (図 3-4 を参照ください)。</p>

<p><img src="figures/3.4.png" title="3.4 複数のブランチがコミットデータの履歴を指す例" alt="3.4 複数のブランチがコミットデータの履歴を指す例" /></p>

<p>Git は、あなたが今どのブランチで作業しているのかをどうやって知るのでしょうか? それを保持する特別なポインタが HEAD と呼ばれるものです。これは、Subversion や CVS といった他の VCS における HEAD の概念とはかなり違うものであることに注意しましょう。Git では、HEAD はあなたが作業しているローカルブランチへのポインタとなります。今回の場合は、あなたはまだ master ブランチにいます。<code>git branch</code> コマンドは新たにブランチを作成するだけであり、そのブランチに切り替えるわけではありません (図 3-5 を参照ください)。</p>

<p><img src="figures/3.5.png" title="3.5 現在作業中のブランチを指す HEAD" alt="3.5 現在作業中のブランチを指す HEAD" /></p>

<p>ブランチを切り替えるには <code>git checkout</code> コマンドを実行します。それでは、新しい testing ブランチに移動してみましょう。</p>

<pre><code>$ git checkout testing
</code></pre>

<p>これで、HEAD は testing ブランチを指すようになります (図 3-6 を参照ください)。</p>

<p><img src="figures/3.6.png" title="3.6 ブランチを切り替えると、HEAD の指す先が移動する" alt="3.6 ブランチを切り替えると、HEAD の指す先が移動する" /></p>

<p>それがどうしたって? では、ここで別のコミットをしてみましょう。</p>

<pre><code>$ vim test.rb
$ git commit -a -m 'made a change'
</code></pre>

<p>図 3-7 にその結果を示します。</p>

<p><img src="figures/3.7.png" title="3.7 HEAD が指すブランチが、コミットによって移動する" alt="3.7 HEAD が指すブランチが、コミットによって移動する" /></p>

<p>興味深いことに、testing ブランチはひとつ進みましたが <code>master</code> ブランチは変わっていません。<code>git checkout</code> でブランチを切り替えたときの状態のままです。それでは <code>master</code> ブランチに戻ってみましょう。</p>

<pre><code>$ git checkout master
</code></pre>

<p>図 3-8 にその結果を示します。</p>

<p><img src="figures/3.8.png" title="3.8 チェックアウトによって HEAD が別のブランチに移動する" alt="3.8 チェックアウトによって HEAD が別のブランチに移動する" /></p>

<p>このコマンドは二つの作業をしています。まず HEAD ポインタが指す先を <code>master</code> ブランチに戻し、そして作業ディレクトリ内のファイルを <code>master</code> が指すスナップショットの状態に戻します。つまり、この時点以降に行った変更は、これまでのプロジェクトから分岐した状態になるということです。これは、testing ブランチで一時的に行った作業を巻き戻したことになります。ここから改めて別の方向に進めるということになります。</p>

<p>それでは、ふたたび変更を加えてコミットしてみましょう。</p>

<pre><code>$ vim test.rb
$ git commit -a -m 'made other changes'
</code></pre>

<p>これで、プロジェクトの歴史が二つに分かれました (図 3-9 を参照ください)。新たなブランチを作成してそちらに切り替え、何らかの作業を行い、メインブランチに戻って別の作業をした状態です。どちらの変更も、ブランチごとに分離しています。ブランチを切り替えつつそれぞれの作業を進め、必要に応じてマージすることができます。これらをすべて、シンプルに <code>branch</code> コマンドと <code>checkout</code> コマンドで行えるのです。</p>

<p><img src="figures/3.9.png" title="3.9 ブランチの歴史が分裂した" alt="3.9 ブランチの歴史が分裂した" /></p>

<p>Git におけるブランチとは、実際のところ特定のコミットを指す 40 文字の SHA-1 チェックサムだけを記録したシンプルなファイルです。したがって、ブランチを作成したり破棄したりするのは非常にコストの低い作業となります。新たなブランチの作成は、単に 41 バイト (40 文字と改行文字) のデータをファイルに書き込むのと同じくらい高速に行えます。</p>

<p>これが他の大半の VCS ツールのブランチと対照的なところです。他のツールでは、プロジェクトのすべてのファイルを新たなディレクトリにコピーしたりすることになります。プロジェクトの規模にもよりますが、これには数秒から数分の時間がかかることでしょう。Git ならこの処理はほぼ瞬時に行えます。また、コミットの時点で親オブジェクトを記録しているので、マージの際にもどこを基準にすればよいのかを自動的に判断してくれます。そのためマージを行うのも非常に簡単です。これらの機能のおかげで、開発者が気軽にブランチを作成して使えるようになっています。</p>

<p>では、なぜブランチを切るべきなのかについて見ていきましょう。</p>

<h2>ブランチとマージの基本</h2>

<p>実際の作業に使うであろう流れを例にとって、ブランチとマージの処理を見てみましょう。次の手順で進めます。</p>

<ol>
<li>ウェブサイトに関する作業を行っている</li>
<li>新たな作業用にブランチを作成する</li>
<li>そのブランチで作業を行う</li>
</ol>


<p>ここで、重大な問題が発生したので至急対応してほしいという連絡を受けました。その後の流れは次のようになります。</p>

<ol>
<li>実運用環境用のブランチに戻る</li>
<li>修正を適用するためのブランチを作成する</li>
<li>テストをした後で修正用ブランチをマージし、実運用環境用のブランチにプッシュする</li>
<li>元の作業用ブランチに戻り、作業を続ける</li>
</ol>


<h3>ブランチの基本</h3>

<p>まず、すでに数回のコミットを済ませた状態のプロジェクトで作業をしているものと仮定します (図 3-10 を参照ください)。</p>

<p><img src="figures/3.10.png" title="3.10 短くて単純なコミットの歴史" alt="3.10 短くて単純なコミットの歴史" /></p>

<p>ここで、あなたの勤務先で使っている何らかの問題追跡システムに登録されている問題番号 53 への対応を始めることにしました。念のために言っておくと、Git は何かの問題追跡システムと連動しているわけではありません。しかし、今回の作業はこの問題番号 53 に対応するものであるため、作業用に新しいブランチを作成します。ブランチの作成と新しいブランチへの切り替えを同時に行うには、<code>git checkout</code> コマンドに <code>-b</code> スイッチをつけて実行します。</p>

<pre><code>$ git checkout -b iss53
Switched to a new branch 'iss53'
</code></pre>

<p>これは、次のコマンドのショートカットです。</p>

<pre><code>$ git branch iss53
$ git checkout iss53
</code></pre>

<p>図 3-11 に結果を示します。</p>

<p><img src="figures/3.11.png" title="3.11 新たなブランチポインタの作成" alt="3.11 新たなブランチポインタの作成" /></p>

<p>ウェブサイト上で何らかの作業をしてコミットします。そうすると <code>iss53</code> ブランチが先に進みます。このブランチをチェックアウトしているからです (つまり、HEAD が iss53 ブランチを指しているということです。図 3-12 を参照ください)。</p>

<pre><code>$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
</code></pre>

<p><img src="figures/3.12.png" title="3.12 作業した結果、iss53 ブランチが移動した" alt="3.12 作業した結果、iss53 ブランチが移動した" /></p>

<p>ここで、ウェブサイトに別の問題が発生したという連絡を受けました。そっちのほうを優先して対応する必要があるとのことです。Git を使っていれば、ここで <code>iss53</code> に関する変更をリリースしてしまう必要はありません。また、これまでの作業をいったん元に戻してから改めて優先度の高い作業にとりかかるなどという大変な作業も不要です。ただ単に、master ブランチに戻るだけでよいのです。</p>

<p>しかしその前に注意すべき点があります。作業ディレクトリやステージングエリアに未コミットの変更が残っている場合、それがもしチェックアウト先のブランチと衝突する内容ならブランチの切り替えはできません。ブランチを切り替える際には、クリーンな状態にしておくのが一番です。これを回避する方法もあります (stash およびコミットの amend という処理です) が、また後ほど説明します。今回はすべての変更をコミットし終えているので、master ブランチに戻ることができます。</p>

<pre><code>$ git checkout master
Switched to branch 'master'
</code></pre>

<p>作業ディレクトリは問題番号 53 の対応を始める前とまったく同じ状態に戻りました。これで、緊急の問題対応に集中できます。ここで覚えておくべき重要な点は、Git が作業ディレクトリの状態をリセットし、チェックアウトしたブランチが指すコミットの時と同じ状態にするということです。そのブランチにおける直近のコミットと同じ状態にするため、ファイルの追加・削除・変更を自動的に行います。</p>

<p>次に、緊急の問題対応を行います。緊急作業用に hotfix ブランチを作成し、作業をそこで進めるようにしましょう (図 3-13 を参照ください)。</p>

<pre><code>$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 3a0874c] fixed the broken email address
 1 files changed, 1 deletion(-)
</code></pre>

<p><img src="figures/3.13.png" title="3.13 master ブランチから新たに作成した hotfix ブランチ" alt="3.13 master ブランチから新たに作成した hotfix ブランチ" /></p>

<p>テストをすませて修正がうまくいったことを確認したら、master ブランチにそれをマージしてリリースします。ここで使うのが <code>git merge</code> コマンドです。</p>

<pre><code>$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 README | 1 -
 1 file changed, 1 deletion(-)
</code></pre>

<p>このマージ処理で "Fast-forward" というフレーズが登場したのにお気づきでしょうか。マージ先のブランチが指すコミットがマージ元のコミットの直接の親であるため、Git がポインタを前に進めたのです。言い換えると、あるコミットに対してコミット履歴上で直接到達できる別のコミットをマージしようとした場合、Git は単にポインタを前に進めるだけで済ませます。マージ対象が分岐しているわけではないからです。この処理のことを "fast forward" と言います。</p>

<p>変更した内容が、これで <code>master</code> ブランチの指すスナップショットに反映されました。これで変更をリリースできます (図 3-14 を参照ください)。</p>

<p><img src="figures/3.14.png" title="3.14 マージした結果、master ブランチの指す先が hotfix ブランチと同じ場所になった" alt="3.14 マージした結果、master ブランチの指す先が hotfix ブランチと同じ場所になった" /></p>

<p>超重要な修正作業が終わったので、横やりが入る前にしていた作業に戻ることができます。しかしその前に、まずは <code>hotfix</code> ブランチを削除しておきましょう。<code>master</code> ブランチが同じ場所を指しているので、もはやこのブランチは不要だからです。削除するには <code>git branch</code> で <code>-d</code> オプションを指定します。</p>

<pre><code>$ git branch -d hotfix
Deleted branch hotfix (was 3a0874c).
</code></pre>

<p>では、先ほどまで問題番号 53 の対応をしていたブランチに戻り、作業を続けましょう (図 3-15 を参照ください)。</p>

<pre><code>$ git checkout iss53
Switched to branch 'iss53'
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
 1 file changed, 1 insertion(+)
</code></pre>

<p><img src="figures/3.15.png" title="3.15 iss53 ブランチは独立して進めることができる" alt="3.15 iss53 ブランチは独立して進めることができる" /></p>

<p>ここで、<code>hotfix</code> ブランチ上で行った作業は <code>iss53</code> ブランチには含まれていないことに注意しましょう。もしそれを取得する必要があるのなら、方法はふたつあります。ひとつは <code>git merge master</code> で <code>master</code> ブランチの内容を <code>iss53</code> ブランチにマージすること。そしてもうひとつはそのまま作業を続け、いつか <code>iss53</code> ブランチの内容を <code>master</code> に適用することになった時点で統合することです。</p>

<h3>マージの基本</h3>

<p>問題番号 53 の対応を終え、<code>master</code> ブランチにマージする準備ができたとしましょう。<code>iss53</code> ブランチのマージは、先ほど <code>hotfix</code> ブランチをマージしたときとまったく同じような手順でできます。つまり、マージ先のブランチに切り替えてから <code>git merge</code> コマンドを実行するだけです。</p>

<pre><code>$ git checkout master
$ git merge iss53
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 1 +
 1 file changed, 1 insertion(+)
</code></pre>

<p>先ほどの <code>hotfix</code> のマージとはちょっとちがう感じですね。今回の場合、開発の歴史が過去のとある時点で分岐しています。マージ先のコミットがマージ元のコミットの直系の先祖ではないため、Git 側でちょっとした処理が必要だったのです。ここでは、各ブランチが指すふたつのスナップショットとそれらの共通の先祖との間で三方向のマージを行いました。図 3-16 に、今回のマージで使用した三つのスナップショットを示します。</p>

<p><img src="figures/3.16.png" title="3.16 Git が共通の先祖を自動的に見つけ、ブランチのマージに使用する" alt="3.16 Git が共通の先祖を自動的に見つけ、ブランチのマージに使用する" /></p>

<p>単にブランチのポインタを先に進めるのではなく、Git はこの三方向のマージ結果から新たなスナップショットを作成し、それを指す新しいコミットを自動作成します (図 3-17 を参照ください)。これはマージコミットと呼ばれ、複数の親を持つ特別なコミットとなります。</p>

<p>マージの基点として使用する共通の先祖を Git が自動的に判別するというのが特筆すべき点です。CVS や Subversion (バージョン 1.5 より前のもの) は、マージの基点となるポイントを自分で見つける必要があります。これにより、他のシステムに比べて Git のマージが非常に簡単なものとなっているのです。</p>

<p><img src="figures/3.17.png" title="3.17 マージ作業の結果から、Git が自動的に新しいコミットオブジェクトを作成する" alt="3.17 マージ作業の結果から、Git が自動的に新しいコミットオブジェクトを作成する" /></p>

<p>これで、今までの作業がマージできました。もはや <code>iss53</code> ブランチは不要です。削除してしまい、問題追跡システムのチケットもクローズしておきましょう。</p>

<pre><code>$ git branch -d iss53
</code></pre>

<h3>マージ時のコンフリクト</h3>

<p>物事は常にうまくいくとは限りません。同じファイルの同じ部分をふたつのブランチで別々に変更してそれをマージしようとすると、Git はそれをうまくマージする方法を見つけられないでしょう。問題番号 53 の変更が仮に <code>hotfix</code> ブランチと同じところを扱っていたとすると、このようなコンフリクトが発生します。</p>

<pre><code>$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>

<p>Git は新たなマージコミットを自動的には作成しませんでした。コンフリクトを解決するまで、処理は中断されます。コンフリクトが発生してマージできなかったのがどのファイルなのかを知るには <code>git status</code> を実行します。</p>

<pre><code>$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)

        both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre>

<p>コンフリクトが発生してまだ解決されていないものについては unmerged として表示されます。Git は、標準的なコンフリクトマーカーをファイルに追加するので、ファイルを開いてそれを解決することにします。コンフリクトが発生したファイルの中には、このような部分が含まれています。</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id="footer"&gt;
  please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53
</code></pre>

<p>これは、HEAD (merge コマンドを実行したときにチェックアウトしていたブランチなので、ここでは master となります) の内容が上の部分 (<code>=======</code> の上にある内容)、そして <code>iss53</code> ブランチの内容が下の部分であるということです。コンフリクトを解決するには、どちらを採用するかをあなたが判断することになります。たとえば、ひとつの解決法としてブロック全体を次のように書き換えます。</p>

<pre><code>&lt;div id="footer"&gt;
please contact us at email.support@github.com
&lt;/div&gt;
</code></pre>

<p>このような解決を各部分に対して行い、<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> や <code>=======</code> そして <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> の行をすべて除去します。そしてすべてのコンフリクトを解決したら、各ファイルに対して <code>git add</code> を実行して解決済みであることを通知します。ファイルをステージすると、Git はコンフリクトが解決されたと見なします。コンフリクトの解決をグラフィカルに行いたい場合は <code>git mergetool</code> を実行します。これは、適切なビジュアルマージツールを立ち上げてコンフリクトの解消を行います。</p>

<pre><code>$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
</code></pre>

<p>デフォルトのツール (Git は <code>opendiff</code> を選びました。私がこのコマンドを Mac で実行したからです) 以外のマージツールを使いたい場合は、“... one of the following tools:”にあるツール一覧を見ましょう。そして、使いたいツールの名前を打ち込みます。第 7 章で、環境にあわせてこのデフォルトを変更する方法を説明します。</p>

<p>マージツールを終了させると、マージに成功したかどうかを Git が聞いてきます。成功したと伝えると、ファイルを自動的にステージしてコンフリクトが解決したことを示します。</p>

<p>再び <code>git status</code> を実行すると、すべてのコンフリクトが解決したことを確認できます。</p>

<pre><code>$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

        modified:   index.html
</code></pre>

<p>結果に満足し、すべてのコンフリクトがステージされていることが確認できたら、<code>git commit</code> を実行してマージコミットを完了させます。デフォルトのコミットメッセージは、このようになります。</p>

<pre><code>Merge branch 'iss53'

Conflicts:
  index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#       .git/MERGE_HEAD
# and try again.
#
</code></pre>

<p>このメッセージを変更して、どのようにして衝突を解決したのかを詳しく説明しておくのもよいでしょう。後から他の人がそのマージを見たときに、あなたがなぜそのようにしたのかがわかりやすくなります。</p>

<h2>ブランチの管理</h2>

<p>これまでにブランチの作成、マージ、そして削除を行いました。ここで、いくつかのブランチ管理ツールについて見ておきましょう。今後ブランチを使い続けるにあたって、これらのツールが便利に使えるでしょう。</p>

<p><code>git branch</code> コマンドは、単にブランチを作ったり削除したりするだけのものではありません。何も引数を渡さずに実行すると、現在のブランチの一覧を表示します。</p>

<pre><code>$ git branch
  iss53
* master
  testing
</code></pre>

<p><code>*</code> という文字が <code>master</code> ブランチの先頭についていることに注目しましょう。これは、現在チェックアウトされているブランチを意味します。つまり、ここでコミットを行うと、<code>master</code> ブランチがひとつ先に進むということです。各ブランチにおける直近のコミットを調べるには <code>git branch -v</code> を実行します。</p>

<pre><code>$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes
</code></pre>

<p>各ブランチの状態を知るために便利なもうひとつの機能として、現在作業中のブランチにマージ済みかそうでないかによる絞り込みができるようになっています。Git には､そのための便利なオプション <code>--merged</code> と <code>--no-merged</code> があります。現在作業中のブランチにマージ済みのブランチを調べるには <code>git branch --merged</code> を実行します。</p>

<pre><code>$ git branch --merged
  iss53
* master
</code></pre>

<p>すでに先ほど <code>iss53</code> ブランチをマージしているので、この一覧に表示されています。このリストにあがっているブランチのうち先頭に <code>*</code> がついていないものは、通常は <code>git branch -d</code> で削除してしまって問題ないブランチです。すでにすべての作業が別のブランチに取り込まれているので、もはや何も失うことはありません。</p>

<p>まだマージされていない作業を持っているすべてのブランチを知るには、<code>git branch --no-merged</code> を実行します。</p>

<pre><code>$ git branch --no-merged
  testing
</code></pre>

<p>先ほどのブランチとは別のブランチが表示されます。まだマージしていない作業が残っているので、このブランチを <code>git branch -d</code> で削除しようとしても失敗します。</p>

<pre><code>$ git branch -d testing
error: The branch 'testing' is not fully merged.
If you are sure you want to delete it, run 'git branch -D testing'.
</code></pre>

<p>本当にそのブランチを消してしまってよいのなら <code>-D</code> で強制的に消すこともできます。……と、親切なメッセージで教えてくれていますね。</p>

<h2>ブランチでの作業の流れ</h2>

<p>ブランチとマージの基本操作はわかりましたが、ではそれを実際にどう使えばいいのでしょう? このセクションでは、気軽にブランチを切れることでどういった作業ができるようになるのかを説明します。みなさんのふだんの開発サイクルにうまく取り込めるかどうかの判断材料としてください。</p>

<h3>長期稼働用ブランチ</h3>

<p>Git では簡単に三方向のマージができるので、あるブランチから別のブランチへのマージを長期間にわたって繰り返すのも簡単なことです。つまり、複数のブランチを常にオープンさせておいて、それぞれ開発サイクルにおける別の場面用に使うということもできます。定期的にブランチ間でのマージを行うことが可能です。</p>

<p>Git 開発者の多くはこの考え方にもとづいた作業の流れを採用しています。つまり、完全に安定したコードのみを <code>master</code> ブランチに置き、いつでもリリースできる状態にしているのです。それ以外に並行して develop や next といった名前のブランチを持ち、安定性をテストするためにそこを使用します。常に安定している必要はありませんが、安定した状態になったらそれを <code>master</code> にマージすることになります。また、時にはトピックブランチ (先ほどの例の <code>iss53</code> ブランチのような短期間のブランチ) を作成し、すべてのテストに通ることやバグが発生していないことを確認することもあります。</p>

<p>実際のところ今話している内容は、一連のコミットの中のどの部分をポインタが指しているかということです。安定版のブランチはコミット履歴上の奥深くにあり、最前線のブランチは履歴上の先端にいます (図 3-18 を参照ください)。</p>

<p><img src="figures/3.18.png" title="3.18 安定したブランチほど、一般的にコミット履歴の奥深くに存在する" alt="3.18 安定したブランチほど、一般的にコミット履歴の奥深くに存在する" /></p>

<p>各ブランチを作業用のサイロと考えることもできます。一連のコミットが、完全にテストを通るようになった時点でより安定したサイロに移動するのです (図 3-19 を参照ください)。</p>

<p><img src="figures/3.19.png" title="3.19 ブランチをサイロとして考えるとわかりやすいかも" alt="3.19 ブランチをサイロとして考えるとわかりやすいかも" /></p>

<p>同じようなことを、安定性のレベルを何段階かにして行うこともできます。大規模なプロジェクトでは、<code>proposed</code> あるいは <code>pu</code> (proposed updates) といったブランチを用意して、<code>next</code> ブランチあるいは <code>master</code> ブランチに投入する前にそこでいったんブランチを統合するというようにしています。安定性のレベルに応じて何段階かのブランチを作成し、安定性が一段階上がった時点で上位レベルのブランチにマージしていくという考え方です。念のために言いますが、このように複数のブランチを常時稼働させることは必須ではありません。しかし、巨大なプロジェクトや複雑なプロジェクトに関わっている場合は便利なことでしょう。</p>

<h3>トピックブランチ</h3>

<p>一方、トピックブランチはプロジェクトの規模にかかわらず便利なものです。トピックブランチとは、短期間だけ使うブランチのことで、何か特定の機能やそれに関連する作業を行うために作成します。これは、今までの VCS では実現不可能に等しいことでした。ブランチを作成したりマージしたりという作業が非常に手間のかかることだったからです。Git では、ブランチを作成して作業をし、マージしてからブランチを削除するという流れを一日に何度も繰り返すことも珍しくありません。</p>

<p>先ほどのセクションで作成した <code>iss53</code> ブランチや <code>hotfix</code> ブランチが、このトピックブランチにあたります。ブランチ上で数回コミットし、それをメインブランチにマージしたらすぐに削除しましたね。この方法を使えば、コンテキストの切り替えを手早く完全に行うことができます。それぞれの作業が別のサイロに分離されており、そのブランチ内の変更は特定のトピックに関するものだけなのですから、コードレビューなどの作業が容易になります。一定の間ブランチで保持し続けた変更は、マージできるようになった時点で (ブランチを作成した順や作業した順に関係なく) すぐにマージしていきます。</p>

<p>次のような例を考えてみましょう。まず (<code>master</code> で) 何らかの作業をし、問題対応のために (<code>iss91</code> に) ブランチを移動し、そこでなにがしかの作業を行い、「あ、こっちのほうがよかったかも」と気づいたので新たにブランチを作成 (<code>iss91v2</code>) して思いついたことをそこで試し、いったん master ブランチに戻って作業を続け、うまくいくかどうかわからないちょっとしたアイデアを試すために新たなブランチ (<code>dumbidea</code> ブランチ) を切りました。この時点で、コミットの歴史は図 3-20 のようになります。</p>

<p><img src="figures/3.20.png" title="3.20 複数のトピックブランチを作成した後のコミットの歴史" alt="3.20 複数のトピックブランチを作成した後のコミットの歴史" /></p>

<p>最終的に、問題を解決するための方法としては二番目 (<code>iss91v2</code>) のほうがよさげだとわかりました。また、ちょっとした思いつきで試してみた <code>dumbidea</code> ブランチが意外とよさげで、これはみんなに公開すべきだと判断しました。最初の <code>iss91</code> ブランチは放棄してしまい (コミット C5 と C6 の内容は失われます)、他のふたつのブランチをマージしました。この時点で、歴史は図 3-21 のようになっています。</p>

<p><img src="figures/3.21.png" title="3.21 dumbidea と iss91v2 をマージした後の歴史" alt="3.21 dumbidea と iss91v2 をマージした後の歴史" /></p>

<p>ここで重要なのは、これまで作業してきたブランチが完全にローカル環境に閉じていたということです。ブランチを作ったりマージしたりといった作業は、すべてみなさんの Git リポジトリ内で完結しており、サーバーとのやりとりは発生していません。</p>

<h2>リモートブランチ</h2>

<p>リモートブランチは、リモートリポジトリ上のブランチの状態を指すものです。ネットワーク越しの操作をしたときに自動的に移動します。リモートブランチは、前回リモートリポジトリに接続したときにブランチがどの場所を指していたかを示すブックマークのようなものです。</p>

<p>ブランチ名は <code>(remote)/(branch)</code> のようになります。たとえば、<code>origin</code> サーバーに最後に接続したときの <code>master</code> ブランチの状態を知りたければ <code>origin/master</code> ブランチをチェックします。誰かほかの人と共同で問題に対応しており、相手が <code>iss53</code> ブランチにプッシュしたとしましょう。あなたの手元にはローカルの <code>iss53</code> ブランチがあります。しかし、サーバー側のブランチは <code>origin/iss53</code> のコミットを指しています。</p>

<p>……ちょっと混乱してきましたか? では、具体例で考えてみましょう。ネットワーク上の <code>git.ourcompany.com</code> に Git サーバーがあるとします。これをクローンすると、Git はそれに <code>origin</code> という名前をつけ、すべてのデータを引き出し、<code>master</code> ブランチを指すポインタを作成し、そのポインタにローカルで <code>origin/master</code> という名前をつけます。それを自分で移動させることはできません。Ｇit はまた、<code>master</code> というブランチも作成します。これは origin の <code>master</code> ブランチと同じ場所を指しており、ここから何らかの作業を始めます (図 3-22 を参照ください)。</p>

<p><img src="figures/3.22.png" title="3.22 git clone により、ローカルの master ブランチのほかに origin の master ブランチを指す origin/master が作られる" alt="3.22 git clone により、ローカルの master ブランチのほかに origin の master ブランチを指す origin/master が作られる" /></p>

<p>ローカルの master ブランチで何らかの作業をしている間に、誰かが <code>git.ourcompany.com</code> にプッシュして master ブランチを更新したとしましょう。この時点であなたの歴史とはことなる状態になってしまいます。また、origin サーバーと再度接続しない限り、<code>origin/master</code> が指す先は移動しません (図 3-23 を参照ください)。</p>

<p><img src="figures/3.23.png" title="3.23 ローカルで作業している間に誰かがリモートサーバーにプッシュすると、両者の歴史が異なるものとなる" alt="3.23 ローカルで作業している間に誰かがリモートサーバーにプッシュすると、両者の歴史が異なるものとなる" /></p>

<p>手元での作業を同期させるには、<code>git fetch origin</code> コマンドを実行します。このコマンドは、まず origin が指すサーバー (今回の場合は <code>git.ourcompany.com</code>) を探し、まだ手元にないデータをすべて取得し、ローカルデータベースを更新し、<code>origin/master</code> が指す先を最新の位置に変更します (図 3-24 を参照ください)。</p>

<p><img src="figures/3.24.png" title="3.24 `git fetch` コマンドによるリモートへの参照の更新" alt="3.24 `git fetch` コマンドによるリモートへの参照の更新" /></p>

<p>複数のリモートサーバーがあった場合にリモートのブランチがどのようになるのかを知るために、もうひとつ Git サーバーがあるものと仮定しましょう。こちらのサーバーは、チームの一部のメンバーが開発目的にのみ使用しています。このサーバーは <code>git.team1.ourcompany.com</code> にあるものとしましょう。このサーバーをあなたの作業中のプロジェクトから参照できるようにするには、第 2 章で紹介した <code>git remote add</code> コマンドを使用します。このリモートに <code>teamone</code> という名前をつけ、URL ではなく短い名前で参照できるようにします (図 3-25 を参照ください)。</p>

<p><img src="figures/3.25.png" title="3.25 別のサーバーをリモートとして追加" alt="3.25 別のサーバーをリモートとして追加" /></p>

<p><code>git fetch teamone</code> を実行すれば、まだ手元にないデータをリモートの <code>teamone</code> サーバーからすべて取得できるようになりました。今回､このサーバーが保持してるデータは <code>origin</code> サーバーが保持するデータの一部なので、Gitは何のデータも取得しません。代わりに､ <code>teamone/master</code> というリモートブランチが指すコミットを、<code>teamone</code> サーバーの <code>master</code> ブランチが指すコミットと同じにします｡ (図 3-26 を参照ください)。</p>

<p><img src="figures/3.26.png" title="3.26 teamone の master ブランチの位置をローカルに取得する" alt="3.26 teamone の master ブランチの位置をローカルに取得する" /></p>

<h3>プッシュ</h3>

<p>ブランチの内容をみんなと共有したくなったら、書き込み権限を持つどこかのリモートにそれをプッシュしなければなりません。ローカルブランチの内容が自動的にリモートと同期されることはありません。共有したいブランチは、明示的にプッシュする必要があります。たとえば、共有したくない内容はプライベートなブランチで作業を進め、共有したい内容だけのトピックブランチを作成してそれをプッシュするということもできます。</p>

<p>手元にある <code>serverfix</code> というブランチを他人と共有したい場合は、最初のブランチをプッシュしたときと同様の方法でそれをプッシュします。つまり <code>git push (remote) (branch)</code> を実行します。</p>

<pre><code>$ git push origin serverfix
Counting objects: 20, done.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (15/15), 1.74 KiB, done.
Total 15 (delta 5), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new branch]      serverfix -&gt; serverfix
</code></pre>

<p>これは、ちょっとしたショートカットです。Git はまずブランチ名 <code>serverfix</code> を <code>refs/heads/serverfix:refs/heads/serverfix</code> に展開します。これは「手元のローカルブランチ serverfix をプッシュして、リモートの serverfix ブランチを更新しろ」という意味です。<code>refs/heads/</code> の部分の意味については第 9 章で詳しく説明しますが、これは一般的に省略可能です。<code>git push origin serverfix:serverfix</code> とすることもできます。これも同じことで、「こっちの serverfix で、リモートの serverfix を更新しろ」という意味になります。この方式を使えば、ローカルブランチの内容をリモートにある別の名前のブランチにプッシュすることができます。リモートのブランチ名を <code>serverfix</code> という名前にしたくない場合は、<code>git push origin serverfix:awesomebranch</code> とすればローカルの <code>serverfix</code> ブランチをリモートの <code>awesomebranch</code> という名前のブランチ名でプッシュすることができます。</p>

<p>次に誰かがサーバーからフェッチしたときには、その人が取得するサーバー上の <code>serverfix</code> はリモートブランチ <code>origin/serverfix</code> となります。</p>

<pre><code>$ git fetch origin
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (14/14), done.
remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15/15), done.
From git@github.com:schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix
</code></pre>

<p>注意すべき点は、新しいリモートブランチを取得したとしても、それが自動的にローカルで編集可能になるわけではないというところです。言い換えると、この場合に新たに <code>serverfix</code> ブランチができるわけではないということです。できあがるのは <code>origin/serverfix</code> ポインタだけであり、これは変更することができません。</p>

<p>この作業を現在の作業ブランチにマージするには、<code>git merge origin/serverfix</code> を実行します。ローカル環境に <code>serverfix</code> ブランチを作ってそこで作業を進めたい場合は、リモートブランチからそれを作成します。</p>

<pre><code>$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
</code></pre>

<p>これで、<code>origin/serverfix</code> が指す先から作業を開始するためのローカルブランチができあがりました。</p>

<h3>追跡ブランチ</h3>

<p>リモートブランチからローカルブランチにチェックアウトすると、<em>追跡ブランチ (tracking branch)</em> というブランチが自動的に作成されます。追跡ブランチとは、リモートブランチと直接のつながりを持つローカルブランチのことです。追跡ブランチ上で <code>git push</code> を実行すると、Git は自動的にプッシュ先のサーバーとブランチを判断します。また、追跡ブランチ上で <code>git pull</code> を実行すると、リモートの参照先からすべてのデータを取得し、対応するリモートブランチの内容を自動的にマージします。</p>

<p>あるリポジトリをクローンしたら、自動的に <code>master</code> ブランチを作成し、<code>origin/master</code> を追跡するようになります。これが、<code>git push</code> や <code>git pull</code> が引数なしでもうまく動作する理由です。しかし、必要に応じてそれ以外の追跡ブランチを作成し、<code>origin</code> 以外にあるブランチや <code>master</code> 以外のブランチを追跡させることも可能です。シンプルな方法としては、<code>git checkout -b [branch] [remotename]/[branch]</code> を実行します。Git バージョン 1.6.2 以降では、より簡単に <code>--track</code> を使うことができます。</p>

<pre><code>$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
</code></pre>

<p>ローカルブランチをリモートブランチと違う名前にしたい場合は、最初に紹介した方法でローカルブランチに別の名前を指定します。</p>

<pre><code>$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
</code></pre>

<p>これで、ローカルブランチ <code>sf</code> が自動的に <code>origin/serverfix</code> を追跡するようになりました。</p>

<h3>リモートブランチの削除</h3>

<p>リモートブランチでの作業が終わったとしましょう。つまり、あなたや他のメンバーが一通りの作業を終え、それをリモートの <code>master</code> ブランチ (あるいは安定版のコードラインとなるその他のブランチ) にマージし終えたということです。リモートブランチを削除するコマンドは、少しわかりにくい構文ですが <code>git push [remotename] :[branch]</code> となります。サーバーの <code>serverfix</code> ブランチを削除したい場合は次のようになります。</p>

<pre><code>$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
 - [deleted]         serverfix
</code></pre>

<p>ドッカーン。これでブランチはサーバーから消えてしまいました。このページの端を折っておいたほうがいいかもしれませんね。実際にこのコマンドが必要になったときには、おそらくこの構文を忘れてしまっているでしょうから。このコマンドを覚えるコツは、少し前に説明した構文 <code>git push [remotename] [localbranch]:[remotebranch]</code> を思い出すことです。<code>[localbranch]</code> の部分をそのまま残して考えると、これは基本的に「こっちの (何もなし) で、向こうの <code>[remotebranch]</code> を更新しろ」と言っていることになります。</p>

<h2>リベース</h2>

<p>Git には、あるブランチの変更を別のブランチに統合するための方法が大きく分けて二つあります。<code>merge</code> と <code>rebase</code> です。このセクションでは、リベースについて「どういう意味か」「どのように行うのか」「なぜそんなにもすばらしいのか」「どんなときに使うのか」を説明します。</p>

<h3>リベースの基本</h3>

<p>マージについての説明で使用した例を振り返ってみましょう (図 3-27 を参照ください)。作業が二つに分岐しており、それぞれのブランチに対してコミットされていることがわかります。</p>

<p><img src="figures/3.27.png" title="3.27 分岐したコミットの歴史" alt="3.27 分岐したコミットの歴史" /></p>

<p>このブランチを統合する最も簡単な方法は、先に説明したように <code>merge</code> コマンドを使うことです。これは、二つのブランチの最新のスナップショット (C3 と C4) とそれらの共通の祖先 (C2) による三方向のマージを行い、新しいスナップショットを作成 (そしてコミット) します。その結果は図 3-28 のようになります。</p>

<p><img src="figures/3.28.png" title="3.28 分岐した作業履歴をひとつに統合する" alt="3.28 分岐した作業履歴をひとつに統合する" /></p>

<p>しかし、別の方法もあります。C3 で行った変更のパッチを取得し、それを C4 の先端に適用するのです。Git では、この作業のことを <em>リベース (rebasing)</em> と呼んでいます。<code>rebase</code> コマンドを使用すると、一方のブランチにコミットされたすべての変更をもう一方のブランチで再現することができます。</p>

<p>今回の例では、次のように実行します。</p>

<pre><code>$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
</code></pre>

<p>これは、まずふたつのブランチ (現在いるブランチとリベース先のブランチ) の共通の先祖に移動し、現在のブランチ上の各コミットの diff を取得して一時ファイルに保存し、現在のブランチの指す先をリベース先のブランチと同じコミットに移動させ、そして先ほどの変更を順に適用していきます。図 3-29 にこの手順をまとめました。</p>

<p><img src="figures/3.29.png" title="3.29 C3 での変更の C4 へのリベース" alt="3.29 C3 での変更の C4 へのリベース" /></p>

<p>この時点で、master ブランチに戻って fast-forward マージができるようになりました (図 3-30 を参照ください)。</p>

<p><img src="figures/3.30.png" title="3.30 master ブランチの Fast-forward" alt="3.30 master ブランチの Fast-forward" /></p>

<p>これで、C3' が指しているスナップショットの内容は、先ほどのマージの例で C5 が指すスナップショットと全く同じものになりました。最終的な統合結果には差がありませんが、リベースのほうがよりすっきりした歴史になります。リベース後のブランチのログを見ると、まるで一直線の歴史のように見えます。元々平行稼働していたにもかかわらず、それが一連の作業として見えるようになるのです。</p>

<p>リモートブランチ上での自分のコミットをすっきりさせるために、よくこの作業を行います。たとえば、自分がメンテナンスしているのではないプロジェクトに対して貢献したいと考えている場合などです。この場合、あるブランチ上で自分の作業を行い、プロジェクトに対してパッチを送る準備ができたらそれを <code>origin/master</code> にリベースすることになります。そうすれば、メンテナは特に統合作業をしなくても単に fast-forward するだけで済ませられるのです。</p>

<p>あなたが最後に行ったコミットが指すスナップショットは、リベースした結果の最後のコミットであってもマージ後の最終のコミットであっても同じものとなることに注意しましょう。違ってくるのは、そこに至る歴史だけです。リベースは、一方のラインの作業内容をもう一方のラインに順に適用しますが、マージの場合はそれぞれの最終地点を統合します。</p>

<h3>さらに興味深いリベース</h3>

<p>リベース先のブランチ以外でもそのリベースを再現することができます。たとえば図 3-31 のような歴史を考えてみましょう。トピックブランチ (<code>server</code>) を作成してサーバー側の機能をプロジェクトに追加し、それをコミットしました。その後、そこからさらにクライアント側の変更用のブランチ (<code>client</code>) を切って数回コミットしました。最後に、server ブランチに戻ってさらに何度かコミットを行いました。</p>

<p><img src="figures/3.31.png" title="3.31 トピックブランチからさらにトピックブランチを作成した歴史" alt="3.31 トピックブランチからさらにトピックブランチを作成した歴史" /></p>

<p>クライアント側の変更を本流にマージしてリリースしたいけれど、サーバー側の変更はまだそのままテストを続けたいという状況になったとします。クライアント側の変更のうちサーバー側にはないもの (C8 と C9) を master ブランチで再現するには、<code>git rebase</code> の <code>--onto</code> オプションを使用します。</p>

<pre><code>$ git rebase --onto master server client
</code></pre>

<p>これは「client ブランチに移動して <code>client</code> ブランチと <code>server</code> ブランチの共通の先祖からのパッチを取得し、<code>master</code> 上でそれを適用しろ」という意味になります。ちょっと複雑ですが、その結果は図 3-32 に示すように非常にクールです。</p>

<p><img src="figures/3.32.png" title="3.32 別のトピックブランチから派生したトピックブランチのリベース" alt="3.32 別のトピックブランチから派生したトピックブランチのリベース" /></p>

<p>これで、master ブランチを fast-forward することができるようになりました (図 3-33 を参照ください)。</p>

<pre><code>$ git checkout master
$ git merge client
</code></pre>

<p><img src="figures/3.33.png" title="3.33 master ブランチを fast-forward し、client ブランチの変更を含める" alt="3.33 master ブランチを fast-forward し、client ブランチの変更を含める" /></p>

<p>さて、いよいよ server ブランチのほうも取り込む準備ができました。server ブランチの内容を master ブランチにリベースする際には、事前にチェックアウトする必要はなく <code>git rebase [basebranch] [topicbranch]</code> を実行するだけでだいじょうぶです。このコマンドは、トピックブランチ (ここでは <code>server</code>) をチェックアウトしてその変更をベースブランチ (<code>master</code>) 上に再現します。</p>

<pre><code>$ git rebase master server
</code></pre>

<p>これは、<code>server</code> での作業を <code>master</code> の作業に続け、結果は図 3-34 のようになります。</p>

<p><img src="figures/3.34.png" title="3.34 server ブランチを master ブランチ上にリベースする" alt="3.34 server ブランチを master ブランチ上にリベースする" /></p>

<p>これで、ベースブランチ (<code>master</code>) を fast-forward することができます。</p>

<pre><code>$ git checkout master
$ git merge server
</code></pre>

<p>ここで <code>client</code> ブランチと <code>server</code> ブランチを削除します。すべての作業が取り込まれたので、これらのブランチはもはや不要だからです。これらの処理を済ませた結果、最終的な歴史は図 3-35 のようになりました。</p>

<pre><code>$ git branch -d client
$ git branch -d server
</code></pre>

<p><img src="figures/3.35.png" title="3.35 最終的なコミット履歴" alt="3.35 最終的なコミット履歴" /></p>

<h3>ほんとうは怖いリベース</h3>

<p>あぁ、このすばらしいリベース機能。しかし、残念ながら欠点もあります。その欠点はほんの一行でまとめることができます。</p>

<p><strong>公開リポジトリにプッシュしたコミットをリベースしてはいけない</strong></p>

<p>この指針に従っている限り、すべてはうまく進みます。もしこれを守らなければ、あなたは嫌われ者となり、友人や家族からも軽蔑されることになるでしょう。</p>

<p>リベースをすると、既存のコミットを破棄して新たなコミットを作成することになります。新たに作成したコミットは破棄したものと似てはいますが別物です。あなたがどこかにプッシュしたコミットを誰かが取得してその上で作業を始めたとしましょう。あなたが <code>git rebase</code> でそのコミットを書き換えて再度プッシュすると、相手は再びマージすることになります。そして相手側の作業を自分の環境にプルしようとするとおかしなことになってしまします。</p>

<p>いったん公開した作業をリベースするとどんな問題が発生するのか、例を見てみましょう。中央サーバーからクローンした環境上で何らかの作業を進めたものとします。現在のコミット履歴は図 3-36 のようになっています。</p>

<p><img src="figures/3.36.png" title="3.36 リポジトリをクローンし、なんらかの作業をすませた状態" alt="3.36 リポジトリをクローンし、なんらかの作業をすませた状態" /></p>

<p>さて、誰か他の人が、マージを含む作業をしてそれを中央サーバーにプッシュしました。それを取得し、リモートブランチの内容を作業環境にマージすると、図 3-37 のような状態になります。</p>

<p><img src="figures/3.37.png" title="3.37 さらなるコミットを取得し、作業環境にマージした状態" alt="3.37 さらなるコミットを取得し、作業環境にマージした状態" /></p>

<p>次に、さきほどマージした作業をプッシュした人が、気が変わったらしく新たにリベースし直したようです。なんと <code>git push --force</code> を使ってサーバー上の歴史を上書きしてしまいました。あなたはもう一度サーバーにアクセスし、新しいコミットを手元に取得します。</p>

<p><img src="figures/3.38.png" title="3.38 誰かがリベースしたコミットをプッシュし、あなたの作業環境の元になっているコミットが破棄された" alt="3.38 誰かがリベースしたコミットをプッシュし、あなたの作業環境の元になっているコミットが破棄された" /></p>

<p>ここであなたは、新しく取得した内容をまたマージしなければなりません。すでにマージ済みのはずであるにもかかわらず。リベースを行うとコミットの SHA-1 ハッシュが変わってしまうので、Git はそれを新しいコミットと判断します。実際のところ C4 の作業は既に取り込み済みなのですが (図 3-39 を参照ください)。</p>

<p><img src="figures/3.39.png" title="3.39 同じ作業を再びマージして新たなマージコミットを作成する" alt="3.39 同じ作業を再びマージして新たなマージコミットを作成する" /></p>

<p>今後の他の開発者の作業を追いかけていくために、今回のコミットもマージする必要があります。そうすると、あなたのコミット履歴には C4 と C4' の両方のコミットが含まれることになります。これらは SHA-1 ハッシュが異なるだけで、作業内容やコミットメッセージは同じものです。このような状態の歴史の上で <code>git log</code> を実行すると、同じ人による同じ日付で同じメッセージのコミットがふたつ登場することになり、混乱します。さらに、この歴史をサーバーにプッシュすると、リベースしたコミットを再び中央サーバーに戻すことになってしまい、混乱する人がさらに増えます。</p>

<p>リベースはあくまでもプッシュする前のコミットをきれいにするための方法であるととらえ、リベースするのはまだ公開していないコミットのみに限定するようにしている限りはすべてがうまく進みます。もしいったんプッシュした後のコミットをリベースしてしまい、どこか他のところでそのコミットを元に作業を進めている人がいたとすると、やっかいなトラブルに巻き込まれることになるでしょう。</p>

<h2>まとめ</h2>

<p>本章では、Git におけるブランチとマージの基本について取り上げました。新たなブランチの作成、ブランチの切り替え、ローカルブランチのマージなどの作業が気軽にできるようになったことでしょう。また、ブランチを共有サーバーにプッシュして公開したり他の共有ブランチ上で作業をしたり、公開する前にブランチをリベースしたりする方法を身につけました。</p>
<h1>Git サーバー</h1>

<p>ここまで読んだみなさんは、ふだん Git を使う上で必要になるタスクのほとんどを身につけたことでしょう。しかし、Git で何らかの共同作業をしようと思えばリモートの Git リポジトリを持つ必要があります。個人リポジトリとの間でのプッシュやプルも技術的には可能ですが、お勧めしません。よっぽど気をつけておかないと、ほかの人がどんな作業をしているのかをすぐに見失ってしまうからです。さらに、自分のコンピューターがオフラインのときにもほかの人が自分のリポジトリにアクセスできるようにしたいとなると、共有リポジトリを持つほうがずっと便利です。というわけで、他のメンバーとの共同作業をするときには、中間リポジトリをどこかに用意してみんながそこにアクセスできるようにし、プッシュやプルを行うようにすることをお勧めします。本書ではこの手のリポジトリのことを "Git サーバー" と呼ぶことにします。しかし、一般的に Git リポジトリをホストするのに必要なリソースはほんの少しだけです。それ専用のサーバーをわざわざ用意する必要はまずありません。</p>

<p>Git サーバーを立ち上げるのは簡単です。まず、サーバーとの通信にどのプロトコルを使うのかを選択します。この章の最初のセクションで、どんなプロトコルが使えるのかとそれぞれのプロトコルの利点・欠点を説明します。その次のセクションでは、それぞれのプロトコルを使用したサーバーの設定方法とその動かし方を説明します。最後に、ホスティングサービスについて紹介します。他人のサーバー上にコードを置くのが気にならない、そしてサーバーの設定だの保守だのといった面倒なことはやりたくないという人のためのものです。</p>

<p>自前でサーバーを立てることには興味がないという人は、この章は最後のセクションまで読み飛ばし、ホスティングサービスに関する情報だけを読めばよいでしょう。そして次の章に進み、分散ソース管理環境での作業について学びます。</p>

<p>リモートリポジトリは、一般的に <em>ベアリポジトリ</em> となります。これは、作業ディレクトリをもたない Git リポジトリのことです。このリポジトリは共同作業の中継地点としてのみ用いられるので、ディスク上にスナップショットをチェックアウトする必要はありません。単に Git のデータがあればそれでよいのです。端的に言うと、ベアリポジトリとはそのプロジェクトの <code>.git</code> ディレクトリだけで構成されるもののことです。</p>

<h2>プロトコル</h2>

<p>Git では、データ転送用のネットワークプロトコルとして Local、Secure Shell (SSH)、Git そして HTTP の四つを使用できます。ここでは、それぞれがどんなものなのかとどんな場面で使うべきか (使うべきでないか) を説明します。</p>

<p>注意すべき点として、HTTP 以外のすべてのプロトコルは、サーバー上に Git がインストールされている必要があります。</p>

<h3>Local プロトコル</h3>

<p>一番基本的なプロトコルが <em>Local プロトコル</em> です。これは、リモートリポジトリをディスク上の別のディレクトリに置くものです。これがよく使われるのは、たとえばチーム全員がアクセスできる共有ファイルシステム (NFS など) がある場合です。あるいは、あまりないでしょうが全員が同じコンピューターにログインしている場合にも使えます。後者のパターンはあまりお勧めできません。すべてのコードリポジトリが同じコンピューター上に存在することになるので、何か事故が起こったときに何もかも失ってしまう可能性があります。</p>

<p>共有ファイルシステムをマウントしているのなら、それをローカルのファイルベースのリポジトリにクローンしたりお互いの間でプッシュやプルをしたりすることができます。この手のリポジトリをクローンしたり既存のプロジェクトのリモートとして追加したりするには、リポジトリへのパスを URL に指定します。たとえば、ローカルリポジトリにクローンするにはこのようなコマンドを実行します。</p>

<pre><code>$ git clone /opt/git/project.git
</code></pre>

<p>あるいは次のようにすることもできます。</p>

<pre><code>$ git clone file:///opt/git/project.git
</code></pre>

<p>URL の先頭に <code>file://</code> を明示するかどうかで、Git の動きは微妙に異なります。<code>file://</code> を明示せずパスだけを指定し、かつコピー元とコピー先が同一のファイルシステム上にある場合は、Git は必要なオブジェクトにハードリンクを張ろうとします。もし異なるファイルシステム上にある場合は、Git はシステムデフォルトのファイルコピー機能を使って必要なオブジェクトをコピーします。一方 <code>file://</code> を指定した場合は、Git がプロセスを立ち上げ、そのプロセスが (通常は) ネットワーク越しにデータを転送します。一般的に、直接のコピーに比べてこれは非常に非効率的です。<code>file://</code> プレフィックスをつける最も大きな理由は、(他のバージョン管理システムからインポートしたときなどにあらわれる) 関係のない参照やオブジェクトを除いたクリーンなコピーがほしいということです。本書では通常のパス表記を使用します。そのほうがたいていの場合に高速となるからです。</p>

<p>ローカルのリポジトリを既存の Git プロジェクトに追加するには、このようなコマンドを実行します。</p>

<pre><code>$ git remote add local_proj /opt/git/project.git
</code></pre>

<p>そうすれば、このリモートとの間のプッシュやプルを、まるでネットワーク越しにあるのと同じようにすることができます。</p>

<h4>利点</h4>

<p>ファイルベースのリポジトリの利点は、シンプルであることと既存のファイルアクセス権やネットワークアクセスを流用できることです。チーム全員がアクセスできる共有ファイルシステムがすでに存在するのなら、リポジトリを用意するのは非常に簡単です。ベアリポジトリのコピーをみんながアクセスできるどこかの場所に置き、読み書き可能な権限を与えるという、ごく普通の共有ディレクトリ上での作業です。この作業のために必要なベアリポジトリをエクスポートする方法については次のセクション「Git サーバーの取得」で説明します。</p>

<p>もうひとつ、ほかの誰かの作業ディレクトリの内容をすばやく取り込めるのも便利なところです。同僚と作業しているプロジェクトで相手があなたに作業内容を確認してほしい言ってきたときなど、わざわざリモートのサーバーにプッシュしてもらってそれをプルするよりは単に <code>git pull /home/john/project</code> のようなコマンドを実行するほうがずっと簡単です。</p>

<h4>欠点</h4>

<p>この方式の欠点は、メンバーが別の場所にいるときに共有アクセスを設定するのは一般的に難しいということです。自宅にいるときに自分のラップトップからプッシュしようとしたら、リモートディスクをマウントする必要があります。これはネットワーク越しのアクセスに比べて困難で遅くなるでしょう。</p>

<p>また、何らかの共有マウントを使用している場合は、必ずしもこの方式が最高速となるわけではありません。ローカルリポジトリが高速だというのは、単にデータに高速にアクセスできるからというだけの理由です。NFS 上に置いたリポジトリは、同じサーバーで稼動しているリポジトリに SSH でアクセスしたときよりも遅くなりがちです。SSH でアクセスしたときは、各システムのローカルディスクにアクセスすることになるからです。</p>

<h3>SSH プロトコル</h3>

<p>Git の転送プロトコルのうちもっとも一般的なのが SSH でしょう。SSH によるサーバーへのアクセスは、ほとんどの場面で既に用意されているからです。仮にまだ用意されていなかったとしても、導入するのは容易なことです。また SSH は、ネットワークベースの Git 転送プロトコルの中で、容易に読み書き可能な唯一のものです。その他のネットワークプロトコル (HTTP および Git) は一般的に読み込み専用で用いるものです。不特定多数向けにこれらのプロトコルを開放したとしても、書き込みコマンドを実行するためには SSH が必要となります。SSH は認証付きのネットワークプロトコルでもあります。あらゆるところで用いられているので、環境を準備するのも容易です。</p>

<p>Git リポジトリを SSH 越しにクローンするには、次のように ssh:// URL を指定します。</p>

<pre><code>$ git clone ssh://user@server/project.git
</code></pre>

<p>あるいは、SCPコマンドのような省略形を使うこともできます｡</p>

<pre><code>$ git clone user@server:project.git
</code></pre>

<p>ユーザー名も省略することもできます。その場合、Git は現在ログインしているユーザーでの接続を試みます。</p>

<h4>利点</h4>

<p>SSH を使う利点は多数あります。まず、ネットワーク越しでのリポジトリへの書き込みアクセスで認証が必要となる場面では、基本的にこのプロトコルを使わなければなりません。次に、一般的に SSH 環境の準備は容易です。SSH デーモンはごくありふれたツールなので、ネットワーク管理者の多くはその使用経験があります。また、多くの OS に標準で組み込まれており、管理用ツールが付属しているものもあります。さらに、SSH 越しのアクセスは安全です。すべての転送データは暗号化され、信頼できるものとなります。最後に、Git プロトコルや Local プロトコルと同程度に効率的です。転送するデータを可能な限りコンパクトにすることができます。</p>

<h4>欠点</h4>

<p>SSH の欠点は、リポジトリへの匿名アクセスを許可できないということです。たとえ読み込み専用であっても、リポジトリにアクセスするには SSH 越しでのマシンへのアクセス権限が必要となります。つまり、オープンソースのプロジェクトにとっては SSH はあまりうれしくありません。特定の企業内でのみ使用するのなら、SSH はおそらく唯一の選択肢となるでしょう。あなたのプロジェクトに読み込み専用の匿名アクセスを許可したい場合は、リポジトリへのプッシュ用に SSH を用意するのとは別にプル用の環境として別のプロトコルを提供する必要があります。</p>

<h3>Git プロトコル</h3>

<p>次は Git プロトコルです。これは Git に標準で付属する特別なデーモンです。専用のポート (9418) をリスンし、SSH プロトコルと同様のサービスを提供しますが、認証は行いません。Git プロトコルを提供するリポジトリを準備するには、<code>git-daemon-export-ok</code> というファイルを作らなければなりません (このファイルがなければデーモンはサービスを提供しません)。ただ、このままでは一切セキュリティはありません。Git リポジトリをすべての人に開放し、クローンさせることができます。しかし、一般に、このプロトコルでプッシュさせることはありません。プッシュアクセスを認めることは可能です。しかし認証がないということは、その URL を知ってさえいればインターネット上の誰もがプロジェクトにプッシュできるということになります。これはありえない話だと言っても差し支えないでしょう。</p>

<h4>利点</h4>

<p>Git プロトコルは、もっとも高速な転送プロトコルです。公開プロジェクトで大量のトラフィックをさばいている場合、あるいは巨大なプロジェクトで読み込みアクセス時のユーザー認証が不要な場合は、Git デーモンを用いてリポジトリを公開するとよいでしょう。このプロトコルは SSH プロトコルと同様のデータ転送メカニズムを使いますが、暗号化と認証のオーバーヘッドがないのでより高速です。</p>

<h4>欠点</h4>

<p>Git プロトコルの弱点は、認証の仕組みがないことです。Git プロトコルだけでしかプロジェクトにアクセスできないという状況は、一般的に望ましくありません。SSH と組み合わせ、プッシュ (書き込み) 権限を持つ一部の開発者には SSH を使わせてそれ以外の人には <code>git://</code> での読み込み専用アクセスを用意することになるでしょう。また、Git プロトコルは準備するのがもっとも難しいプロトコルでもあります。まず、独自のデーモンを起動しなければなりません (この章の“Gitosis”のところで詳しく説明します)。そのためには <code>xinetd</code> やそれに類するものの設定も必要になりますが、これはそんなにお手軽にできるものではありません。また、ファイアウォールでポート 9418 のアクセスを許可する必要もあります。これは標準のポートではないので、企業のファイアウォールでは許可されなていないかもしれません。大企業のファイアウォールでは、こういったよくわからないポートは普通ブロックされています。</p>

<h3>HTTP/S プロトコル</h3>

<p>最後は HTTP プロトコルです。HTTP あるいは HTTPS のうれしいところは、準備するのが簡単だという点です。基本的に、必要な作業といえば Git リポジトリを HTTP のドキュメントルート以下に置いて <code>post-update</code> フックを用意することだけです (Git のフックについては第 7 章で詳しく説明します)。これで、ウェブサーバー上のその場所にアクセスできる人ならだれでもリポジトリをクローンできるようになります。リポジトリへの HTTP での読み込みアクセスを許可するには、こんなふうにします。</p>

<pre><code>$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
</code></pre>

<p>これだけです。Git に標準でついてくる <code>post-update</code> フックは、適切なコマンド (<code>git update-server-info</code>) を実行して HTTP でのフェッチとクローンをうまく動くようにします。このコマンドが実行されるのは、このリポジトリに対して SSH 越しでのプッシュがあったときです。その他の人たちがクローンする際には次のようにします。</p>

<pre><code>$ git clone http://example.com/gitproject.git
</code></pre>

<p>今回の例ではたまたま <code>/var/www/htdocs</code> (一般的な Apache の標準設定) を使用しましたが、別にそれに限らず任意のウェブサーバーを使うことができます。単にベアリポジトリをそのパスに置けばよいだけです。Git のデータは、普通の静的ファイルとして扱われます (実際のところどのようになっているかの詳細は第 9 章を参照ください)。</p>

<p>HTTP 越しの Git のプッシュを行うことも可能ですが、あまり使われていません。また、これには複雑な WebDAV の設定が必要です。めったに使われることがないので、本書では取り扱いません。HTTP でのプッシュに興味があるかたのために、それ用のリポジトリを準備する方法が <code>http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt</code> で公開されています。HTTP 越しでの Git のプッシュに関して、よいお知らせがひとつあります。どんな WebDAV サーバーでも使うことが可能で、特に Git ならではの機能は必要ありません。つまり、もしプロバイダが WebDAV によるウェブサイトの更新に対応しているのなら、それを使用することができます。</p>

<h4>利点</h4>

<p>HTTP を使用する利点は、簡単にセットアップできるということです。便利なコマンドで、Git リポジトリへの読み取りアクセスを全世界に公開できます。ものの数分で用意できることでしょう。また、HTTP はサーバー上のリソースを激しく使用することはありません。すべてのデータは HTTP サーバー上の静的なファイルとして扱われます。普通の Apache サーバーは毎秒数千ファイルぐらいは余裕でさばくので、小規模サーバーであったとしても (Git リポジトリへのへのアクセスで) サーバーが過負荷になることはないでしょう。</p>

<p>HTTPS で読み込み専用のリポジトリを公開することもできます。これで、転送されるコンテンツを暗号化したりクライアント側で特定の署名つき SSL 証明書を使わせたりすることができるようになります。そこまでやるぐらいなら SSH の公開鍵を使うほうが簡単ではありますが、場合によっては署名入り SSL 証明書やその他の HTTP ベースの認証方式を使った HTTPS での読み込み専用アクセスを使うこともあるでしょう。</p>

<p>もうひとつの利点としてあげられるのは、HTTP が非常に一般的なプロトコルであるということです。たいていの企業のファイアウォールはこのポートを通すように設定されています。</p>

<h4>欠点</h4>

<p>HTTP によるリポジトリの提供の問題点は、クライアント側から見て非効率的だということです。リポジトリのフェッチやクローンには非常に時間がかかります。また、他のネットワークプロトコルにくらべてネットワークのオーバーヘッドや転送量が非常に増加します。必要なデータだけをやりとりするといった賢い機能はない (サーバー側で転送時になんらかの作業をすることができない) ので、HTTP はよく <em>ダム (dumb)</em> プロトコルなどと呼ばれています。HTTP とその他のプロトコルの間の効率の違いに関する詳細な情報は、第 9 章を参照ください。</p>

<h2>サーバー用の Git の取得</h2>

<p>Git サーバーを立ち上げるには、既存のリポジトリをエクスポートして新たなベアリポジトリ (作業ディレクトリを持たないリポジトリ) を作らなければなりません。これは簡単にできます。リポジトリをクローンして新たにベアリポジトリを作成するには、clone コマンドでオプション <code>--bare</code> を指定します。慣例により、ベアリポジトリのディレクトリ名の最後は <code>.git</code> とすることになっています。</p>

<pre><code>$ git clone --bare my_project my_project.git
Cloning into bare repository 'my_project.git'...
done.
</code></pre>

<p>そうすると、Git ディレクトリのデータを <code>my_project.git</code> ディレクトリにコピーできます。</p>

<p>これは、おおざっぱに言うと次の操作と同じようなことです。</p>

<pre><code>$ cp -Rf my_project/.git my_project.git
</code></pre>

<p>設定ファイルにはちょっとした違いもありますが、ほぼこんなものです。作業ディレクトリなしで Git リポジトリを受け取り、それ単体のディレクトリを作成しました。</p>

<h3>ベアリポジトリのサーバー上への設置</h3>

<p>ベアリポジトリを取得できたので、あとはそれをサーバー上においてプロトコルを準備するだけです。ここでは、<code>git.example.com</code> というサーバーがあってそこに SSH でアクセスできるものと仮定しましょう。Git リポジトリはサーバー上の <code>/opt/git</code> ディレクトリに置く予定です。新しいリポジトリを作成するには、ベアリポジトリを次のようにコピーします。</p>

<pre><code>$ scp -r my_project.git user@git.example.com:/opt/git
</code></pre>

<p>この時点で、同じサーバーに SSH でアクセスできてかつ <code>/opt/git</code> ディレクトリへの読み込みアクセス権限がある人なら、次のようにしてこのリポジトリをクローンできるようになりました。</p>

<pre><code>$ git clone user@git.example.com:/opt/git/my_project.git
</code></pre>

<p>ユーザーが SSH でアクセスでき、かつ <code>/opt/git/my_project.git</code> ディレクトリへの書き込みアクセス権限があれば、すでにプッシュもできる状態になっています。<code>git init</code> コマンドで <code>--shared</code> オプションを指定すると、リポジトリに対するグループ書き込みパーミッションを自動的に追加することができます。</p>

<pre><code>$ ssh user@git.example.com
$ cd /opt/git/my_project.git
$ git init --bare --shared
</code></pre>

<p>既存の Git リポジトリからベアリポジトリを作成し、メンバーが SSH でアクセスできるサーバーにそれを配置するだけ。簡単ですね。これで、そのプロジェクトでの共同作業ができるようになりました。</p>

<p>複数名が使用する Git サーバーをたったこれだけの作業で用意できるというのは特筆すべきことです。サーバー SSH アクセス可能なアカウントを作成し、ベアリポジトリをサーバーのどこかに置き、そこに読み書き可能なアクセス権を設定する。これで準備OK。他には何もいりません。</p>

<p>次のいくつかのセクションでは、より洗練された環境を作るための方法を説明します。いちいちユーザーごとにアカウントを作らなくて済む方法、一般向けにリポジトリへの読み込みアクセスを開放する方法、ウェブ UI の設定、Gitosis の使い方などです。しかし、数名のメンバーで閉じたプロジェクトでの作業なら、SSH サーバーとベアリポジトリ <em>さえ</em> あれば十分なことは覚えておきましょう。</p>

<h3>ちょっとしたセットアップ</h3>

<p>小規模なグループ、あるいは数名の開発者しかいない組織で Git を使うなら、すべてはシンプルに進められます。Git サーバーを準備する上でもっとも複雑なことのひとつは、ユーザー管理です。同一リポジトリに対して「このユーザーは読み込みのみが可能、あのユーザーは読み書きともに可能」などと設定したければ、アクセス権とパーミッションの設定は多少難しくなります。</p>

<h4>SSH アクセス</h4>

<p>開発者全員が SSH でアクセスできるサーバーがすでにあるのなら、リポジトリを用意するのは簡単です。先ほど説明したように、ほとんど何もする必要はないでしょう。より複雑なアクセス制御をリポジトリ上で行いたい場合は、そのサーバーの OS 上でファイルシステムのパーミッションを設定するとよいでしょう。</p>

<p>リポジトリに対する書き込みアクセスをさせたいメンバーの中にサーバーのアカウントを持っていない人がいる場合は、新たに SSH アカウントを作成しなければなりません。あなたがサーバーにアクセスできているということは、すでに SSH サーバーはインストールされているということです。</p>

<p>その状態で、チームの全員にアクセス権限を与えるにはいくつかの方法があります。ひとつは全員分のアカウントを作成すること。直感的ですがすこし面倒です。ひとりひとりに対して <code>adduser</code> を実行して初期パスワードを設定するという作業をしなければなりません。</p>

<p>もうひとつの方法は、'git' ユーザーをサーバー上に作成し、書き込みアクセスが必要なユーザーには SSH 公開鍵を用意してもらってそれを 'git' ユーザーの <code>~/.ssh/authorized_keys</code> に追加します。これで、全員が 'git' ユーザーでそのマシンにアクセスできるようになりました。これがコミットデータに影響を及ぼすことはありません。SSH で接続したときのユーザーとコミットするときに記録されるユーザーとは別のものだからです。</p>

<p>あるいは、SSH サーバーの認証を LDAP サーバーやその他の中央管理形式の仕組みなど既に用意されているものにするとこもできます。各ユーザーがサーバー上でシェルへのアクセスができさえすれば、どんな仕組みの SSH 認証であっても動作します。</p>

<h2>SSH 公開鍵の作成</h2>

<p>多くの Git サーバーでは、SSH の公開鍵認証を使用しています。この方式を使用するには、各ユーザーが自分の公開鍵を作成しなければなりません。公開鍵のつくりかたは、OS が何であってもほぼ同じです。まず、自分がすでに公開鍵を持っていないかどうか確認します。デフォルトでは、各ユーザーの SSH 鍵はそのユーザーの <code>~/.ssh</code> ディレクトリに置かれています。自分が鍵を持っているかどうかを確認するには、このディレクトリに行ってその中身を調べます。</p>

<pre><code>$ cd ~/.ssh
$ ls
authorized_keys2  id_dsa       known_hosts
config            id_dsa.pub
</code></pre>

<p>そして「○○」「○○.pub」というファイル名の組み合わせを探します。「○○」の部分は、通常は <code>id_dsa</code> あるいは <code>id_rsa</code> となります。もし見つかったら、<code>.pub</code> がついているほうのファイルがあなたの公開鍵で、もう一方があなたの秘密鍵です。そのようなファイルがない (あるいはそもそも <code>.ssh</code> ディレクトリがない) 場合は、<code>ssh-keygen</code> というプログラムを実行してそれを作成します。このプログラムは Linux/Mac なら SSH パッケージに含まれており、Windows では MSysGit パッケージに含まれています。</p>

<pre><code>$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/schacon/.ssh/id_rsa.
Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local
</code></pre>

<p>まず、鍵の保存先 (<code>.ssh/id_rsa</code>) を指定し、それからパスフレーズを二回入力するよう求められます。鍵を使うときにパスフレーズを入力したくない場合は、パスフレーズを空のままにしておきます。</p>

<p>さて、次に各ユーザーは自分の公開鍵をあなた (あるいは Git サーバーの管理者である誰か) に送らなければなりません (ここでは、すでに公開鍵認証を使用するように SSH サーバーが設定済みであると仮定します)。公開鍵を送るには、<code>.pub</code> ファイルの中身をコピーしてメールで送ります。公開鍵は、このようなファイルになります。</p>

<pre><code>$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@agadorlaptop.local
</code></pre>

<p>各種 OS 上での SSH 鍵の作り方については、GitHub の <code>http://github.com/guides/providing-your-ssh-key</code> に詳しく説明されています。</p>

<h2>サーバーのセットアップ</h2>

<p>それでは、サーバー側での SSH アクセスの設定について順を追って見ていきましょう。この例では <code>authorized_keys</code> 方式でユーザーの認証を行います。また、Ubuntu のような標準的な Linux ディストリビューションを動かしているものと仮定します。まずは 'git' ユーザーを作成し、そのユーザーの <code>.ssh</code> ディレクトリを作りましょう。</p>

<pre><code>$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh
</code></pre>

<p>次に、開発者たちの SSH 公開鍵をそのユーザーの <code>authorized_keys</code> に追加していきましょう。受け取った鍵が一時ファイルとして保存されているものとします。先ほどもごらんいただいたとおり、公開鍵の中身はこのような感じになっています。</p>

<pre><code>$ cat /tmp/id_rsa.john.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair
</code></pre>

<p>これを <code>authorized_keys</code> に追加していきましょう。</p>

<pre><code>$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>

<p>さて、彼らが使うための空のリポジトリを作成しましょう。<code>git init</code> に <code>--bare</code> オプションを指定して実行すると、作業ディレクトリのない空のリポジトリを初期化します。</p>

<pre><code>$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git --bare init
</code></pre>

<p>これで、John と Josie そして Jessica はプロジェクトの最初のバージョンをプッシュできるようになりました。このリポジトリをリモートとして追加し、ブランチをプッシュすればいいのです。何か新しいプロジェクトを追加しようと思ったら、そのたびに誰かがサーバーにログインし、ベアリポジトリを作らなければならないことに注意しましょう。'git' ユーザーとリポジトリを作ったサーバーのホスト名を <code>gitserver</code> としておきましょう。<code>gitserver</code> がそのサーバーを指すように DNS を設定しておけば、このようなコマンドを使えます。</p>

<pre><code># John のコンピューターで
$ cd myproject
$ git init
$ git add .
$ git commit -m 'initial commit'
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master
</code></pre>

<p>これで、他のメンバーがリポジトリをクローンして変更内容を書き戻せるようになりました。</p>

<pre><code>$ git clone git@gitserver:/opt/git/project.git
$ cd project
$ vim README
$ git commit -am 'fix for the README file'
$ git push origin master
</code></pre>

<p>この方法を使えば、小規模なチーム用の読み書き可能な Git サーバーをすばやく立ち上げることができます。</p>

<p>万一の場合に備えて 'git' ユーザーができることを制限するのも簡単で、Git に関する作業しかできない制限付きシェル <code>git-shell</code> が Git に付属しています。これを 'git' ユーザーのログインシェルにしておけば、'git' ユーザーはサーバーへの通常のシェルアクセスができなくなります。これを使用するには、ユーザーのログインシェルとして bash や csh ではなく <code>git-shell</code> を指定します。そのためには <code>/etc/passwd</code> ファイルを編集しなければなりません。</p>

<pre><code>$ sudo vim /etc/passwd
</code></pre>

<p>いちばん最後に、このような行があるはずです。</p>

<pre><code>git:x:1000:1000::/home/git:/bin/sh
</code></pre>

<p>ここで <code>/bin/sh</code> を <code>/usr/bin/git-shell</code> (<code>which git-shell</code> を実行してインストール先を探し、それを指定します) に変更します。変更後はこのようになるでしょう。</p>

<pre><code>git:x:1000:1000::/home/git:/usr/bin/git-shell
</code></pre>

<p>これで、'git' ユーザーは Git リポジトリへのプッシュやプル以外のシェル操作ができなくなりました。それ以外の操作をしようとすると、このように拒否されます。</p>

<pre><code>$ ssh git@gitserver
fatal: What do you think I am? A shell?
Connection to gitserver closed.
</code></pre>

<h2>一般公開</h2>

<p>匿名での読み込み専用アクセス機能を追加するにはどうしたらいいでしょうか? 身内に閉じたプロジェクトではなくオープンソースのプロジェクトを扱うときに、これを考えることになります。あるいは、自動ビルドや継続的インテグレーション用に大量のサーバーが用意されており、それがしばしば入れ替わるという場合など。単なる読み込み専用の匿名アクセスのためだけに毎回 SSH 鍵を作成しなければならないのは大変です。</p>

<p>おそらく一番シンプルな方法は、静的なウェブサーバーを立ち上げてそのドキュメントルートに Git リポジトリを置き、本章の最初のセクションで説明した <code>post-update</code> フックを有効にすることです。先ほどの例を続けてみましょう。リポジトリが <code>/opt/git</code> ディレクトリにあり、マシン上で Apache が稼働中であるものとします。念のために言いますが、別に Apache に限らずどんなウェブサーバーでも使えます。しかしここでは、Apache の設定を例にして何が必要なのかを説明していきます。</p>

<p>まずはフックを有効にします。</p>

<pre><code>$ cd project.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
</code></pre>

<p>この <code>post-update</code> は、いったい何をするのでしょうか? その中身はこのようになります。</p>

<pre><code>$ cat .git/hooks/post-update
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".
#

exec git-update-server-info
</code></pre>

<p>SSH 経由でサーバーへのプッシュが行われると、Git はこのコマンドを実行し、HTTP 経由での取得に必要なファイルを更新します。</p>

<p>次に、Apache の設定に VirtualHost エントリを追加して Git プロジェクトのディレクトリをドキュメントルートに設定します。ここでは、ワイルドカード DNS を設定して <code>*.gitserver</code> へのアクセスがすべてこのマシンに来るようになっているものとします。</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName git.gitserver
    DocumentRoot /opt/git
    &lt;Directory /opt/git/&gt;
        Order allow, deny
        allow from all
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>また、<code>/opt/git</code> ディレクトリの所有グループを <code>www-data</code> にし、ウェブサーバーがこのリポジトリにアクセスできるようにしなければなりません。CGI スクリプトを実行する Apache インスタンスのユーザー権限で動作することになるからです。</p>

<pre><code>$ chgrp -R www-data /opt/git
</code></pre>

<p>Apache を再起動すれば、プロジェクトの URL を指定してリポジトリのクローンができるようになります。</p>

<pre><code>$ git clone http://git.gitserver/project.git
</code></pre>

<p>この方法を使えば、多数のユーザーに HTTP での読み込みアクセス権を与える設定がたった数分でできあがります。多数のユーザーに認証なしでのアクセスを許可するためのもうひとつの方法として、Git デーモンを立ち上げることもできます。しかし、その場合はプロセスをデーモン化させなければなりません。その方法については次のセクションで説明します。</p>

<h2>GitWeb</h2>

<p>これで、読み書き可能なアクセス方法と読み込み専用のアクセス方法を用意できるようになりました。次にほしくなるのは、ウェブベースでの閲覧方法でしょうか。Git には標準で GitWeb という CGI スクリプトが付属しており、これを使うことができます。GitWeb の使用例は、たとえば <code>http://git.kernel.org</code> で確認できます (図 4-1 を参照ください)。</p>

<p><img src="figures/4.1.png" title="4.1 GitWeb のユーザーインターフェイス" alt="4.1 GitWeb のユーザーインターフェイス" /></p>

<p>自分のプロジェクトでためしに GitWeb を使ってみようという人のために、一時的なインスタンスを立ち上げるためのコマンドが Git に付属しています。これを実行するには <code>lighttpd</code> や <code>webrick</code> といった軽量なサーバーが必要です。Linux マシンなら、たいてい <code>lighttpd</code> がインストールされています。これを実行するには、プロジェクトのディレクトリで <code>git instaweb</code> と打ち込みます。Mac の場合なら、Leopard には Ruby がプレインストールされています。したがって <code>webrick</code> が一番よい選択肢でしょう。<code>instaweb</code> を lighttpd 以外で実行するには、<code>--httpd</code> オプションを指定します。</p>

<pre><code>$ git instaweb --httpd=webrick
[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]
</code></pre>

<p>これは、HTTPD サーバーをポート 1234 で起動させ、自動的にウェブブラウザーを立ち上げてそのページを表示させます。非常にお手軽です。ひととおり見終えてサーバーを終了させたくなったら、同じコマンドに <code>--stop</code> オプションをつけて実行します。</p>

<pre><code>$ git instaweb --httpd=webrick --stop
</code></pre>

<p>ウェブインターフェイスをチーム内で常時立ち上げたりオープンソースプロジェクト用に公開したりする場合は、CGI スクリプトを設定して通常のウェブサーバーに配置しなければなりません。Linux のディストリビューションの中には、<code>apt</code> や <code>yum</code> などで <code>gitweb</code> パッケージが用意されているものもあります。まずはそれを探してみるとよいでしょう。手動での GitWeb のインストールについて、さっと流れを説明します。まずは Git のソースコードを取得しましょう。その中に GitWeb が含まれており、CGI スクリプトを作ることができます。</p>

<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/
$ make GITWEB_PROJECTROOT="/opt/git" \
        prefix=/usr gitweb
$ sudo cp -Rf gitweb /var/www/
</code></pre>

<p>コマンドを実行する際に、Git リポジトリの場所 <code>GITWEB_PROJECTROOT</code> 変数で指定しなければならないことに注意しましょう。さて、次は Apache にこのスクリプトを処理させるようにしなければなりません。VirtualHost に次のように追加しましょう。</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName gitserver
    DocumentRoot /var/www/gitweb
    &lt;Directory /var/www/gitweb&gt;
        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
        AllowOverride All
        order allow,deny
        Allow from all
        AddHandler cgi-script cgi
        DirectoryIndex gitweb.cgi
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>GitWeb は、CGI に対応したウェブサーバーならどんなものを使っても動かすことができます。何か別のサーバーのほうがよいというのなら、そのサーバーで動かすのもたやすいことでしょう。これで、<code>http://gitserver/</code> にアクセスすればリポジトリをオンラインで見られるようになりました。また <code>http://git.gitserver</code> で、HTTP 越しのクローンやフェッチもできます。</p>

<h2>Gitosis</h2>

<p>ユーザーの公開鍵を <code>authorized_keys</code> にまとめてアクセス管理する方法は、しばらくの間はうまくいくでしょう。しかし、何百人ものユーザーを管理する段階になると、この方式はとても面倒になります。サーバーのシェルでの操作が毎回発生するわけですし、またアクセス制御が皆無な状態、つまり公開鍵を登録した人はすべてのプロジェクトのすべてのファイルを読み書きできる状態になってしまいます。</p>

<p>ここで、よく使われている Gitosis というソフトウェアについて紹介しましょう。Gitosis は、<code>authorized_keys</code> ファイルを管理したりちょっとしたアクセス制御を行ったりするためのスクリプト群です。ユーザーを追加したりアクセス権を定義したりするための UI に、ウェブではなく独自の Git リポジトリを採用しているというのが興味深い点です。プロジェクトに関する情報を準備してそれをプッシュすると、その情報に基づいて Gitosis がサーバーを設定するというクールな仕組みになっています。</p>

<p>Gitosis のインストールは簡単だとはいえませんが、それほど難しくもありません。Linux サーバー上で運用するのがいちばん簡単でしょう。今回の例では、ごく平凡な Ubuntu 8.10 サーバーを使います。</p>

<p>Gitosis は Python のツールを使います。まずは Python の setuptools パッケージをインストールしなければなりません。Ubuntu なら python-setuptools というパッケージがあります。</p>

<pre><code>$ apt-get install python-setuptools
</code></pre>

<p>次に、プロジェクトのメインサイトから Gitosis をクローンしてインストールします。</p>

<pre><code>$ git clone https://github.com/tv42/gitosis.git
$ cd gitosis
$ sudo python setup.py install
</code></pre>

<p>これで、Gitosis が使う実行ファイル群がインストールされました。Gitosis は、リポジトリが <code>/home/git</code> にあることが前提となっています。しかしここではすでに <code>/opt/git</code> にリポジトリが存在するので、いろいろ設定しなおすのではなくシンボリックリンクを作ってしまいましょう。</p>

<pre><code>$ ln -s /opt/git /home/git/repositories
</code></pre>

<p>Gitosis は鍵の管理も行うので、まず現在の鍵ファイルを削除してあとでもう一度鍵を追加し、Gitosis に <code>authorized_keys</code> を自動管理させなければなりません。ここではまず <code>authorized_keys</code> を別の場所に移動します。</p>

<pre><code>$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak
</code></pre>

<p>次は 'git' ユーザーのシェルをもし <code>git-shell</code> コマンドに変更していたのなら、元に戻さなければなりません。人にログインさせるのではなく、かわりに Gitosis に管理してもらうのです。<code>/etc/passwd</code> ファイルにある</p>

<pre><code>git:x:1000:1000::/home/git:/usr/bin/git-shell
</code></pre>

<p>の行を、次のように戻しましょう。</p>

<pre><code>git:x:1000:1000::/home/git:/bin/sh
</code></pre>

<p>いよいよ Gitosis の初期設定です。自分の公開鍵を使って <code>gitosis-init</code> コマンドを実行します。サーバー上に自分の公開鍵をおいていない場合は、まず公開鍵をコピーしましょう。</p>

<pre><code>$ sudo -H -u git gitosis-init &lt; /tmp/id_dsa.pub
Initialized empty Git repository in /opt/git/gitosis-admin.git/
Reinitialized existing Git repository in /opt/git/gitosis-admin.git/
</code></pre>

<p>これで、指定した鍵を持つユーザーが Gitosis 用の Git リポジトリを変更できるようになりました。次に、新しいリポジトリの <code>post-update</code> スクリプトに実行ビットを設定します。</p>

<pre><code>$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update
</code></pre>

<p>これで準備完了です。きちんと設定できていれば、Gitosis の初期設定時に登録した公開鍵を使って SSH でサーバーにログインできるはずです。結果はこのようになります。</p>

<pre><code>$ ssh git@gitserver
PTY allocation request failed on channel 0
ERROR:gitosis.serve.main:Need SSH_ORIGINAL_COMMAND in environment.
  Connection to gitserver closed.
</code></pre>

<p>これは「何も Git のコマンドを実行していないので、接続を拒否した」というメッセージです。では、実際に何か Git のコマンドを実行してみましょう。Gitosis 管理リポジトリをクローンします。</p>

<pre><code># on your local computer
$ git clone git@gitserver:gitosis-admin.git
</code></pre>

<p><code>gitosis-admin</code> というディレクトリができました。次のような内容になっています。</p>

<pre><code>$ cd gitosis-admin
$ find .
./gitosis.conf
./keydir
./keydir/scott.pub
</code></pre>

<p><code>gitosis.conf</code> が、ユーザーやリポジトリそしてパーミッションを指定するためのファイルです。<code>keydir</code> ディレクトリには、リポジトリへの何らかのアクセス権を持つ全ユーザーの公開鍵ファイルを格納します。ユーザーごとにひとつのファイルとなります。<code>keydir</code> ディレクトリ内のファイル名 (この例では <code>scott.pub</code>) は人によって異なるでしょう。これは、<code>gitosis-init</code> スクリプトでインポートした公開鍵の最後にある説明をもとにして Gitosis がつけた名前です。</p>

<p><code>gitosis.conf</code> ファイルを見ると、今のところは先ほどクローンした <code>gitosis-admin</code> プロジェクトについての情報しか書かれていません。</p>

<pre><code>$ cat gitosis.conf
[gitosis]

[group gitosis-admin]
members = scott
writable = gitosis-admin
</code></pre>

<p>これは、'scott' ユーザー（Gitosis の初期化時に公開鍵を指定したユーザー）だけが <code>gitosis-admin</code> プロジェクトにアクセスできるという意味です。</p>

<p>では、新しいプロジェクトを追加してみましょう。<code>mobile</code> という新しいセクションを作成し、モバイルチームのメンバーとモバイルチームがアクセスするプロジェクトを書き入れます。今のところ存在するユーザーは 'scott' だけなので、とりあえずは彼をメンバーとして追加します。そして、新しいプロジェクト <code>iphone_project</code> を作ることにしましょう。</p>

<pre><code>[group mobile]
members = scott
writable = iphone_project
</code></pre>

<p><code>gitosis-admin</code> プロジェクトに手を入れたら、それをコミットしてサーバーにプッシュしないと変更が反映されません。</p>

<pre><code>$ git commit -am 'add iphone_project and mobile group'
[master 8962da8] add iphone_project and mobile group
 1 file changed, 4 insertions(+)
$ git push origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 272 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@gitserver:gitosis-admin.git
   fb27aec..8962da8  master -&gt; master
</code></pre>

<p>新しい <code>iphone_project</code> プロジェクトにプッシュするには、ローカル側のプロジェクトに、このサーバーをリモートとして追加します。サーバー側でわざわざベアリポジトリを作る必要はありません。先ほどプッシュした地点で、Gitosis が自動的にベアリポジトリの作成を済ませています。</p>

<pre><code>$ git remote add origin git@gitserver:iphone_project.git
$ git push origin master
Initialized empty Git repository in /opt/git/iphone_project.git/
Counting objects: 3, done.
Writing objects: 100% (3/3), 230 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@gitserver:iphone_project.git
 * [new branch]      master -&gt; master
</code></pre>

<p>パスを指定する必要がないことに注目しましょう (実際、パスを指定しても動作しません)。コロンの後にプロジェクト名を指定するだけで、Gitosis がプロジェクトを見つけてくれます。</p>

<p>このプロジェクトに新たなメンバーを迎え入れることになりました、公開鍵を追加しなければなりません。しかし、今までのようにサーバー上の <code>~/.ssh/authorized_keys</code> に追記する必要はありません。ユーザー単位の鍵ファイルを <code>keydir</code> ディレクトリ内に置くだけです。鍵ファイルにつけた名前が、<code>gitosis.conf</code> でその人を指定するときの名前となります。では、John と Josie そして Jessica の公開鍵を追加しましょう。</p>

<pre><code>$ cp /tmp/id_rsa.john.pub keydir/john.pub
$ cp /tmp/id_rsa.josie.pub keydir/josie.pub
$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub
</code></pre>

<p>そして彼らを 'mobile' チームに追加し、<code>iphone_project</code> を読み書きできるようにします。</p>

<pre><code>[group mobile]
members = scott john josie jessica
writable = iphone_project
</code></pre>

<p>この変更をコミットしてプッシュすると、この四人のユーザーがプロジェクトへの読み書きをできるようになります。</p>

<p>Gitosis にはシンプルなアクセス制御機能もあります。John には読み込み専用のアクセス権を設定したいという場合は、このようにします。</p>

<pre><code>[group mobile]
members = scott josie jessica
writable = iphone_project

[group mobile_ro]
members = john
readonly = iphone_project
</code></pre>

<p>John はプロジェクトをクローンして変更内容を受け取れます。しかし、手元での変更をプッシュしようとすると Gitosis に拒否されます。このようにして好きなだけのグループを作成し、それぞれに個別のユーザーとプロジェクトを含めることができます。また、グループのメンバーとして別のグループを指定し (その場合は先頭に <code>@</code> をつけます)、メンバーを自動的に継承することもできます。</p>

<pre><code>[group mobile_committers]
members = scott josie jessica

[group mobile]
members   = @mobile_committers
writable  = iphone_project

[group mobile_2]
members   = @mobile_committers john
writable  = another_iphone_project
</code></pre>

<p>何か問題が発生した場合には、<code>[gitosis]</code> セクションの下に <code>loglevel=DEBUG</code> を書いておくと便利です。設定ミスでプッシュ権限を奪われてしまった場合は、サーバー上の <code>/home/git/.gitosis.conf</code> を直接編集して元に戻します。Gitosis は、このファイルから情報を読み取っています。<code>gitosis.conf</code> ファイルへの変更がプッシュされてきたときに、その内容をこのファイルに書き出します。このファイルを手動で変更しても、次に <code>gitosis-admin</code> プロジェクトへのプッシュが成功した時点でその内容が書き換えられることになります。</p>

<h2>Gitolite</h2>

<p>このセクションでは､Gitoliteの紹介およびインストールと初期設定の方法を解説します｡しかし、完全な状態ではなく、Gitolite に付属する大量のドキュメントに取って代わるものというわけでもありません。また､このセクションは時々更新される可能性があるので､<a href="http://sitaramc.github.com/gitolite/progit.html">最新の情報</a>も確認しておくとよいでしょう｡</p>

<p>GitoliteはGitに認可機能を与えるもので､認証には<code>sshd</code>か<code>httpd</code>を使用します(復習: 認証とはユーザーが誰かを確認することで､認可とはユーザーがアクセスを許可されているかどうかを確認することです)｡</p>

<p>Gitolite は、単なるリポジトリ単位の権限付与だけではなくリポジトリ内のブランチやタグ単位で権限を付与することができます。つまり、特定の人 (あるいはグループ) にだけ特定の "refs" (ブランチあるいはタグ) に対するプッシュ権限を与えて他の人には許可しないといったことができるのです。</p>

<h3>インストール</h3>

<p>Gitolite のインストールは非常に簡単で、豊富な付属ドキュメントを読まなくてもインストールできます。必要なものは、何らかの Unix 系サーバのアカウントです。root アクセス権は不要です。Git や Perl、そして OpenSSH 互換の SSH サーバは既にインストールされているものとします。以下の例では、<code>gitserver</code> というホストにあるアカウント <code>git</code> を使います。</p>

<p>Gitolite は、いわゆる "サーバー" ソフトウェアとしては少し変わっています。アクセスは SSH 経由で行うので、サーバー上のすべての userid が "gitolite host" となり得ます。もっともシンプルなインストール方法をこれから解説していきますので､その他の方法についてはドキュメントを確認してください｡</p>

<p>まずは､ユーザー<code>git</code>をインストール先のサーバー上に作成し､そのユーザーでログインします｡sshの公開鍵(デフォルト設定で<code>ssh-keygen</code>を実行している場合は､<code>~/.ssh/id_rsa.pub</code>がそれに当たります)をあなたのワークステーションからコピーし､ファイル名を<code>&lt;yourname&gt;.pub</code> (以下の例では<code>scott.pub</code>を使用します)に変更しておきます｡次に､以下のコマンドを実行します:</p>

<pre><code>git clone git://github.com/sitaramc/gitolite
gitolite/install -ln
    # $HOME/bin が存在し､かつPATHが通っているものとします
gitolite setup -pk $HOME/scott.pub
</code></pre>

<p><code>gitolite-admin</code>という名前のGitリポジトリが､最後のコマンドにより作成されます｡</p>

<p>最後に､あなたのワークステーションに戻って､<code>git clone git@gitserver:gitolite-admin</code>を実行します｡これで完了です! Gitolite はサーバにインストールされ、<code>gitolite-admin</code> という新しいリポジトリがあなたのワークステーションにできあがりました。Gitolite の設定を管理するには、このリポジトリに変更を加えてプッシュします。</p>

<h3>インストールのカスタマイズ</h3>

<p>デフォルトのインストールは素早く済ませられ、たいていの人にとってはこれで十分でしょう。しかし、必要に応じてインストール方法をカスタマイズすることもできます。rcファイルを変更してカスタマイズすることも可能ですし､もしそれ以上を望むのであれば､gitoliteのカスタマイズについてのドキュメントを確認してください｡</p>

<h3>設定ファイルおよびアクセス制御ルール</h3>

<p>インストールが終わったら、あなたのワークステーションにクローンしたばかりの<code>gitolite-admin</code> リポジトリに移動して､中をのぞいてみましょう。</p>

<pre><code>$ cd ~/gitolite-admin/
$ ls
conf/  keydir/
$ find conf keydir -type f
conf/gitolite.conf
keydir/scott.pub
$ cat conf/gitolite.conf

repo gitolite-admin
    RW+                 = scott

repo testing
    RW+                 = @all
</code></pre>

<p>"scott" (先ほどの <code>gitolite setup</code> コマンドで、指定した公開鍵の名前です) が、<code>gitolite-admin</code> リポジトリおよび同名の公開鍵ファイルへの読み書き権限を持っていることに注目しましょう。</p>

<p>ユーザーを追加するのは簡単です｡"alice"というユーザーを追加するなら､彼女の公開鍵を取得し､<code>alice.pub</code>に名前を変更､そしてそれをあなたのワークステーションにクローンされたgitolite-adminレポジトリ内の<code>keydir</code>ディレクトリにコピーします｡変更を追加し､コミットし､プッシュすれば､ユーザーの追加は完了です｡</p>

<p>Gitolite の設定ファイルの構文はドキュメントに詳しく書かれているので、ここでは大事なところに絞って説明します。</p>

<p>ユーザやリポジトリをグループにまとめることもできます。グループ名は単なるマクロのようなものです。グループを定義する際には、それがユーザであるかプロジェクトであるかは無関係です。実際にその「マクロ」を <em>使う</em> 段階になって初めてそれらを区別することになります。</p>

<pre><code>@oss_repos      = linux perl rakudo git gitolite
@secret_repos   = fenestra pear

@admins         = scott
@interns        = ashok
@engineers      = sitaram dilbert wally alice
@staff          = @admins @engineers @interns
</code></pre>

<p>パーミッションは、"ref" レベルで設定することができます。次の例では、インターン (@interns) は "int" ブランチにしかプッシュできないように設定しています。エンジニア (@engineers) は名前が "eng-" で始まるすべてのブランチにプッシュでき、また "rc" のあとに一桁の数字が続く名前のタグにもプッシュできます。また、管理者 (@admins) はすべての ref に対してあらゆることができます。</p>

<pre><code>repo @oss_repos
    RW  int$                = @interns
    RW  eng-                = @engineers
    RW  refs/tags/rc[0-9]   = @engineers
    RW+                     = @admins
</code></pre>

<p><code>RW</code> や <code>RW+</code> の後に書かれている式は正規表現 (regex) で、これにマッチする refname (ref) が対象となります。なので、これに "refex" と名付けました! もちろん、refex はこの例で示したよりずっと強力なものです。Perl の正規表現になじめない人は、あまりやりすぎないようにしましょう。</p>

<p>また、すでにお気づきかもしれませんが、<code>refs/</code> で始まらない refex を指定すると、Gitolite はその先頭に <code>refs/heads/</code> がついているものとみなします。これは構文上の利便性を意識したものです。</p>

<p>設定ファイルの構文の中でも重要なのは、ひとつのリポジトリに対するルールをすべてひとまとめにしなくてもよいということです。共通の設定をひとまとめにして上の例のように <code>oss_repos</code> に対してルールを設定し、その後で個々の場合について個別のルールを追加していくこともできます。</p>

<pre><code>repo gitolite
    RW+                     = sitaram
</code></pre>

<p>このルールは、<code>gitolite</code> リポジトリのルール群に追加されます。</p>

<p>で、実際のアクセス制御ルールはどのように書けばいいの? と思われたことでしょう。簡単に説明します。</p>

<p>Gitolite のアクセス制御には二段階のレベルがあります。まず最初はリポジトリレベルのアクセス制御です。あるリポジトリへの読み込み (書き込み) アクセス権を持っているということは、そのリポジトリの <em>すべての</em> ref に対する読み込み (書き込み) 権限を持っていることを意味します。Gitosisにはこのレベルのアクセス制御しかありませんでした｡</p>

<p>もうひとつのレベルは "書き込み" アクセス権だけを制御するものですが、リポジトリ内のブランチやタグ単位で設定できます。ユーザ名、試みられるアクセス (<code>W</code> あるいは <code>+</code>)、そして更新される refname が既知となります。アクセスルールのチェックは、設定ファイルに書かれている順に行われ、この組み合わせにマッチ (単なる文字列マッチではなく正規表現によるマッチであることに注意しましょう) するものを探していきます。マッチするものが見つかったら、プッシュが成功します。マッチしなかった場合は、アクセスが拒否されます。</p>

<h3>"拒否" ルールによる高度なアクセス制御</h3>

<p>これまでに見てきた権限は <code>R</code>、<code>RW</code> あるいは <code>RW+</code> だけでした。しかし、Gitolite にはそれ以外の権限もあります。それが <code>-</code> で、"禁止" をあらわすものです。これを使えばより強力なアクセス制御ができるようになりますが、少し設定は複雑になります。マッチしなければアクセスを拒否するというだけでなく、ルールを書く順番もからんでくることになるからです。</p>

<p>上の例で、エンジニアは master と integ <em>以外</em> のすべてのブランチを巻き戻せるように設定しようとすると、次のようになります。</p>

<pre><code>    RW  master integ    = @engineers
    -   master integ    = @engineers
    RW+                 = @engineers
</code></pre>

<p>この場合も上から順にルールを適用し、最初にマッチしたアクセス権をあてはめます。何もマッチしなければアクセスは拒否されます。master や integ に対する巻き戻し以外のプッシュは、最初のルールにマッチするので許可されます。これらのブランチに対する巻き戻しのプッシュは最初のルールにマッチしません。そこで二番目のルールに移動し、この時点で拒否されます。master と integ 以外への (巻き戻しを含む) 任意のプッシュは最初の二つのルールのいずれにもマッチしないので、三番目のルールが適用されます。</p>

<h3>ファイル単位でのプッシュの制限</h3>

<p>変更をプッシュすることのできるブランチを制限するだけでなく、変更できるファイルを制限することも可能です。たとえば、Makefile (あるいはその他のプログラム) などは誰もが変更できるというものではないでしょう。このファイルはさまざまなものに依存しており、変更によっては壊れてしまうことがあるかもしれないからです。そんな場合は次のように設定します。</p>

<pre><code>repo foo
    RW                      =   @junior_devs @senior_devs

    -   VREF/NAME/Makefile  =   @junior_devs
</code></pre>

<p>この機能には大幅な変更が加えられているので､Gitoliteの旧バージョンから移行してきたユーザーは気をつけてください｡移行の手引きを確認してください｡</p>

<h3>個人ブランチ</h3>

<p>Gitolite には "個人ブランチ" ("個人的なブランチ用の名前空間" と言ったほうがいいでしょうか) という機能があります。これは、法人の環境では非常に便利なものです。</p>

<p>Git の世界では、いわゆる「プルリクエスト」によるコードのやりとりが頻繁に発生します。しかし法人の環境では、権限のない人によるアクセスは厳禁です。開発者のワークステーションにはそんな権限はありません。そこで、まず一度中央サーバにプッシュして、そこからプルしてもらうよう誰かにお願いすることになります。</p>

<p>これを中央管理型の VCS でやろうとすると、同じ名前のブランチが乱造されることになってしまいます。また、これらのアクセス権限を設定するのは管理者にとって面倒な作業です。</p>

<p>Gitolite では、開発者ごとに "personal" あるいは "scratch" といった名前空間プレフィックス (たとえば <code>refs/personal/&lt;devname&gt;/*</code>) を定義できます。詳細は､ドキュメントを確認してください｡</p>

<h3>"ワイルドカード" リポジトリ</h3>

<p>Gitolite では、ワイルドカード (実際のところは Perl の正規表現です) を使ってリポジトリを指定することができます。たとえば <code>assignments/s[0-9][0-9]/a[0-9][0-9]</code> のようにします。この機能を使うと、新たな権限モード (<code>C</code>) が用意されます。これは、ワイルドカードにマッチするリポジトリの作成を許可するモードです。新たに作成したリポジトリの所有者は自動的にそのユーザに設定され、他のユーザに <code>R</code> あるいは <code>RW</code> の権限を付与できるようになります。この機能についても､詳細はドキュメントを確認してください｡</p>

<h3>その他の機能</h3>

<p>最後にその他の機能の例を紹介しましょう。これらについての詳しい説明は、ドキュメントにあります。</p>

<p><strong>ログ記録</strong>: Gitolite は、成功したアクセスをすべてログに記録します。巻き戻し権限 (<code>RW+</code>) を与えているときに、誰かが <code>master</code> を吹っ飛ばしてしまったとしましょう。そんなときにはログファイルが救世主となります。ログを見れば、問題を起こした SHA をすぐに発見できるでしょう。</p>

<p><strong>アクセス権の報告</strong>: もうひとつの便利な機能は、サーバに ssh で接続したときに起こります。gitolite はあなたがアクセスするリポジトリとどのようなアクセスができるかを表示します。たとえばこんな感じです。</p>

<pre><code>    hello scott, this is git@git running gitolite3 v3.01-18-g9609868 on git 1.7.4.4

         R     anu-wsd
         R     entrans
         R  W  git-notes
         R  W  gitolite
         R  W  gitolite-admin
         R     indic_web_input
         R     shreelipi_converter
</code></pre>

<p><strong>委譲</strong>: 大規模な環境では、特定のリポジトリのグループに対する責任を委譲して個別に管理させることもできます。こうすれば主管理者の負荷が軽減され、主管理者がボトルネックとなることも少なくなります。</p>

<p><strong>ミラーリング</strong>: Gitolite は、複数のミラーを保守したり、プライマリサーバーが落ちたときに簡単にミラーに切り替えたりすることができます。</p>

<h2>Git デーモン</h2>

<p>認証の不要な読み取り専用アクセスを一般に公開する場合は、HTTP を捨てて Git プロトコルを使うことを考えることになるでしょう。主な理由は速度です。Git プロトコルのほうが HTTP に比べてずっと効率的で高速です。Git プロトコルを使えば、ユーザーの時間を節約することになります。</p>

<p>Git プロトコルは、認証なしで読み取り専用アクセスを行うためのものです。ファイアウォールの外にサーバーがあるのなら、一般に公開しているプロジェクトにのみ使うようにしましょう。ファイアウォール内で使うのなら、たとえば大量のメンバーやコンピューター (継続的インテグレーションのビルドサーバーなど) に対して SSH の鍵なしで読み取り専用アクセスを許可するという使い方もあるでしょう。</p>

<p>いずれにせよ、Git プロトコルは比較的容易にセットアップすることができます。デーモン化するためには、このようなコマンドを実行します。</p>

<pre><code>git daemon --reuseaddr --base-path=/opt/git/ /opt/git/
</code></pre>

<p><code>--reuseaddr</code> は、前の接続がタイムアウトするのを待たずにサーバーを再起動させるオプションです。<code>--base-path</code> オプションを指定すると、フルパスをしていしなくてもプロジェクトをクローンできるようになります。そして最後に指定したパスは、Git デーモンに公開させるリポジトリの場所です。ファイアウォールを使っているのなら、ポート 9418 に穴を開けなければなりません。</p>

<p>プロセスをデーモンにする方法は、OS によってさまざまです。Ubuntu の場合は Upstart スクリプトを使います。</p>

<pre><code>/etc/event.d/local-git-daemon
</code></pre>

<p>のようなファイルを用意して、このようなスクリプトを書きます。</p>

<pre><code>start on startup
stop on shutdown
exec /usr/bin/git daemon \
    --user=git --group=git \
    --reuseaddr \
    --base-path=/opt/git/ \
    /opt/git/
respawn
</code></pre>

<p>セキュリティを考慮して、リポジトリに対する読み込み権限しかないユーザーでこのデーモンを実行させるようにしましょう。新しいユーザー 'git-ro' を作り、このユーザーでデーモンを実行させるとよいでしょう。ここでは、説明を簡単にするために Gitosis と同じユーザー 'git' で実行させることにします。</p>

<p>マシンを再起動すれば Git デーモンが自動的に立ち上がり、終了させても再び起動するようになります。再起動せずに実行させるには、次のコマンドを実行します。</p>

<pre><code>initctl start local-git-daemon
</code></pre>

<p>その他のシステムでは、<code>xinetd</code> や <code>sysvinit</code> システムのスクリプトなど、コマンドをデーモン化して監視できる仕組みを使います。</p>

<p>次に、どのプロジェクトに対して Git プロトコルでの認証なしアクセスを許可するのかを Gitosis に指定します。各リポジトリ用のセクションを追加すれば、Git デーモンからの読み込みアクセスを許可するように指定することができます。Git プロトコルでのアクセスを <code>iphone_project</code>に許可したい場合は、<code>gitosis.conf</code> の最後に次のように追加します。</p>

<pre><code>[repo iphone_project]
daemon = yes
</code></pre>

<p>この変更をコミットしてプッシュすると、デーモンがこのプロジェクトへのアクセスを受け付けるようになります。</p>

<p>Gitosis を使わずに Git デーモンを設定したい場合は、Git デーモンで公開したいプロジェクトに対してこのコマンドを実行しなければなりません。</p>

<pre><code>$ cd /path/to/project.git
$ touch git-daemon-export-ok
</code></pre>

<p>このファイルが存在するプロジェクトについては、Git は認証なしで公開してもよいものとみなします。</p>

<p>Gitosis を使うと、どのプロジェクトを GitWeb で見せるのかを指定することもできます。まずは次のような行を <code>/etc/gitweb.conf</code> に追加しましょう。</p>

<pre><code>$projects_list = "/home/git/gitosis/projects.list";
$projectroot = "/home/git/repositories";
$export_ok = "git-daemon-export-ok";
@git_base_url_list = ('git://gitserver');
</code></pre>

<p>GitWeb でどのプロジェクトを見せるのかを設定するには、Gitosis の設定ファイルで <code>gitweb</code> を指定します。たとえば、<code>iphone_project</code>を GitWeb で見せたい場合は、<code>repo</code> の設定は次のようになります。</p>

<pre><code>[repo iphone_project]
daemon = yes
gitweb = yes
</code></pre>

<p>これをコミットしてプッシュすると、GitWeb で <code>iphone_project</code>が自動的に表示されるようになります。</p>

<h2>Git のホスティング</h2>

<p>Git サーバーを立ち上げる作業が面倒なら、外部の専用ホスティングサイトに Git プロジェクトを置くという選択肢があります。この方法には多くの利点があります。ホスティングサイトでプロジェクトを立ち上げるのは簡単ですし、サーバーのメンテナンスや日々の監視も不要です。自前のサーバーを持っているとしても、オープンソースのコードなどはホスティングサイトで公開したいこともあるかもしれません。そのほうがオープンソースコミュニティのメンバーに見つけてもらいやすく、そして支援を受けやすくなります。</p>

<p>今ではホスティングの選択肢が数多くあり、それぞれ利点もあれば欠点もあります。最新の情報を知るには、次のページを調べましょう。</p>

<pre><code>https://git.wiki.kernel.org/index.php/GitHosting
</code></pre>

<p>これらすべてについて網羅することは不可能ですし、たまたま私自身がこの中のひとつで働いていることもあるので、ここでは GitHub を使ってアカウントの作成からプロジェクトの立ち上げまでの手順を説明します。どのような流れになるのかを見ていきましょう。</p>

<p>GitHub は最大のオープンソース Git ホスティングサイトで、公開リポジトリだけでなく非公開のリポジトリもホスティングできる数少ないサイトのひとつです。つまり、オープンソースのコードと非公開のコードを同じ場所で管理できるのです。実際、本書に関する非公開の共同作業についても GitHub を使っています。</p>

<h3>GitHub</h3>

<p>GitHub がその他多くのコードホスティングサイトと異なるのは、プロジェクトの位置づけです。プロジェクトを主体に考えるのではなく、GitHub ではユーザー主体の構成になっています。私が GitHub に <code>grit</code> プロジェクトを公開したとして、それは <code>github.com/grit</code> ではなく <code>github.com/schacon/grit</code> となります。どのプロジェクトにも「正式な」バージョンというものはありません。たとえ最初の作者がプロジェクトを放棄したとしても、それをユーザーからユーザーへと自由に移動することができます。</p>

<p>GitHub は営利企業なので、非公開のリポジトリについては料金をとって管理しています。しかし、フリーのアカウントを取得すればオープンソースのプロジェクトを好きなだけ公開することができます。その方法についてこれから説明します。</p>

<h3>ユーザーアカウントの作成</h3>

<p>まずはフリー版のユーザーアカウントを作成しましょう。Pricing and Signup のページ <code>http://github.com/plans</code> で、フリーアカウントの "Sign Up" ボタンを押すと (図 4-2 を参照ください)、新規登録ページに移動します。</p>

<p><img src="figures/4.2.png" title="4.2 GitHub のプラン説明ページ" alt="4.2 GitHub のプラン説明ページ" /></p>

<p>ユーザー名を選び、メールアドレスを入力します。アカウントとパスワードがこのメールアドレスに関連づけられます (図 4-3 を参照ください)。</p>

<p><img src="figures/4.3.png" title="4.3 GitHub のユーザー登録フォーム" alt="4.3 GitHub のユーザー登録フォーム" /></p>

<p>それが終われば、次に SSH の公開鍵を追加しましょう。新しい鍵を作成する方法については、さきほど「ちょっとしたセットアップ」のところで説明しました。公開鍵の内容をコピーし、SSH Public Key のテキストボックスに貼り付けます。"explain ssh keys" のリンクをクリックすると、主要 OS 上での公開鍵の作成手順を詳しく説明してくれます。"I agree, sign me up" ボタンをクリックすると、あなたのダッシュボードに移動します (図 4-4 を参照ください)。</p>

<p><img src="figures/4.4.png" title="4.4 GitHub のユーザーダッシュボード" alt="4.4 GitHub のユーザーダッシュボード" /></p>

<p>では次に、新しいリポジトリの作成に進みましょう。</p>

<h3>新しいリポジトリの作成</h3>

<p>ダッシュボードで、Your Repositories の横にあるリンク "create a new one" をクリックしましょう。新規リポジトリの作成フォームに進みます (図 4-5 を参照ください)。</p>

<p><img src="figures/4.5.png" title="4.5 GitHub での新しいリポジトリの作成" alt="4.5 GitHub での新しいリポジトリの作成" /></p>

<p>ここで必要なのはプロジェクト名を決めることだけです。ただ、それ以外に説明文を追加することもできます。ここで "Create Repository" ボタンを押せば、GitHub 上での新しいリポジトリのできあがりです (図 4-6 を参照ください)。</p>

<p><img src="figures/4.6.png" title="4.6 GitHub でのプロジェクトのヘッダ情報" alt="4.6 GitHub でのプロジェクトのヘッダ情報" /></p>

<p>まだ何もコードが追加されていないので、ここでは「新しいプロジェクトを作る方法」「既存の Git プロジェクトをプッシュする方法」「Subversion の公開リポジトリからインポートする方法」が説明されています (図 4-7 を参照ください)。</p>

<p><img src="figures/4.7.png" title="4.7 新しいリポジトリに関する説明" alt="4.7 新しいリポジトリに関する説明" /></p>

<p>この説明は、本書でこれまでに説明してきたものとほぼ同じです。まだ Git プロジェクトでないプロジェクトを初期化するには、次のようにします。</p>

<pre><code>$ git init
$ git add .
$ git commit -m 'initial commit'
</code></pre>

<p>ローカルにある Git リポジトリを使用する場合は、GitHub をリモートに登録して master ブランチをプッシュします。</p>

<pre><code>$ git remote add origin git@github.com:testinguser/iphone_project.git
$ git push origin master
</code></pre>

<p>これで GitHub 上でリポジトリが公開され、だれもがプロジェクトにアクセスできるような URL ができあがりました。この例の場合は <code>http://github.com/testinguser/iphone_project</code> です。各プロジェクトのページのヘッダには、ふたつの Git URL が表示されています (図 4-8 を参照ください)。</p>

<p><img src="figures/4.8.png" title="4.8 公開 URL とプライベート URL が表示されたヘッダ" alt="4.8 公開 URL とプライベート URL が表示されたヘッダ" /></p>

<p>Public Clone URL は、読み込み専用の公開 URL で、これを使えば誰でもプロジェクトをクローンできます。この URL は、あなたのウェブサイトをはじめとしたお好みの場所で紹介することができます。</p>

<p>Your Clone URL は、読み書き可能な SSH の URL で、先ほどアップロードした公開鍵に対応する SSH 秘密鍵を使った場合にのみアクセスできます。他のユーザーがこのプロジェクトのページを見てもこの URL は表示されず、公開 URL のみが見えるようになっています。</p>

<h3>Subversion からのインポート</h3>

<p>GitHub では、Subversion で公開しているプロジェクトを Git にインポートすることもできます。先ほどの説明ページの最後のリンクをクリックすると、Subversion からのインポート用ページに進みます。このページにはインポート処理についての情報が表示されており、公開 Subversion リポジトリの URL を入力するテキストボックスが用意されています。</p>

<p><img src="figures/4.9.png" title="4.9 Subversion からのインポート" alt="4.9 Subversion からのインポート" /></p>

<p>もしそのプロジェクトが非常に大規模なものであったり標準とは異なるものであったり、あるいは公開されていないものであったりした場合は、この手順ではうまくいかないでしょう。第 7 章で、手動でのプロジェクトのインポート手順について詳しく説明します。</p>

<h3>共同作業者の追加</h3>

<p>では、チームの他のメンバーを追加しましょう。John、Josie そして Jessica は全員すでに GitHub のアカウントを持っており、彼らもこのリポジトリにプッシュできるようにしたければ、プロジェクトの共同作業者として登録します。そうすれば、彼らの公開鍵をつかったプッシュも可能となります。</p>

<p>プロジェクトのヘッダにある "edit" ボタンをクリックするかプロジェクトの上の Admin タブを選択すると、GitHub プロジェクトの管理者用ページに移動します (図 4-10 を参照ください)。</p>

<p><img src="figures/4.10.png" title="4.10 GitHub の管理者用ページ" alt="4.10 GitHub の管理者用ページ" /></p>

<p>別のユーザーにプロジェクトへの書き込み権限を付与するには、“Add another collaborator”リンクをクリックします。新しいテキストボックスがあらわれるので、そこにユーザー名を記入します。何か入力すると、マッチするユーザー名の候補がポップアップ表示されます。ユーザーが見つかれば、Add ボタンをクリックすればそのユーザーを共同作業者に追加できます (図 4-11 を参照ください)。</p>

<p><img src="figures/4.11.png" title="4.11 プロジェクトへの共同作業者の追加" alt="4.11 プロジェクトへの共同作業者の追加" /></p>

<p>対象者を全員追加し終えたら、Repository Collaborators のところにその一覧が見えるはずです (図 4-12 を参照ください)。</p>

<p><img src="figures/4.12.png" title="4.12 プロジェクトの共同作業者一覧" alt="4.12 プロジェクトの共同作業者一覧" /></p>

<p>誰かのアクセス権を剥奪したい場合は、"revoke" リンクをクリックすればそのユーザーはプッシュできなくなります。また、今後新たにプロジェクトを作ったときに、この共同作業者一覧をコピーして使うこともできます。</p>

<h3>あなたのプロジェクト</h3>

<p>プロジェクトをプッシュするか、あるいは Subversion からのインポートを済ませると、プロジェクトのメインページは図 4-13 のようになります。</p>

<p><img src="figures/4.13.png" title="4.13 GitHub プロジェクトのメインページ" alt="4.13 GitHub プロジェクトのメインページ" /></p>

<p>他の人がこのプロジェクトにアクセスしたときに見えるのがこのページとなります。このページには、さまざまな情報を見るためのタブが用意されています。Commits タブに表示されるのはコミットの一覧で、<code>git log</code> コマンドの出力と同様にコミット時刻が新しい順に表示されます。Network タブには、このプロジェクトをフォークして何か貢献してくれた人の一覧が表示されます。Downloads タブには、プロジェクト内でタグが打たれている任意の点について tar や zip でまとめたものをアップロードすることができます。Wiki タブには、プロジェクトに関するドキュメントやその他の情報を書き込むための wiki が用意されています。Graphs タブは、プロジェクトに対する貢献やその他の統計情報を視覚化して表示します。そして、Source タブにはプロジェクトのメインディレクトリの一覧が表示され、もし README ファイルがあればその内容が下に表示されます。このタブでは、最新のコミットについての情報も表示されます。</p>

<h3>プロジェクトのフォーク</h3>

<p>プッシュアクセス権のない別のプロジェクトに協力したくなったときは、GitHub ではプロジェクトをフォークすることを推奨しています。興味を持ったとあるプロジェクトのページに行って、それをちょっとばかりハックしたくなったときは、プロジェクトのヘッダにある "fork" ボタンをクリックしましょう。GitHub が自分のところにそのプロジェクトをコピーしてくれるので、そこへのプッシュができるようになります。</p>

<p>この方式なら、プッシュアクセス権を与えるために共同作業者としてユーザーを追加することを気にせずにすみます。プロジェクトをフォークした各ユーザーが自分のところにプッシュし、主メンテナーは必要に応じてかれらの作業をマージすればいいのです。</p>

<p>プロジェクトをフォークするには、そのプロジェクトのページ (この場合は mojombo/chronic) に移動してヘッダの "fork" ボタンをクリックします (図 4-14 を参照ください)。</p>

<p><img src="figures/4.14.png" title="4.14 任意のプロジェクトの書き込み可能なコピーを取得する &quot;fork&quot; ボタン" alt="4.14 任意のプロジェクトの書き込み可能なコピーを取得する &quot;fork&quot; ボタン" /></p>

<p>数秒後に新しいプロジェクトのページに移動します。そこには、このプロジェクトがどのプロジェクトのフォークであるかが表示されています (図 4-15 を参照ください)。</p>

<p><img src="figures/4.15.png" title="4.15 フォークしたプロジェクト" alt="4.15 フォークしたプロジェクト" /></p>

<h3>GitHub のまとめ</h3>

<p>これで GitHub についての説明を終えますが、特筆すべき点はこれらの作業を本当に手早く済ませられることです。アカウントを作ってプロジェクトを追加してそこにプッシュする、ここまでがほんの数分でできてしまいます。オープンソースのプロジェクトを公開したのなら、数多くの開発者のコミュニティがあなたのプロジェクトにアクセスできるようになりました。きっと中にはあなたに協力してくれる人もあらわれることでしょう。少なくとも、Git を動かして試してみる土台としては使えるはずです。</p>

<h2>まとめ</h2>

<p>リモート Git リポジトリを用意するためのいくつかの方法を紹介し、他のメンバーとの共同作業ができるようになりました。</p>

<p>自前でサーバーを構築すれば、多くのことを制御できるようになり、ファイアウォールの内側でもサーバーを実行することができます。しかし、サーバーを構築して運用するにはそれなりの手間がかかります。ホスティングサービスを使えば、サーバーの準備や保守は簡単になります。しかし、他人のサーバー上に自分のコードを置き続けなければなりません。組織によってはそんなことを許可していないかもしれません。</p>

<p>どの方法 (あるいは複数の方法の組み合わせ) を使えばいいのか、自分や所属先の事情に合わせて考えましょう。</p>
<h1>Git での分散作業</h1>

<p>リモート Git リポジトリを用意し、すべての開発者がコードを共有できるようになりました。また、ローカル環境で作業をする際に使う基本的な Git コマンドについても身についたことでしょう。次に、Git を使った分散作業の流れを見ていきましょう。</p>

<p>本章では、Git を使った分散環境での作業の流れを説明します。自分のコードをプロジェクトに提供する方法、そしてプロジェクトのメンテナーと自分の両方が作業を進めやすくする方法、そして多数の開発者からの貢献を受け入れるプロジェクトを運営する方法などを扱います。</p>

<h2>分散作業の流れ</h2>

<p>中央管理型のバージョン管理システム (Centralized Version Control System: CVCS) とは違い、Git は分散型だという特徴があります。この特徴を生かすと、プロジェクトの開発者間での共同作業をより柔軟に行えるようになります。中央管理型のシステムでは、個々の開発者は中央のハブに対するノードという位置づけとなります。しかし Git では、各開発者はノードであると同時にハブにもなり得ます。つまり、誰もが他のリポジトリに対してコードを提供することができ、誰もが公開リポジトリを管理して他の開発者の作業を受け入れることもできるということです。これは、みなさんのプロジェクトや開発チームでの作業の流れにさまざまな可能性をもたらします。本章では、この柔軟性を生かすいくつかの実例を示します。それぞれについて、利点だけでなく想定される弱点についても扱うので、適宜取捨選択してご利用ください。</p>

<h3>中央集権型のワークフロー</h3>

<p>中央管理型のシステムでは共同作業の方式は一つだけです。それが中央集権型のワークフローです。これは、中央にある一つのハブ (リポジトリ) がコードを受け入れ、他のメンバー全員がそこに作業内容を同期させるという流れです。多数の開発者がハブにつながるノードとなり、作業を一か所に集約します (図 5-1 を参照ください)。</p>

<p><img src="figures/5.1.png" title="5.1 中央集権型のワークフロー" alt="5.1 中央集権型のワークフロー" /></p>

<p>二人の開発者がハブからのクローンを作成して個々に変更をした場合、最初の開発者がそれをプッシュするのは特に問題なくできます。もう一人の開発者は、まず最初の開発者の変更をマージしてからサーバーへのプッシュを行い、最初の開発者の変更を消してしまわないようにします。この考え方は、Git 上でも Subversion (あるいはその他の CVCS) と同様に生かせます。そしてこの方式は Git でも完全に機能します。</p>

<p>小規模なチームに所属していたり、組織内で既に中央集権型のワークフローになじんでいたりなどの場合は、Git でその方式を続けることも簡単です。リポジトリをひとつ立ち上げて、チームのメンバー全員がそこにプッシュできるようにすればいいのです。Git は他のユーザーの変更を上書きしてしまうことはありません。誰かがクローンして手元で変更を加えた内容をプッシュしようとしたときに、もし既に他の誰かの変更がプッシュされていれば、サーバー側でそのプッシュは拒否されます。そして、直接プッシュすることはできないのでまずは変更内容をマージしなさいと教えてくれます。この方式は多くの人にとって魅力的なものでしょう。これまでにもなじみのある方式だし、今までそれでうまくやってきたからです。</p>

<h3>統合マネージャー型のワークフロー</h3>

<p>Git では複数のリモートリポジトリを持つことができるので、書き込み権限を持つ公開リポジトリを各自が持ち、他のメンバーからは読み込みのみのアクセスを許可するという方式をとることもできます。この方式には、「公式」プロジェクトを表す公式なリポジトリも含みます。このプロジェクトの開発に参加するには、まずプロジェクトのクローンを自分用に作成し、変更はそこにプッシュします。次に、メインプロジェクトのメンテナーに「変更を取り込んでほしい」とお願いします。メンテナーはあなたのリポジトリをリモートに追加し、変更を取り込んでマージします。そしてその結果をリポジトリにプッシュするのです。この作業の流れは次のようになります (図 5-2 を参照ください)。</p>

<ol>
<li>プロジェクトのメンテナーが公開リポジトリにプッシュする</li>
<li>開発者がそのリポジトリをクローンし、変更を加える</li>
<li>開発者が各自の公開リポジトリにプッシュする</li>
<li>開発者がメンテナーに「変更を取り込んでほしい」というメールを送る</li>
<li>メンテナーが開発者のリポジトリをリモートに追加し、それをマージする</li>
<li>マージした結果をメンテナーがメインリポジトリにプッシュする</li>
</ol>


<p><img src="figures/5.2.png" title="5.2 統合マネージャー型のワークフロー" alt="5.2 統合マネージャー型のワークフロー" /></p>

<p>これは GitHub のようなサイトでよく使われている流れです。プロジェクトを容易にフォークでき、そこにプッシュした内容をみんなに簡単に見てもらえます。この方式の主な利点の一つは、あなたはそのまま開発を続行し、メインリポジトリのメンテナーはいつでも好きなタイミングで変更を取り込めるということです。変更を取り込んでもらえるまで作業を止めて待つ必要はありません。自分のペースで作業を進められるのです。</p>

<h3>独裁者と若頭型のワークフロー</h3>

<p>これは、複数リポジトリ型のワークフローのひとつです。何百人もの開発者が参加するような巨大なプロジェクトで採用されています。有名どころでは Linux カーネルがこの方式です。統合マネージャーを何人も用意し、それぞれにリポジトリの特定の部分を担当させます。彼らは若頭 (lieutenant) と呼ばれます。そしてすべての若頭をまとめる統合マネージャーが「慈悲深い独裁者 (benevalent dictator)」です。独裁者のリポジトリが基準リポジトリとなり、すべてのメンバーはこれをプルします。この作業の流れは次のようになります (図 5-3 を参照ください)。</p>

<ol>
<li>一般の開発者はトピックブランチ上で作業を進め、master の先頭にリベースする。独裁者の master ブランチがマスターとなる</li>
<li>若頭が各開発者のトピックブランチを自分の master ブランチにマージする</li>
<li>独裁者が各若頭の master ブランチを自分の master ブランチにマージする</li>
<li>独裁者が自分の master をリポジトリにプッシュし、他のメンバーがリベースできるようにする</li>
</ol>


<p><img src="figures/5.3.png" title="5.3 慈悲深い独裁者型のワークフロー" alt="5.3 慈悲深い独裁者型のワークフロー" /></p>

<p>この手のワークフローはあまり一般的ではありませんが、大規模なプロジェクトや高度に階層化された環境では便利です。プロジェクトリーダー (独裁者) が大半の作業を委譲し、サブセット単位である程度まとまってからコードを統合することができるからです。</p>

<p>Git のような分散システムでよく使われるワークフローの多くは、実社会での何らかのワークフローにあてはめて考えることができます。これで、どのワークフローがあなたに合うかがわかったことでしょう (ですよね?)。次は、より特化した例をあげて個々のフローを実現する方法を見ていきましょう。</p>

<h2>プロジェクトへの貢献</h2>

<p>さまざまなワークフローの概要について説明しました。また、すでにみなさんは Git の基本的な使い方を身につけています。このセクションでは、何らかのプロジェクトに貢献する際のよくあるパターンについて学びましょう。</p>

<p>これは非常に説明しづらい内容です。というのも、ほんとうにいろいろなパターンがあるからです。Git は柔軟なシステムなので、いろいろな方法で共同作業をすることができます。そのせいもあり、どのプロジェクトをとってみても微妙に他とは異なる方式を使っているのです。違いが出てくる原因としては、アクティブな貢献者の数やプロジェクトで使用しているワークフロー、あなたのコミット権、そして外部からの貢献を受け入れる際の方式などがあります。</p>

<p>最初の要素はアクティブな貢献者の数です。そのプロジェクトに対してアクティブにコードを提供している開発者はどれくらいいるのか、そして彼らはどれくらいの頻度で提供しているのか。よくあるのは、数名の開発者が一日数回のコミットを行うというものです。休眠状態のプロジェクトなら、もう少し頻度が低くなるでしょう。大企業や大規模なプロジェクトでは、開発者の数が数千人になることもあります。数十から下手したら百を超えるようなパッチが毎日やってきます。開発者の数が増えれば増えるほど、あなたのコードをきちんと適用したり他のコードをマージしたりするのが難しくなります。あなたが手元で作業をしている間に他の変更が入って、手元で変更した内容が無意味になってしまったりあるいは他の変更を壊してしまう羽目になったり。そのせいで、手元の変更を適用してもらうための待ち時間が発生したり。手元のコードを常に最新の状態にし、正しいパッチを作るにはどうしたらいいのでしょうか。</p>

<p>次に考えるのは、プロジェクトが採用しているワークフローです。中央管理型で、すべての開発者がコードに対して同等の書き込みアクセス権を持っている状態? 特定のメンテナーや統合マネージャーがすべてのパッチをチェックしている? パッチを適用する前にピアレビューをしている? あなたはパッチをチェックしたりピアレビューに参加したりしている人? 若頭型のワークフローを使っており、まず彼らにコードを渡さなければならない?</p>

<p>次の問題は、あなたのコミット権です。あなたがプロジェクトへの書き込みアクセス権限を持っている場合は、プロジェクトに貢献するための作業の流れが変わってきます。書き込み権限がない場合、そのプロジェクトではどのような形式での貢献を推奨していますか? 何かポリシーのようなものはありますか? 一度にどれくらいの作業を貢献することになりますか? また、どれくらいの頻度で貢献することになりますか?</p>

<p>これらの点を考慮して、あなたがどんな流れでどのようにプロジェクトに貢献していくのかが決まります。単純なものから複雑なものまで、実際の例を見ながら考えていきましょう。これらの例を参考に、あなたなりのワークフローを見つけてください。</p>

<h3>コミットの指針</h3>

<p>個々の例を見る前に、コミットメッセージについてのちょっとした注意点をお話しておきましょう。コミットに関する指針をきちんと定めてそれを守るようにすると、Git での共同作業がよりうまく進むようになります。Git プロジェクトでは、パッチの投稿用のコミットを作成するときのヒントをまとめたドキュメントを用意しています。Git のソースの中にある <code>Documentation/SubmittingPatches</code> をごらんください。</p>

<p>まず、余計な空白文字を含めてしまわないように注意が必要です。Git には、余計な空白文字をチェックするための簡単な仕組みがあります。コミットする前に <code>git diff --check</code> を実行してみましょう。おそらく意図したものではないと思われる空白文字を探し、それを教えてくれます。例を示しましょう。端末上では赤で表示される箇所を <code>X</code> で置き換えています。</p>

<pre><code>$ git diff --check
lib/simplegit.rb:5: trailing whitespace.
+    @git_dir = File.expand_path(git_dir)XX
lib/simplegit.rb:7: trailing whitespace.
+ XXXXXXXXXXX
lib/simplegit.rb:26: trailing whitespace.
+    def command(git_cmd)XXXX
</code></pre>

<p>コミットの前にこのコマンドを実行すれば、余計な空白文字をコミットしてしまって他の開発者に嫌がられることもなくなるでしょう。</p>

<p>次に、コミットの単位が論理的に独立した変更となるようにしましょう。つまり、個々の変更内容を把握しやすくするということです。週末に五つの問題点を修正した大規模な変更を、月曜日にまとめてコミットするなどということは避けましょう。仮に週末の間にコミットできなかったとしても、ステージングエリアを活用して月曜日にコミット内容を調整することができます。修正した問題ごとにコミットを分割し、それぞれに適切なコメントをつければいいのです。もし別々の問題の修正で同じファイルを変更しているのなら、<code>git add --patch</code> を使ってその一部だけをステージすることもできます (詳しくは第 6 章で説明します)。すべての変更を同時に追加しさえすれば、一度にコミットしようが五つのコミットに分割しようがブランチの先端は同じ状態になります。あとから変更内容をレビューする他のメンバーのことも考えて、できるだけレビューしやすい状態でコミットするようにしましょう。こうしておけば、あとからその変更の一部だけを取り消したりするのにも便利です。第 6 章では、Git を使って歴史を書き換えたり対話的にファイルをステージしたりする方法を説明します。第 6 章で説明する方法を使えば、きれいでわかりやすい歴史を作り上げることができます。</p>

<p>最後に注意しておきたいのが、コミットメッセージです。よりよいコミットメッセージを書く習慣を身に着けておくと、Git を使った共同作業をより簡単に行えるようになります。一般的な規則として、メッセージの最初には変更の概要を一行 (50 文字以内) にまとめた説明をつけるようにします。その後に空行をひとつ置いてからより詳しい説明を続けます。Git プロジェクトでは、その変更の動機やこれまでの実装との違いなどのできるだけ詳しい説明をつけることを推奨しています。参考にするとよいでしょう。また、メッセージでは命令形、現在形を使うようにしています。つまり "私は○○のテストを追加しました (I added tests for)" とか "○○のテストを追加します (Adding tests for,)" ではなく "○○のテストを追加 (Add tests for.)" 形式にするということです。Tim Pope が tpope.net で書いたテンプレート (の日本語訳) を以下に示します。</p>

<pre><code>短い (50 文字以下での) 変更内容のまとめ

必要に応じた、より詳細な説明。72文字程度で折り返します。最初の
行がメールの件名、残りの部分がメールの本文だと考えてもよいでしょ
う。最初の行と詳細な説明の間には、必ず空行を入れなければなりま
せん (詳細説明がまったくない場合は空行は不要です)。空行がないと、
rebase などがうまく動作しません。

空行を置いて、さらに段落を続けることもできます。

 - 箇条書きも可能

 - 箇条書きの記号としては、主にハイフンやアスタリスクを使います。
   箇条書き記号の前にはひとつ空白を入れ、各項目の間には空行を入
   れます。しかし、これ以外の流儀もいろいろあります。
</code></pre>

<p>すべてのコミットメッセージがこのようになっていれば、他の開発者との作業が非常に進めやすくなるでしょう。Git プロジェクトでは、このようにきれいに整形されたコミットメッセージを使っています。<code>git log --no-merges</code> を実行すれば、きれいに整形されたプロジェクトの歴史がどのように見えるかがわかります。</p>

<p>これ以降の例を含めて本書では、説明を簡潔にするためにこのような整形を省略します。そのかわりに <code>git commit</code> の <code>-m</code> オプションを使います。本書での私のやり方をまねするのではなく、ここで説明した方式を使いましょう。</p>

<h3>非公開な小規模のチーム</h3>

<p>実際に遭遇するであろう環境のうち最も小規模なのは、非公開のプロジェクトで開発者が数名といったものです。ここでいう「非公開」とは、クローズドソースであるということ。つまり、チームのメンバー以外は見られないということです。チーム内のメンバーは全員、リポジトリへのプッシュ権限を持っています。</p>

<p>こういった環境では、今まで Subversion やその他の中央管理型システムを使っていたときとほぼ同じワークフローで作業を進めることができます。オフラインでコミットできたりブランチやマージが楽だったりといった Git ならではの利点はいかせますが、作業の流れ自体は今までとほぼ同じです。最大の違いは、マージが (コミット時にサーバー側で行われるのではなく) クライアント側で行われるということです。二人の開発者が共有リポジトリで開発を始めるときにどうなるかを見ていきましょう。最初の開発者 John が、リポジトリをクローンして変更を加え、それをローカルでコミットします (これ以降のメッセージでは、プロトコル関連のメッセージを <code>...</code> で省略しています)。</p>

<pre><code># John のマシン
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
</code></pre>

<p>もう一人の開発者 Jessica も同様に、リポジトリをクローンして変更をコミットしました。</p>

<pre><code># Jessica のマシン
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
</code></pre>

<p>Jessica が作業内容をサーバーにプッシュします。</p>

<pre><code># Jessica のマシン
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master
</code></pre>

<p>John も同様にプッシュしようとしました。</p>

<pre><code># John のマシン
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
</code></pre>

<p>John はプッシュできませんでした。Jessica が先にプッシュを済ませていたからです。Subversion になじみのある人には特に注目してほしいのですが、ここで John と Jessica が編集していたのは別々のファイルです。Subversion ならこのような場合はサーバー側で自動的にマージを行いますが、Git の場合はローカルでマージしなければなりません。John は、まず Jessica の変更内容を取得してマージしてからでないと、自分の変更をプッシュできないのです。</p>

<pre><code>$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master
</code></pre>

<p>この時点で、John のローカルリポジトリは図 5-4 のようになっています。</p>

<p><img src="figures/5.4.png" title="5.4 John のリポジトリ" alt="5.4 John のリポジトリ" /></p>

<p>John の手元に Jessica がプッシュした内容が届きましたが、さらにそれを彼自身の作業にマージしてからでないとプッシュできません。</p>

<pre><code>$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
</code></pre>

<p>マージがうまくいきました。John のコミット履歴は図 5-5 のようになります。</p>

<p><img src="figures/5.5.png" title="5.5 `origin/master` をマージした後の John のリポジトリ" alt="5.5 `origin/master` をマージした後の John のリポジトリ" /></p>

<p>自分のコードが正しく動作することを確認した John は、変更内容をサーバーにプッシュします。</p>

<pre><code>$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master
</code></pre>

<p>最終的に、John のコミット履歴は図 5-6 のようになりました。</p>

<p><img src="figures/5.6.png" title="5.6 origin サーバーにプッシュした後の John の履歴" alt="5.6 origin サーバーにプッシュした後の John の履歴" /></p>

<p>一方そのころ、Jessica はトピックブランチで作業を進めていました。<code>issue54</code> というトピックブランチを作成した彼女は、そこで 3 回コミットをしました。彼女はまだ John の変更を取得していません。したがって、彼女のコミット履歴は図 5-7 のような状態です。</p>

<p><img src="figures/5.7.png" title="5.7 Jessica のコミット履歴" alt="5.7 Jessica のコミット履歴" /></p>

<p>Jessica は John の作業を取り込もうとしました。</p>

<pre><code># Jessica のマシン
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master
</code></pre>

<p>これで、さきほど John がプッシュした内容が取り込まれました。Jessica の履歴は図 5-8 のようになります。</p>

<p><img src="figures/5.8.png" title="5.8 John の変更を取り込んだ後の Jessica の履歴" alt="5.8 John の変更を取り込んだ後の Jessica の履歴" /></p>

<p>Jessica のトピックブランチ上での作業が完了しました。プッシュする前にどんな作業をマージしなければならないのかを知るため、彼女は <code>git log</code> コマンドを実行しました。</p>

<pre><code>$ git log --no-merges origin/master ^issue54
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

    removed invalid default value
</code></pre>

<p>Jessica はトピックブランチの内容を自分の <code>master</code> ブランチにマージし、同じく John の作業 (<code>origin/master</code>) も自分の <code>master</code> ブランチにマージして再び変更をサーバーにプッシュすることになります。まずは <code>master</code> ブランチに戻り、これまでの作業を統合できるようにします。</p>

<pre><code>$ git checkout master
Switched to branch "master"
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
</code></pre>

<p><code>origin/master</code> と <code>issue54</code> のどちらからマージしてもかまいません。どちらも上流にあるので、マージする順序が変わっても結果は同じなのです。どちらの順でマージしても、最終的なスナップショットはまったく同じものになります。ただそこにいたる歴史が微妙に変わってくるだけです。彼女はまず <code>issue54</code> からマージすることにしました。</p>

<pre><code>$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
</code></pre>

<p>何も問題は発生しません。ご覧の通り、単なる fast-forward です。次に Jessica は John の作業 (<code>origin/master</code>) をマージします。</p>

<pre><code>$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
</code></pre>

<p>こちらもうまく完了しました。Jessica の履歴は図 5-9 のようになります。</p>

<p><img src="figures/5.9.png" title="5.9 John の変更をマージした後の Jessica の履歴" alt="5.9 John の変更をマージした後の Jessica の履歴" /></p>

<p>これで、Jessica の <code>master</code> ブランチから <code>origin/master</code> に到達可能となります。これで自分の変更をプッシュできるようになりました (この作業の間に John は何もプッシュしていなかったものとします)。</p>

<pre><code>$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master
</code></pre>

<p>各開発者が何度かコミットし、お互いの作業のマージも無事できました。図 5-10 をごらんください。</p>

<p><img src="figures/5.10.png" title="5.10 すべての変更をサーバーに書き戻した後の Jessica の履歴" alt="5.10 すべての変更をサーバーに書き戻した後の Jessica の履歴" /></p>

<p>これがもっとも単純なワークフローです。トピックブランチでしばらく作業を進め、統合できる状態になれば自分の <code>master</code> ブランチにマージする。他の開発者の作業を取り込む場合は、<code>origin/master</code> を取得してもし変更があればマージする。そして最終的にそれをサーバーの <code>master</code> ブランチにプッシュする。全体的な流れは図 5-11 のようになります。</p>

<p><img src="figures/5.11.png" title="5.11 複数開発者での Git を使ったシンプルな開発作業のイベントシーケンス" alt="5.11 複数開発者での Git を使ったシンプルな開発作業のイベントシーケンス" /></p>

<h3>非公開で管理されているチーム</h3>

<p>次に扱うシナリオは、大規模な非公開のグループに貢献するものです。機能単位の小規模なグループで共同作業した結果を別のグループと統合するような環境での作業の進め方を学びましょう。</p>

<p>John と Jessica が共同でとある機能を実装しており、Jessica はそれとは別の件で Josie とも作業をしているものとします。彼らの勤務先は統合マネージャー型のワークフローを採用しており、各グループの作業を統合する担当者が決まっています。メインリポジトリの <code>master</code> ブランチを更新できるのは統合担当者だけです。この場合、すべての作業はチームごとのブランチで行われ、後で統合担当者がまとめることになります。</p>

<p>では、Jessica の作業の流れを追っていきましょう。彼女は二つの機能を同時に実装しており、それぞれ別の開発者と共同作業をしています。すでに自分用のリポジトリをクローンしている彼女は、まず <code>featureA</code> の作業を始めることにしました。この機能用に新しいブランチを作成し、そこで作業を進めます。</p>

<pre><code># Jessica のマシン
$ git checkout -b featureA
Switched to a new branch "featureA"
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
</code></pre>

<p>自分の作業内容を John に渡すため、彼女は <code>featureA</code> ブランチへのコミットをサーバーにプッシュしました。Jessica には <code>master</code> ブランチへのプッシュをする権限はありません。そこにプッシュできるのは統合担当者だけなのです。そこで、John との共同作業用の別のブランチにプッシュします。</p>

<pre><code>$ git push origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA
</code></pre>

<p>Jessica は John に「私の作業を <code>featureA</code> というブランチにプッシュしておいたので、見てね」というメールを送りました。John からの返事を待つ間、Jessica はもう一方の <code>featureB</code> の作業を Josie とはじめます。まず最初に、この機能用の新しいブランチをサーバーの <code>master</code> ブランチから作ります。</p>

<pre><code># Jessica のマシン
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch "featureB"
</code></pre>

<p>そして Jessica は、<code>featureB</code> ブランチに何度かコミットしました。</p>

<pre><code>$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
</code></pre>

<p>Jessica のリポジトリは図 5-12 のようになっています。</p>

<p><img src="figures/5.12.png" title="5.12 Jessica のコミット履歴" alt="5.12 Jessica のコミット履歴" /></p>

<p>この変更をプッシュしようと思ったそのときに、Josie から「私の作業を <code>featureBee</code> というブランチにプッシュしておいたので、見てね」というメールがやってきました。Jessica はまずこの変更をマージしてからでないとサーバーにプッシュすることはできません。そこで、まず Josie の変更を <code>git fetch</code> で取得しました。</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee
</code></pre>

<p>次に、<code>git merge</code> でこの内容を自分の作業にマージします。</p>

<pre><code>$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
</code></pre>

<p>ここでちょっとした問題が発生しました。彼女は、手元の <code>featureB</code> ブランチの内容をサーバーの <code>featureBee</code> ブランチにプッシュしなければなりません。このような場合は、<code>git push</code> コマンドでローカルブランチ名に続けてコロン (:) を書き、その後にリモートブランチ名を指定します。</p>

<pre><code>$ git push origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee
</code></pre>

<p>これは <em>refspec</em> と呼ばれます。第 9 章で、Git の refspec の詳細とそれで何ができるのかを説明します。</p>

<p>さて、John からメールが返ってきました。「私の変更も <code>featureA</code> ブランチにプッシュしておいたので、確認よろしく」とのことです。彼女は <code>git fetch</code> でその変更を取り込みます。</p>

<pre><code>$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA
</code></pre>

<p>そして、<code>git log</code> で何が変わったのかを確認します。</p>

<pre><code>$ git log origin/featureA ^featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
</code></pre>

<p>確認を終えた彼女は、John の作業を自分の <code>featureA</code> ブランチにマージしました。</p>

<pre><code>$ git checkout featureA
Switched to branch "featureA"
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
</code></pre>

<p>Jessica はもう少し手を入れたいところがあったので、再びコミットしてそれをサーバーにプッシュします。</p>

<pre><code>$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push origin featureA
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA
</code></pre>

<p>Jessica のコミット履歴は、この時点で図 5-13 のようになります。</p>

<p><img src="figures/5.13.png" title="5.13 Jessica がブランチにコミットした後のコミット履歴" alt="5.13 Jessica がブランチにコミットした後のコミット履歴" /></p>

<p>Jessica、Josie そして John は、統合担当者に「<code>featureA</code> ブランチと <code>featureBee</code> ブランチは本流に統合できる状態になりました」と報告しました。これらのブランチが本流に統合された後で本流を取得すると、マージコミットが新たに追加されて図 5-14 のような状態になります。</p>

<p><img src="figures/5.14.png" title="5.14 Jessica が両方のトピックブランチをマージしたあとのコミット履歴" alt="5.14 Jessica が両方のトピックブランチをマージしたあとのコミット履歴" /></p>

<p>Git へ移行するグループが続出しているのも、この「複数チームの作業を並行して進め、後で統合できる」という機能のおかげです。小さなグループ単位でリモートブランチを使った共同作業ができ、しかもそれがチーム全体の作業を妨げることがない。これは Git の大きな利点です。ここで見たワークフローをまとめると、図 5-15 のようになります。</p>

<p><img src="figures/5.15.png" title="5.15 管理されたチームでのワークフローの基本的な流れ" alt="5.15 管理されたチームでのワークフローの基本的な流れ" /></p>

<h3>小規模な公開プロジェクト</h3>

<p>公開プロジェクトに貢献するとなると、また少し話が変わってきます。そのプロジェクトのブランチを直接更新できる権限はないでしょうから、何か別の方法でメンテナに接触する必要があります。最初の例では、フォークをサポートしている Git ホスティングサービスでフォークを使って貢献する方法を説明します。repo.or.cz と GitHub はどちらもフォークに対応しており、多くのメンテナはこの方式での協力を期待しています。そしてこの次のセクションでは、メールでパッチを送る形式での貢献について説明します。</p>

<p>まずはメインリポジトリをクローンしましょう。そしてパッチ用のトピックブランチを作り、そこで作業を進めます。このような流れになります。</p>

<pre><code>$ git clone (url)
$ cd project
$ git checkout -b featureA
$ (作業)
$ git commit
$ (作業)
$ git commit
</code></pre>

<p><code>rebase -i</code> を使ってすべての作業をひとつのコミットにまとめたり、メンテナがレビューしやすいようにコミット内容を整理したりといったことも行うかもしれません。対話的なリベースの方法については第 6 章で詳しく説明します。</p>

<p>ブランチでの作業を終えてメンテナに渡せる状態になったら、プロジェクトのページに行って "Fork" ボタンを押し、自分用に書き込み可能なフォークを作成します。このリポジトリの URL をリモートとして追加しなければなりません。ここでは <code>myfork</code> という名前にしました。</p>

<pre><code>$ git remote add myfork (url)
</code></pre>

<p>自分の作業内容は、ここにプッシュすることになります。変更を master ブランチにマージしてからそれをプッシュするよりも、今作業中の内容をそのままリモートブランチにプッシュするほうが簡単でしょう。もしその変更が受け入れられなかったり一部だけが取り込まれたりした場合に、master ブランチを巻き戻す必要がなくなるからです。メンテナがあなたの作業をマージするかリベースするかあるいは一部だけ取り込むか、いずれにせよあなたはその結果をリポジトリから再度取り込むことになります。</p>

<pre><code>$ git push myfork featureA
</code></pre>

<p>自分用のフォークに作業内容をプッシュし終えたら、それをメンテナに伝えましょう。これは、よく「プルリクエスト」と呼ばれるもので、ウェブサイトから実行する (GutHub には "pull request" ボタンがあり、メンテナに自動的にメッセージを送ってくれます) こともできれば <code>git request-pull</code> コマンドの出力をプロジェクトのメンテナにメールで送ることもできます。</p>

<p><code>request-pull</code> コマンドには、トピックブランチをプルしてもらいたい先のブランチとその Git リポジトリの URL を指定します。すると、プルしてもらいたい変更の概要が出力されます。たとえば Jessica が John にプルリクエストを送ろうとしたとしましょう。彼女はすでにトピックブランチ上で 2 回のコミットを済ませています。</p>

<pre><code>$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
</code></pre>

<p>この出力をメンテナに送れば「どのブランチからフォークしたのか、どういったコミットをしたのか、そしてそれをどこにプルしてほしいのか」を伝えることができます。</p>

<p>自分がメンテナになっていないプロジェクトで作業をする場合は、<code>master</code> ブランチでは常に <code>origin/master</code> を追いかけるようにし、自分の作業はトピックブランチで進めていくほうが楽です。そうすれば、パッチが拒否されたときも簡単にそれを捨てることができます。また、作業内容ごとにトピックブランチを分離しておけば、本流のリポジトリが更新されてパッチがうまく適用できなくなったとしても簡単にリベースできるようになります。たとえば、さきほどのプロジェクトに対して別の作業をすることになったとしましょう。その場合は、先ほどプッシュしたトピックブランチを使うのではなく、メインリポジトリの <code>master</code> ブランチから新たなトピックブランチを作成します。</p>

<pre><code>$ git checkout -b featureB origin/master
$ (作業)
$ git commit
$ git push myfork featureB
$ (メンテナにメールを送る)
$ git fetch origin
</code></pre>

<p>これで、それぞれのトピックがサイロに入った状態になりました。お互いのトピックが邪魔しあったり依存しあったりすることなく、それぞれ個別に書き換えやリベースが可能となります。図 5-16 を参照ください。</p>

<p><img src="figures/5.16.png" title="5.16 featureB に関する作業のコミット履歴" alt="5.16 featureB に関する作業のコミット履歴" /></p>

<p>プロジェクトのメンテナが、他の大量のパッチを適用したあとであなたの最初のパッチを適用しようとしました。しかしその時点でパッチはすでにそのままでは適用できなくなっています。こんな場合は、そのブランチを <code>origin/master</code> の先端にリベースして衝突を解決させ、あらためて変更内容をメンテナに送ります。</p>

<pre><code>$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
</code></pre>

<p>これで、あなたの歴史は図 5-17 のように書き換えられました。</p>

<p><img src="figures/5.17.png" title="5.17 featureA の作業を終えた後のコミット履歴" alt="5.17 featureA の作業を終えた後のコミット履歴" /></p>

<p>ブランチをリベースしたので、プッシュする際には <code>-f</code> を指定しなければなりません。これは、サーバー上の <code>featureA</code> ブランチをその直系の子孫以外のコミットで上書きするためです。別のやり方として、今回の作業を別のブランチ (<code>featureAv2</code> など) にプッシュすることもできます。</p>

<p>もうひとつ別のシナリオを考えてみましょう。あなたの二番目のブランチを見たメンテナが、その考え方は気に入ったものの細かい実装をちょっと変更してほしいと連絡してきました。この場合も、プロジェクトの <code>master</code> ブランチから作業を進めます。現在の <code>origin/master</code> から新たにブランチを作成し、そこに <code>featureB</code> ブランチの変更を押し込み、もし衝突があればそれを解決し、実装をちょっと変更してからそれを新しいブランチとしてプッシュします。</p>

<pre><code>$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
$ (実装をちょっと変更する)
$ git commit
$ git push myfork featureBv2
</code></pre>

<p><code>--squash</code> オプションは、マージしたいブランチでのすべての作業をひとつのコミットにまとめ、それを現在のブランチの先頭にマージします。<code>--no-commit</code> オプションは、自動的にコミットを記録しないよう Git に指示しています。こうすれば、別のブランチのすべての変更を取り込んでさらに手元で変更を加えたものを新しいコミットとして記録できるのです。</p>

<p>そして、メンテナに「言われたとおりのちょっとした変更をしたものが <code>featureBv2</code> ブランチにあるよ」と連絡します (図 5-18 を参照ください)。</p>

<p><img src="figures/5.18.png" title="5.18 featureBv2 の作業を終えた後のコミット履歴" alt="5.18 featureBv2 の作業を終えた後のコミット履歴" /></p>

<h3>大規模な公開プロジェクト</h3>

<p>多くの大規模プロジェクトでは、パッチを受け付ける手続きが確立されています。プロジェクトによっていろいろ異なるので、まずはそのプロジェクト固有のルールがないかどうか確認しましょう。しかし、大規模なプロジェクトの多くは開発者用メーリングリストへのパッチの投稿を受け付けています。そこで、ここではそれを例にとって話を進めます。</p>

<p>実際の作業の流れは先ほどとほぼ同じで、作業する内容ごとにトピックブランチを作成することになります。違うのは、パッチをプロジェクトに提供する方法です。プロジェクトをフォークし、自分用のリポジトリにプッシュするのではなく、個々のコミットについてメールを作成し、それを開発者用メーリングリストに投稿します。</p>

<pre><code>$ git checkout -b topicA
$ (作業)
$ git commit
$ (作業)
$ git commit
</code></pre>

<p>これで二つのコミットができあがりました。これらをメーリングリストに投稿します。<code>git format-patch</code> を使うと mbox 形式のファイルが作成されるので、これをメーリングリストに送ることができます。このコマンドは、コミットメッセージの一行目を件名、残りのコミットメッセージとコミット内容のパッチを本文に書いたメールを作成します。これのよいところは、<code>format-patch</code> で作成したメールからパッチを適用すると、すべてのコミット情報が適切に維持されるというところです。次のセクションで実際にパッチを適用するところになれば、よりはっきりと実感するでしょう。</p>

<pre><code>$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
</code></pre>

<p><code>format-patch</code> コマンドは、できあがったパッチファイルの名前を出力します。<code>-M</code> スイッチは、名前が変わったことを検出するためのものです。できあがったファイルは次のようになります。</p>

<pre><code>$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
1.6.2.rc1.20.g8c5b.dirty
</code></pre>

<p>このファイルを編集して、コミットメッセージには書けなかったような情報をメーリングリスト用に追加することもできます。<code>---</code> の行とパッチの開始位置 (<code>lib/simplegit.rb</code> の行) の間にメッセージを書くと、メールを受信した人はそれを読むことができますが、パッチからは除外されます。</p>

<p>これをメーリングリストに投稿するには、メールソフトにファイルの内容を貼り付けるか、あるいはコマンドラインのプログラムを使います。ファイルの内容をコピーして貼り付けると「かしこい」メールソフトが勝手に改行の位置を変えてしまうなどの問題が起こりがちです。ありがたいことに Git には、きちんとしたフォーマットのパッチを IMAP で送ることを支援するツールが用意されています。これを使うと便利です。ここでは、パッチを Gmail で送る方法を説明しましょう。というのも、たまたま私が使ってるメールソフトが Gmail だからです。さまざまなメールソフトでの詳細なメール送信方法が、Git ソースコードにある <code>Documentation/SubmittingPatches</code> の最後に載っています。</p>

<p>まず。<code>~/.gitconfig</code> ファイルの imap セクションを設定します。それぞれの値を <code>git config</code> コマンドで順に設定してもかまいませんし、このファイルに手で書き加えてもかまいません。最終的に、設定ファイルは次のようになります。</p>

<pre><code>[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
</code></pre>

<p>IMAP サーバーで SSL を使っていない場合は、最後の二行はおそらく不要でしょう。そして host のところが <code>imaps://</code> ではなく <code>imap://</code> となります。ここまでの設定が終われば、<code>git imap-send</code> を実行して IMAP サーバーの Drafts フォルダにパッチを置くことができるようになります。</p>

<pre><code>$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done
</code></pre>

<p>あとは、Drafts フォルダに移動して To フィールドをメーリングリストのアドレスに変更し (おそらく CC には担当メンテなのアドレスを入れ)、送信できるようになりました。</p>

<p>SMTP サーバーを使ってパッチを送ることもできます。IMAP サーバー同様、設定は <code>git config</code> コマンドで順に設定してもいいですし、<code>~/.gitconfig</code> ファイルの sendmail セクションに直接入力してもかまいません。</p>

<pre><code>[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587
</code></pre>

<p>設定が追加できたら、<code>git send-email</code> を実行してパッチを送信します。</p>

<pre><code>$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
</code></pre>

<p>Git はその後、各パッチについてこのようなログ情報をはき出すはずです。</p>

<pre><code>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  \line 'From: Jessica Smith &lt;jessica@example.com&gt;'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK
</code></pre>

<h3>まとめ</h3>

<p>このセクションでは、今後みなさんが遭遇するであろうさまざまな形式の Git プロジェクトについて、関わっていくための作業手順を説明しました。そして、その際に使える新兵器もいくつか紹介しました。次はもう一方の側、つまり Git プロジェクトを運営する側について見ていきましょう。慈悲深い独裁者、あるいは統合マネージャーとしての作業手順を説明します。</p>

<h2>プロジェクトの運営</h2>

<p>プロジェクトに貢献する方法だけでなく、プロジェクトを運営する方法についても知っておくといいでしょう。たとえば <code>format-patch</code> を使ってメールで送られてきたパッチを処理する方法や、別のリポジトリのリモートブランチでの変更を統合する方法などです。本流のリポジトリを保守するにせよパッチの検証や適用を手伝うにせよ、どうすれば貢献者たちにとってわかりやすくなるかを知っておくべきでしょう。</p>

<h3>トピックブランチでの作業</h3>

<p>新しい機能を組み込もうと考えている場合は、トピックブランチを作ることをおすすめします。トピックブランチとは、新しく作業を始めるときに一時的に作るブランチのことです。そうすれば、そのパッチだけを個別にいじることができ、もしうまくいかなかったとしてもすぐに元の状態に戻すことができます。ブランチの名前は、今からやろうとしている作業の内容にあわせたシンプルな名前にしておきます。たとえば <code>ruby_client</code> などといったものです。そうすれば、しばらく時間をおいた後でそれを廃棄することになったときに、内容を思い出しやすくなります。Git プロジェクトのメンテナは、ブランチ名に名前空間を使うことが多いようです。たとえば <code>sc/ruby_client</code> のようになり、ここでの <code>sc</code> はその作業をしてくれた人の名前を短縮したものとなります。自分の master ブランチをもとにしたブランチを作成する方法は、このようになります。</p>

<pre><code>$ git branch sc/ruby_client master
</code></pre>

<p>作成してすぐそのブランチに切り替えたい場合は、<code>checkout -b</code> コマンドを使います。</p>

<pre><code>$ git checkout -b sc/ruby_client master
</code></pre>

<p>受け取った作業はこのトピックブランチですすめ、長期ブランチに統合するかどうかを判断することになります。</p>

<h3>メールで受け取ったパッチの適用</h3>

<p>あなたのプロジェクトへのパッチをメールで受け取った場合は、まずそれをトピックブランチに適用して中身を検証します。メールで届いたパッチを適用するには <code>git apply</code> と <code>git am</code> の二通りの方法があります。</p>

<h4>apply でのパッチの適用</h4>

<p><code>git diff</code> あるいは Unix の <code>diff</code> コマンドで作ったパッチを受け取ったときは、<code>git apply</code> コマンドを使ってパッチを適用します。パッチが <code>/tmp/patch-ruby-client.patch</code> にあるとすると、このようにすればパッチを適用できます。</p>

<pre><code>$ git apply /tmp/patch-ruby-client.patch
</code></pre>

<p>これは、作業ディレクトリ内のファイルを変更します。<code>patch -p1</code> コマンドでパッチをあてるのとほぼ同じなのですが、それ以上に「これでもか」というほどのこだわりを持ってパッチを適用するので fuzzy マッチになる可能性が少なくなります。また、<code>git diff</code> 形式ではファイルの追加・削除やファイル名の変更も扱うことができますが、<code>patch</code> コマンドにはそれはできません。そして最後に、<code>git apply</code> は「全部適用するか、あるいは一切適用しないか」というモデルを採用しています。一方 <code>patch</code> コマンドの場合は、途中までパッチがあたった中途半端な状態になって困ることがあります。<code>git apply</code> のほうが、 <code>patch</code> よりもこだわりを持った処理を行うのです。<code>git apply</code> コマンドはコミットを作成するわけではありません。実行した後で、その変更をステージしてコミットする必要があります。</p>

<p><code>git apply</code> を使って、そのパッチをきちんと適用できるかどうかを事前に確かめることができます。パッチをチェックするには <code>git apply --check</code> を実行します。</p>

<pre><code>$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
</code></pre>

<p>何も出力されなければ、そのパッチはうまく適用できるということです。このコマンドは、チェックに失敗した場合にゼロ以外の値を返して終了します。スクリプト内でチェックしたい場合などにはこの返り値を使用します。</p>

<h4>am でのパッチの適用</h4>

<p>コードを提供してくれた人が Git のユーザーで、<code>format-patch</code> コマンドを使ってパッチを送ってくれたとしましょう。この場合、あなたの作業はより簡単になります。パッチの中に、作者の情報やコミットメッセージも含まれているからです。「パッチを作るときには、できるだけ <code>diff</code> ではなく <code>format-patch</code> を使ってね」とお願いしてみるのもいいでしょう。昔ながらの形式のパッチが届いたときだけは <code>git apply</code> を使わなければならなくなります。</p>

<p><code>format-patch</code> で作ったパッチを適用するには <code>git am</code> を使います。技術的なお話をすると、<code>git am</code> は mbox ファイルを読み込む仕組みになっています。mbox はシンプルなプレーンテキスト形式で、一通あるいは複数のメールのメッセージをひとつのテキストファイルにまとめるためのものです。中身はこのようになります。</p>

<pre><code>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20
</code></pre>

<p>先ほどのセクションでごらんいただいたように、format-patch コマンドの出力結果もこれと同じ形式で始まっていますね。これは、mbox 形式のメールフォーマットとしても正しいものです。<code>git send-email</code> を正しく使ったパッチが送られてきた場合、受け取ったメールを mbox 形式で保存して <code>git am</code> コマンドでそのファイルを指定すると、すべてのパッチの適用が始まります。複数のメールをまとめてひとつの mbox に保存できるメールソフトを使っていれば、送られてきたパッチをひとつのファイルにまとめて <code>git am</code> で一度に適用することもできます。</p>

<p>しかし、<code>format-patch</code> で作ったパッチがチケットシステム (あるいはそれに類する何か) にアップロードされたような場合は、まずそのファイルをローカルに保存して、それを <code>git am</code> に渡すことになります。</p>

<pre><code>$ git am 0001-limit-log-function.patch
Applying: add limit to log function
</code></pre>

<p>どんなパッチを適用したのかが表示され、コミットも自動的に作られます。作者の情報はメールの <code>From</code> ヘッダと <code>Date</code> ヘッダから取得し、コミットメッセージは <code>Subject</code> とメールの本文 (パッチより前の部分) から取得します。たとえば、先ほどごらんいただいた mbox の例にあるパッチを適用した場合は次のようなコミットとなります。</p>

<pre><code>$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20
</code></pre>

<p><code>Commit</code> には、そのパッチを適用した人と適用した日時が表示されます。<code>Author</code> には、そのパッチを実際に作成した人と作成した日時が表示されます。</p>

<p>しかし、パッチが常にうまく適用できるとは限りません。パッチを作成したときの状態と現在のメインブランチとが大きくかけ離れてしまっていたり、そのパッチが別の (まだ適用していない) パッチに依存していたりなどといったことがあり得るでしょう。そんな場合は <code>git am</code> は失敗し、次にどうするかを聞かれます。</p>

<pre><code>$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".
</code></pre>

<p>このコマンドは、何か問題が発生したファイルについて衝突マークを書き込みます。これは、マージやリベースに失敗したときに書き込まれるのとよく似たものです。問題を解決する方法も同じです。まずはファイルを編集して衝突を解決し、新しいファイルをステージし、<code>git am --resolved</code> を実行して次のパッチに進みます。</p>

<pre><code>$ (ファイルを編集する)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
</code></pre>

<p>Git にもうちょっと賢く働いてもらって衝突を回避したい場合は、<code>-3</code> オプションを使用します。これは、Git で三方向のマージを行うオプションです。このオプションはデフォルトでは有効になっていません。適用するパッチの元になっているコミットがあなたのリポジトリ上のものでない場合に正しく動作しないからです。パッチの元になっているコミットが手元にある場合は、<code>-3</code> オプションを使うと、衝突しているパッチをうまく適用できます。</p>

<pre><code>$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
</code></pre>

<p>ここでは、既に適用済みのパッチを適用してみました。<code>-3</code> オプションがなければ、衝突が発生していたことでしょう。</p>

<p>たくさんのパッチが含まれる mbox からパッチを適用するときには、<code>am</code> コマンドを対話モードで実行することもできます。パッチが見つかるたびに処理を止め、それを適用するかどうかの確認を求められます。</p>

<pre><code>$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
</code></pre>

<p>これは、「大量にあるパッチについて、内容をまず一通り確認したい」「既に適用済みのパッチは適用しないようにしたい」などの場合に便利です。</p>

<p>トピックブランチ上でそのトピックに関するすべてのパッチの適用を済ませてコミットすれば、次はそれを長期ブランチに統合するかどうか (そしてどのように統合するか) を考えることになります。</p>

<h3>リモートブランチのチェックアウト</h3>

<p>自前のリポジトリを持つ Git ユーザーが自分のリポジトリに変更をプッシュし、そのリポジトリの URL とリモートブランチ名だけをあなたにメールで連絡してきた場合のことを考えてみましょう。そのリポジトリをリモートとして登録し、それをローカルにマージすることになります。</p>

<p>Jessica から「すばらしい新機能を作ったので、私のリポジトリの <code>ruby-client</code> ブランチを見てください」といったメールが来たとします。これを手元でテストするには、リモートとしてこのリポジトリを追加し、ローカルにブランチをチェックアウトします。</p>

<pre><code>$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
</code></pre>

<p>「この前のとは違う、別のすばらしい機能を作ったの!」と別のブランチを伝えられた場合は、すでにリモートの設定が済んでいるので単にそのブランチを取得してチェックアウトするだけで確認できます。</p>

<p>この方法は、誰かと継続的に共同作業を進めていく際に便利です。ちょっとしたパッチをたまに提供してくれるだけの人の場合は、パッチをメールで受け取るようにしたほうが時間の節約になるでしょう。全員に自前のサーバーを用意させて、たまに送られてくるパッチを取得するためだけに定期的にリモートの追加と削除を行うなどというのは時間の無駄です。ほんの数件のパッチを提供してくれる人たちを含めて数百ものリモートを管理することなど、きっとあなたはお望みではないでしょう。しかし、スクリプトやホスティングサービスを使えばこの手の作業は楽になります。つまり、どのような方式をとるかは、あなたや他のメンバーがどのような方式で開発を進めるかによって決まります。</p>

<p>この方式のもうひとつの利点は、コミットの履歴も同時に取得できるということです。マージの際に問題が起こることもあるでしょうが、そんな場合にも相手の作業が自分側のどの地点に基づくものなのかを知ることができます。適切に三方向のマージが行われるので、<code>-3</code> を指定したときに「このパッチの基点となるコミットにアクセスできればいいなぁ」と祈る必要はありません。</p>

<p>継続的に共同作業を続けるわけではないけれど、それでもこの方式でパッチを取得したいという場合は、リモートリポジトリの URL を <code>git pull</code> コマンドで指定することもできます。これは一度きりのプルに使うものであり、リモートを参照する URL は保存されません。</p>

<pre><code>$ git pull git://github.com/onetimeguy/project.git
From git://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.
</code></pre>

<h3>何が変わるのかの把握</h3>

<p>トピックブランチの中に、提供してもらった作業が含まれた状態になりました。次に何をすればいいのか考えてみましょう。このセクションでは、これまでに扱ったいくつかのコマンドを復習します。それらを使って、もしこの変更をメインブランチにマージしたらいったい何が起こるのかを調べていきましょう。</p>

<p>トピックブランチのコミットのうち、master ブランチに存在しないコミットの内容をひとつひとつレビューできれば便利でしょう。master ブランチに含まれるコミットを除外するには、ブランチ名の前に <code>--not</code> オプションを指定します。たとえば、誰かから受け取った二つのパッチを適用するために <code>contrib</code> というブランチを作成したとすると、</p>

<pre><code>$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better
</code></pre>

<p>このようなコマンドを実行すればそれぞれのコミットの内容を確認できます。<code>git log</code> に <code>-p</code> オプションを渡せば、コミットの後に diff を表示させることもできます。これも以前に説明しましたね。</p>

<p>このトピックブランチを別のブランチにマージしたときに何が起こるのかを完全な diff で知りたい場合は、ちょっとした裏技を使わないと正しい結果が得られません。おそらく「こんなコマンドを実行するだけじゃないの?」と考えておられることでしょう。</p>

<pre><code>$ git diff master
</code></pre>

<p>このコマンドで表示される diff は、誤解を招きかねないものです。トピックブランチを切った時点からさらに <code>master</code> ブランチが先に進んでいたとすると、これは少し奇妙に見える結果を返します。というのも、Git は現在のトピックブランチの最新のコミットのスナップショットと <code>master</code> ブランチの最新のコミットのスナップショットを直接比較するからです。トピックブランチを切った後に <code>master</code> ブランチ上であるファイルに行を追加したとすると、スナップショットを比較した結果は「トピックブランチでその行を削除しようとしている」状態になります。</p>

<p><code>master</code> がトピックブランチの直系の先祖である場合は、これは特に問題とはなりません。しかし二つの歴史が分岐している場合には、diff の結果は「トピックブランチで新しく追加したすべての内容を追加し、<code>master</code> ブランチにしかないものはすべて削除する」というものになります。</p>

<p>本当に知りたいのはトピックブランチで変更された内容、つまりこのブランチを master にマージしたときに master に加わる変更です。これを知るには、Git に「トピックブランチの最新のコミット」と「トピックブランチと master ブランチの直近の共通の先祖」とを比較させます。</p>

<p>共通の先祖を見つけだしてそこからの diff を取得するには、このようにします。</p>

<pre><code>$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db
</code></pre>

<p>しかし、これでは不便です。そこで Git には、同じことをより手短にやるための手段としてトリプルドット構文が用意されています。<code>diff</code> コマンドを実行するときにピリオドを三つ打った後に別のブランチを指定すると、「現在いるブランチの最新のコミット」と「指定した二つのブランチの共通の先祖」とを比較するようになります。</p>

<pre><code>$ git diff master...contrib
</code></pre>

<p>このコマンドは、master との共通の先祖から分岐した現在のトピックブランチで変更された内容のみを表示します。この構文は、覚えやすいので非常に便利です。</p>

<h3>提供された作業の取り込み</h3>

<p>トピックブランチでの作業をメインブランチに取り込む準備ができたら、どのように取り込むかを考えることになります。さらに、プロジェクトを運営していくにあたっての全体的な作業の流れはどのようにしたらいいでしょうか? さまざまな方法がありますが、ここではそのうちのいくつかを紹介します。</p>

<h4>マージのワークフロー</h4>

<p>シンプルなワークフローのひとつとして、作業を自分の <code>master</code> ブランチに取り込むことを考えます。ここでは、<code>master</code> ブランチで安定版のコードを管理しているものとします。トピックブランチでの作業が一段落したら (あるいは誰かから受け取ったパッチをトピックブランチ上で検証し終えたら)、それを master ブランチにマージしてからトピックブランチを削除し、作業を進めることになります。<code>ruby_client</code> および <code>php_client</code> の二つのブランチを持つ図 5-19 のようなリポジトリでまず <code>ruby_client</code> をマージしてから <code>php_client</code> もマージすると、歴史は図 5-20 のようになります。</p>

<p><img src="figures/5.19.png" title="5.19 いくつかのトピックブランチを含む履歴" alt="5.19 いくつかのトピックブランチを含む履歴" /></p>

<p><img src="figures/5.20.png" title="5.20 トピックブランチをマージした後の状態" alt="5.20 トピックブランチをマージした後の状態" /></p>

<p>これがおそらく一番シンプルなワークフローでしょうが、大規模なリポジトリやプロジェクトで作業をしていると問題が発生することもあります。</p>

<p>多人数で開発していたり大規模なプロジェクトに参加していたりする場合は、二段階以上のマージサイクルを使うこともあるでしょう。ここでは、長期間運用するブランチが <code>master</code> と <code>develop</code> のふたつあるものとします。<code>master</code> が更新されるのは安定版がリリースされるときだけで、新しいコードはずべて <code>develop</code> ブランチに統合されるという流れです。これらのブランチは、両方とも定期的に公開リポジトリにプッシュすることになります。新しいトピックブランチをマージする準備ができたら (図 5-21)、それを <code>develop</code> にマージします (図 5-22)。そしてリリースタグを打つときに、<code>master</code> を現在の <code>develop</code> ブランチが指す位置に進めます (図 5-23)。</p>

<p><img src="figures/5.21.png" title="5.21 トピックブランチのマージ前" alt="5.21 トピックブランチのマージ前" /></p>

<p><img src="figures/5.22.png" title="5.22 トピックブランチのマージ後" alt="5.22 トピックブランチのマージ後" /></p>

<p><img src="figures/5.23.png" title="5.23 トピックブランチのリリース後" alt="5.23 トピックブランチのリリース後" /></p>

<p>他の人があなたのプロジェクトをクローンするときには、master をチェックアウトすれば最新の安定版をビルドすることができ、その後の更新を追いかけるのも容易にできるようになります。一方 develop をチェックアウトすれば、さらに最先端の状態を取得することができます。この考え方を推し進めると、統合用のブランチを用意してすべての作業をいったんそこにマージするようにもできます。統合ブランチ上のコードが安定してテストを通過すれば、それを develop ブランチにマージします。そしてそれが安定していることが確認できたら master ブランチを先に進めるということになります。</p>

<h4>大規模マージのワークフロー</h4>

<p>Git 開発プロジェクトには、常時稼働するブランチが四つあります。<code>master</code>、<code>next</code>、そして新しい作業用の <code>pu</code> (proposed updates) とメンテナンスバックポート用の <code>maint</code> です。新しいコードを受け取ったメンテナは、まず自分のリポジトリのトピックブランチにそれを格納します。先ほど説明したのと同じ方式です (図 5-24 を参照ください)。そしてその内容を検証し、安全に取り込める状態かさらなる作業が必要かを見極めます。だいじょうぶだと判断したらそれを <code>next</code> にマージします。このブランチをプッシュすれば、すべてのメンバーがそれを試せるようになります。</p>

<p><img src="figures/5.24.png" title="5.24 複数のトピックブランチの並行管理" alt="5.24 複数のトピックブランチの並行管理" /></p>

<p>さらに作業が必要なトピックについては、<code>pu</code> にマージします。完全に安定していると判断されたトピックについては改めて <code>master</code> にマージされ、<code>next</code> にあるトピックのうちまだ <code>master</code> に入っていないものを再構築します。つまり、<code>master</code> はほぼ常に前に進み、<code>next</code> は時々リベースされ、<code>pu</code> はそれ以上の頻度でリベースされることになります (図 5-25 を参照ください)。</p>

<p><img src="figures/5.25.png" title="5.25 常時稼働する統合用ブランチへのトピックブランチのマージ" alt="5.25 常時稼働する統合用ブランチへのトピックブランチのマージ" /></p>

<p>最終的に <code>master</code> にマージされたトピックブランチは、リポジトリから削除します。Git 開発プロジェクトでは <code>maint</code> ブランチも管理しています。これは最新のリリースからフォークしたもので、メンテナンスリリースに必要なバックポート用のパッチを管理します。つまり、Git のリポジトリをクローンするとあなたは四つのブランチをチェックアウトすることができるということです。これらのブランチはどれも異なる開発段階を表し、「どこまで最先端を追いかけたいか」「どのように Git プロジェクトに貢献したいか」によって使い分けることになります。メンテナ側では、新たな貢献を受け入れるためのワークフローが整っています。</p>

<h4>リベースとチェリーピックのワークフロー</h4>

<p>受け取った作業を master ブランチにマージするのではなく、リベースやチェリーピックを使って master ブランチの先端につなげていく方法を好むメンテナもいます。そのほうがほぼ直線的な歴史を保てるからです。トピックブランチでの作業を終えて統合できる状態になったと判断したら、そのブランチで rebase コマンドを実行し、その変更を現在の master (あるいは <code>develop</code> などの) ブランチの先端につなげます。うまくいけば、<code>master</code> ブランチをそのまま前に進めてることでプロジェクトの歴史を直線的に進めることができます。</p>

<p>あるブランチの作業を別のブランチに移すための手段として、他にチェリーピック (つまみぐい) という方法があります。Git におけるチェリーピックとは、コミット単位でのリベースのようなものです。あるコミットによって変更された内容をパッチとして受け取り、それを現在のブランチに再適用します。トピックブランチでいくつかコミットしたうちのひとつだけを統合したい場合、あるいはトピックブランチで一回だけコミットしたけれどそれをリベースではなくチェリーピックで取り込みたい場合などにこの方法を使用します。図 5-26 のようなプロジェクトを例にとって考えましょう。</p>

<p><img src="figures/5.26.png" title="5.26 チェリーピック前の歴史" alt="5.26 チェリーピック前の歴史" /></p>

<p>コミット <code>e43a6</code> を master ブランチに取り込むには、次のようにします。</p>

<pre><code>$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
</code></pre>

<p>これは <code>e43a6</code> と同じ内容の変更を施しますが、コミットの SHA-1 値は新しくなります。適用した日時が異なるからです。これで、歴史は図 5-27 のように変わりました。</p>

<p><img src="figures/5.27.png" title="5.27 トピックブランチのコミットをチェリーピックした後の歴史" alt="5.27 トピックブランチのコミットをチェリーピックした後の歴史" /></p>

<p>あとは、このトピックブランチを削除すれば取り込みたくない変更を消してしまうことができます。</p>

<h3>リリース用のタグ付け</h3>

<p>いよいよリリースする時がきました。おそらく、後からいつでもこのリリースを取得できるようにタグを打っておくことになるでしょう。新しいタグを打つ方法は第 2 章で説明しました。タグにメンテナの署名を入れておきたい場合は、このようにします。</p>

<pre><code>$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon &lt;schacon@gmail.com&gt;"
1024-bit DSA key, ID F721C45A, created 2009-02-09
</code></pre>

<p>タグに署名した場合、署名に使用した PGP 鍵ペアの公開鍵をどのようにして配布するかが問題になるかもしれません。Git 開発プロジェクトのメンテナ達がこの問題をどのように解決したかというと、自分たちの公開鍵を blob としてリポジトリに含め、それを直接指すタグを追加することにしました。この方法を使うには、まずどの鍵を使うかを決めるために <code>gpg --list-keys</code> を実行します。</p>

<pre><code>$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
</code></pre>

<p>鍵を直接 Git データベースにインポートするには、鍵をエクスポートしてそれをパイプで <code>git hash-object</code> に渡します。これは、鍵の中身を新しい blob として Git に書き込み、その blob の SHA-1 を返します。</p>

<pre><code>$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
</code></pre>

<p>鍵の中身を Git に取り込めたので、この鍵を直接指定するタグを作成できるようになりました。<code>hash-object</code> コマンドで知った SHA-1 値を指定すればいいのです。</p>

<pre><code>$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
</code></pre>

<p><code>git push --tags</code> を実行すると、<code>maintainer-pgp-pub</code> タグをみんなと共有できるようになります。誰かがタグを検証したい場合は、あなたの PGP 鍵が入った blob をデータベースから直接プルで取得し、それを PGP にインポートすればいいのです。</p>

<pre><code>$ git show maintainer-pgp-pub | gpg --import
</code></pre>

<p>この鍵をインポートした人は、あなたが署名したすべてのタグを検証できるようになります。タグのメッセージに検証手順の説明を含めておけば、<code>git show &lt;tag&gt;</code> でエンドユーザー向けに詳しい検証手順を示すことができます。</p>

<h3>ビルド番号の生成</h3>

<p>Git では、コミットごとに 'v123' のような単調な番号を振っていくことはありません。もし特定のコミットに対して人間がわかりやすい名前がほしければ、そのコミットに対して <code>git describe</code> を実行します。Git は、そのコミットに最も近いタグの名前とそのタグからのコミット数、そしてそのコミットの SHA-1 値の一部を使った名前を作成します。</p>

<pre><code>$ git describe master
v1.6.2-rc1-20-g8c5b85c
</code></pre>

<p>これで、スナップショットやビルドを公開するときにわかりやすい名前をつけられるようになります。実際、Git そのもののソースコードを Git リポジトリからクローンしてビルドすると、<code>git --version</code> が返す結果はこの形式になります。タグが打たれているコミットを直接指定した場合は、タグの名前が返されます。</p>

<p><code>git describe</code> コマンドは注釈付きのタグ (<code>-a</code> あるいは <code>-s</code> フラグをつけて作成したタグ) を使います。したがって、<code>git describe</code> を使うならリリースタグは注釈付きのタグとしなければなりません。そうすれば、describe したときにコミットの名前を適切につけることができます。この文字列を checkout コマンドや show コマンドでの対象の指定に使うこともできますが、これは末尾にある SHA-1 値の省略形に依存しているので将来にわたってずっと使えるとは限りません。たとえば Linux カーネルは、最近 SHA-1 オブジェクトの一意性を確認するための文字数を 8 文字から 10 文字に変更しました。そのため、古い <code>git describe</code> の出力での名前はもはや使えません。</p>

<h3>リリースの準備</h3>

<p>実際にリリースするにあたって行うであろうことのひとつに、最新のスナップショットのアーカイブを作るという作業があります。Git を使っていないというかわいそうな人たちにもコードを提供するために。その際に使用するコマンドは <code>git archive</code> です。</p>

<pre><code>$ git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz
</code></pre>

<p>tarball を開けば、プロジェクトのディレクトリの下に最新のスナップショットが得られます。まったく同じ方法で zip アーカイブを作成することもできます。この場合は <code>git archive</code> で <code>--format=zip</code> オプションを指定します。</p>

<pre><code>$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip
</code></pre>

<p>これで、あなたのプロジェクトのリリース用にすてきな tarball と zip アーカイブができあがりました。これをウェブサイトにアップロードするなりメールで送ってあげるなりしましょう。</p>

<h3>短いログ</h3>

<p>そろそろメーリングリストにメールを送り、プロジェクトに何が起こったのかをみんなに知らせてあげましょう。前回のリリースから何が変わったのかの変更履歴を手軽に取得するには <code>git shortlog</code> コマンドを使います。これは、指定した範囲のすべてのコミットのまとめを出力します。たとえば、直近のリリースの名前が v1.0.1 だった場合は、次のようにすると前回のリリース以降のすべてのコミットの概要が得られます。</p>

<pre><code>$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2
</code></pre>

<p>v1.0.1 以降のすべてのコミットの概要が、作者別にまとめて得られました。これをメーリングリストに投稿するといいでしょう。</p>

<h2>まとめ</h2>

<p>Git を使っているプロジェクトにコードを提供したり、自分のプロジェクトに他のユーザーからのコードを取り込んだりといった作業を安心してこなせるようになりましたね。おめでとうございます。Git を使いこなせる開発者の仲間入りです! 次の章では、複雑な状況に対応するためのより強力なツールやヒントを学びます。これであなたは真の Git マスターとなることでしょう。</p>
<h1>Git のさまざまなツール</h1>

<p>Git を使ったソースコード管理のためのリポジトリの管理や保守について、日々使用するコマンドやワークフローの大半を身につけました。ファイルの追跡やコミットといった基本的なタスクをこなせるようになっただけではなくステージングエリアの威力もいかせるようになりました。また気軽にトピックブランチを切ってマージする方法も知りました。</p>

<p>では、Git の非常に強力な機能の数々をさらに探っていきましょう。日々の作業でこれらを使うことはあまりありませんが、いつかは必要になるかもしれません。</p>

<h2>リビジョンの選択</h2>

<p>Git で特定のコミットやコミットの範囲を指定するにはいくつかの方法があります。明白なものばかりではありませんが、知っておくと役立つでしょう。</p>

<h3>単一のリビジョン</h3>

<p>SHA-1 ハッシュを指定すれば、コミットを明確に参照することができます。しかしそれ以外にも、より人間にやさしい方式でコミットを参照することもできます。このセクションでは単一のコミットを参照するためのさまざまな方法の概要を説明します。</p>

<h3>SHA の短縮形</h3>

<p>Git は、最初の数文字をタイプしただけであなたがどのコミットを指定したいのかを汲み取ってくれます。条件は、SHA-1 の最初の 4 文字以上を入力していることと、それでひとつのコミットが特定できる (現在のリポジトリに、入力した文字ではじまる SHA-1 のコミットがひとつしかない) ことです。</p>

<p>あるコミットを指定するために <code>git log</code> コマンドを実行し、とある機能を追加したコミットを見つけました。</p>

<pre><code>$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
</code></pre>

<p>探していたのは、<code>1c002dd....</code> で始まるコミットです。<code>git show</code> でこのコミットを見るときは、次のどのコマンドでも同じ結果になります (短いバージョンで、重複するコミットはないものとします)。</p>

<pre><code>$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
</code></pre>

<p>一意に特定できる範囲での SHA-1 の短縮形を Git に見つけさせることもできます。<code>git log</code> コマンドで <code>--abbrev-commit</code> を指定すると、コミットを一意に特定できる範囲の省略形で出力します。デフォルトでは 7 文字ぶん表示しますが、それだけで SHA-1 を特定できない場合はさらに長くなります。</p>

<pre><code>$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
</code></pre>

<p>ひとつのプロジェクト内での一意性を確保するには、普通は 8 文字から 10 文字もあれば十分すぎることでしょう。最も大規模な Git プロジェクトのひとつである Linux カーネルの場合は、40 文字のうち先頭の 12 文字を指定しないと一意性を確保できません。</p>

<h3>SHA-1 に関するちょっとしたメモ</h3>

<p>「リポジトリ内のふたつのオブジェクトがたまたま同じ SHA-1 ハッシュ値を持ってしまったらどうするの?」と心配する人も多いでしょう。実際、どうなるのでしょう?</p>

<p>すでにリポジトリに存在するオブジェクトと同じ SHA-1 値を持つオブジェクトをコミットしてした場合、Git はすでにそのオブジェクトがデータベースに格納されているものと判断します。そのオブジェクトを後からどこかで取得しようとすると、常に最初のオブジェクトのデータが手元にやってきます (訳注: つまり、後からコミットした内容は存在しないことになってしまう)。</p>

<p>しかし、そんなことはまず起こりえないということを知っておくべきでしょう。SHA-1 ダイジェストの大きさは 20 バイト (160 ビット) です。ランダムなハッシュ値がつけられた中で、たった一つの衝突が 50% の確率で発生するために必要なオブジェクトの数は約 2<sup>80</sup> となります (衝突の可能性の計算式は <code>p = (n(n-1)/2) * (1/2^160)</code> です)。2<sup>80</sup> は、ほぼ 1.2 x 10<sup>24</sup> 、つまり一兆二千億のそのまた一兆倍です。これは、地球上にあるすべての砂粒の数の千二百倍にあたります。</p>

<p>SHA-1 の衝突を見るにはどうしたらいいのか、ひとつの例をごらんに入れましょう。地球上の人類 65 億人が全員プログラムを書いていたとします。そしてその全員が、Linux カーネルのこれまでの開発履歴 (100 万の Git オブジェクト) と同等のコードを一秒で書き上げ、馬鹿でかい単一の Git リポジトリにプッシュしていくとします。これを五年間続けたとして、SHA-1 オブジェクトの衝突がひとつでも発生する可能性がやっと 50% になります。それよりも「あなたの所属する開発チームの全メンバーが、同じ夜にそれぞれまったく無関係の事件で全員オオカミに殺されてしまう」可能性のほうがよっぽど高いことでしょう。</p>

<h3>ブランチの参照</h3>

<p>特定のコミットを参照するのに一番直感的なのは、そのコミットを指すブランチがある場合です。コミットオブジェクトや SHA-1 値を指定する場面ではどこでも、その代わりにブランチ名を指定することができます。たとえば、あるブランチ上の最新のコミットを表示したい場合は次のふたつのコマンドが同じ意味となります (<code>topic1</code> ブランチが <code>ca82a6d</code> を指しているものとします)。</p>

<pre><code>$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
</code></pre>

<p>あるブランチがいったいどの SHA を指しているのか、あるいはその他の例の内容が結局のところどの SHA に行き着くのかといったことを知るには、Git の調査用ツールである <code>rev-parse</code> を使います。こういった調査用ツールのより詳しい情報は第 9 章で説明します。<code>rev-parse</code> は低レベルでの操作用のコマンドであり、日々の操作で使うためのものではありません。しかし、今実際に何が起こっているのかを知る必要があるときなどには便利です。ブランチ上で <code>rev-parse</code> を実行すると、このようになります。</p>

<pre><code>$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
</code></pre>

<h3>参照ログの短縮形</h3>

<p>あなたがせっせと働いている間に Git が裏でこっそり行っていることのひとつが、参照ログ (reflog) の管理です。これは、HEAD とブランチの参照が過去数ヶ月間どのように動いてきたかをあらわすものです。</p>

<p>参照ログを見るには <code>git reflog</code> を使います。</p>

<pre><code>$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
</code></pre>

<p>何らかの理由でブランチの先端が更新されるたびに、Git はその情報をこの一時履歴に格納します。そして、このデータを使って過去のコミットを指定することもできます。リポジトリの HEAD の五つ前の状態を知りたい場合は、先ほど見た reflog の出力のように <code>@{n}</code> 形式で参照することができます。</p>

<pre><code>$ git show HEAD@{5}
</code></pre>

<p>この構文を使うと、指定した期間だけさかのぼったときに特定のブランチがどこを指していたかを知ることもできます。たとえば <code>master</code> ブランチの昨日の状態を知るには、このようにします。</p>

<pre><code>$ git show master@{yesterday}
</code></pre>

<p>こうすると、そのブランチの先端が昨日どこを指していたかを表示します。この技が使えるのは参照ログにデータが残っている間だけなので、直近数ヶ月よりも前のコミットについては使うことができません。</p>

<p>参照ログの情報を <code>git log</code> の出力風の表記で見るには <code>git log -g</code> を実行します。</p>

<pre><code>$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
</code></pre>

<p>参照ログの情報は、完全にローカルなものであることに気をつけましょう。これは、あなた自身が自分のリポジトリで何をしたのかを示す記録です。つまり、同じリポジトリをコピーした別の人の参照ログとは異なる内容になります。また、最初にリポジトリをクローンした直後の参照ログは空となります。まだリポジトリ上であなたが何もしていないからです。<code>git show HEAD@{2.months.ago}</code> が動作するのは、少なくとも二ヶ月以上前にそのリポジトリをクローンした場合のみで、もしつい 5 分前にクローンしたばかりなら何も結果を返しません。</p>

<h3>家系の参照</h3>

<p>コミットを特定する方法として他によく使われるのが、その家系をたどっていく方法です。参照の最後に <code>^</code> をつけると、Git はそれを「指定したコミットの親」と解釈します。あなたのプロジェクトの歴史がこのようになっていたとしましょう。</p>

<pre><code>$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
</code></pre>

<p>直前のコミットを見るには <code>HEAD^</code> を指定します。これは "HEAD の親" という意味になります。</p>

<pre><code>$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
</code></pre>

<p><code>^</code> の後に数字を指定することもできます。たとえば <code>d921970^2</code> は "d921970 の二番目の親" という意味になります。これが役立つのはマージコミット (親が複数存在する) のときくらいでしょう。最初の親はマージを実行したときにいたブランチとなり、二番目の親は取り込んだブランチ上のコミットとなります。</p>

<pre><code>$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
</code></pre>

<p>家系の指定方法としてもうひとつよく使うのが <code>~</code> です。これも最初の親を指します。つまり <code>HEAD~</code> と <code>HEAD^</code> は同じ意味になります。違いが出るのは、数字を指定したときです。<code>HEAD~2</code> は "最初の親の最初の親" つまり "祖父母" という意味になります。指定した数だけ、順に最初の親をさかのぼっていくことになります。たとえば、先ほど示したような歴史上では <code>HEAD~3</code> は次のようになります。</p>

<pre><code>$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
</code></pre>

<p>これは <code>HEAD^^^</code> のようにあらわすこともできます。これは「最初の親の最初の親の最初の親」という意味になります。</p>

<pre><code>$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
</code></pre>

<p>これらふたつの構文を組み合わせることもできます。直近の参照 (マージコミットだったとします) の二番目の親を取得するには <code>HEAD~3^2</code> などとすればいいのです。</p>

<h3>コミットの範囲指定</h3>

<p>個々のコミットを指定できるようになったので、次はコミットの範囲を指定する方法を覚えていきましょう。これは、ブランチをマージするときに便利です。たくさんのブランチを持っている場合など「で、このブランチの作業のなかでまだメインブランチにマージしていないのはどれだったっけ?」といった疑問に答えるために範囲指定を使えます。</p>

<h4>ダブルドット</h4>

<p>範囲指定の方法としてもっとも一般的なのが、ダブルドット構文です。これは、ひとつのコミットからはたどれるけれどもうひとつのコミットからはたどれないというコミットの範囲を Git に調べさせるものです。図 6-1 のようなコミット履歴を例に考えましょう。</p>

<p><img src="figures/6.1.png" title="6.1 範囲指定選択用の歴史の例" alt="6.1 範囲指定選択用の歴史の例" /></p>

<p>experiment ブランチの内容のうち、まだ master ブランチにマージされていないものを調べることになりました。対象となるコミットのログを見るには、Git に <code>master..experiment</code> と指示します。これは "experiment からはたどれるけれど、master からはたどれないすべてのコミット" という意味です。説明を短く簡潔にするため、実際のログの出力のかわりに上の図の中でコミットオブジェクトをあらわす文字を使うことにします。</p>

<pre><code>$ git log master..experiment
D
C
</code></pre>

<p>もし逆に、<code>master</code> には存在するけれども <code>experiment</code> には存在しないすべてのコミットが知りたいのなら、ブランチ名を逆にすればいいのです。<code>experiment..master</code> とすれば、<code>master</code> のすべてのコミットのうち <code>experiment</code> からたどれないものを取得できます。</p>

<pre><code>$ git log experiment..master
F
E
</code></pre>

<p>これは、<code>experiment</code> ブランチを最新の状態に保つために何をマージしなければならないのかを知るのに便利です。もうひとつ、この構文をよく使う例としてあげられるのが、これからリモートにプッシュしようとしている内容を知りたいときです。</p>

<pre><code>$ git log origin/master..HEAD
</code></pre>

<p>このコマンドは、現在のブランチ上でのコミットのうち、リモート <code>origin</code> の <code>master</code> ブランチに存在しないものをすべて表示します。現在のブランチが <code>origin/master</code> を追跡しているときに <code>git push</code> を実行すると、<code>git log origin/master..HEAD</code> で表示されたコミットがサーバーに転送されます。この構文で、どちらか片方を省略することもできます。その場合、Git は省略したほうを HEAD とみなします。たとえば、<code>git log origin/master..</code> と入力すると先ほどの例と同じ結果が得られます。Git は、省略した側を HEAD に置き換えて処理を進めるのです。</p>

<h4>複数のポイント</h4>

<p>ダブルドット構文は、とりあえず使うぶんには便利です。しかし、二つよりもっと多くのブランチを指定してリビジョンを特定したいこともあるでしょう。複数のブランチの中から現在いるブランチには存在しないコミットを見つける場合などです。Git でこれを行うには <code>^</code> 文字を使うか、あるいはそこからたどりつけるコミットが不要な参照の前に <code>--not</code> をつけます。これら三つのコマンドは、同じ意味となります。</p>

<pre><code>$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
</code></pre>

<p>これらの構文が便利なのは、二つよりも多くの参照を使って指定できるというところです。ダブルドット構文では二つの参照しか指定できませんでした。たとえば、<code>refA</code> と <code>refB</code> のどちらかからはたどれるけれども <code>refC</code> からはたどれないコミットを取得したい場合は、次のいずれかを実行します。</p>

<pre><code>$ git log refA refB ^refC
$ git log refA refB --not refC
</code></pre>

<p>この非常に強力なリビジョン問い合わせシステムを使えば、今あなたのブランチに何があるのかを知るのに非常に役立つことでしょう。</p>

<h4>トリプルドット</h4>

<p>範囲指定選択の主な構文であとひとつ残っているのがトリプルドット構文です。これは、ふたつの参照のうちどちらか一方からのみたどれるコミット (つまり、両方からたどれるコミットは含まない) を指定します。図 6-1 で示したコミット履歴の例を振り返ってみましょう。<code>master</code> あるいは <code>experiment</code> に存在するコミットのうち、両方に存在するものを除いたコミットを知りたい場合は次のようにします。</p>

<pre><code>$ git log master...experiment
F
E
D
C
</code></pre>

<p>これは通常の <code>log</code> の出力と同じですが、これら四つのコミットについての情報しか表示しません。表示順は、従来どおりコミット日時順となります。</p>

<p>この場合に <code>log</code> コマンドでよく使用するスイッチが <code>--left-right</code> です。このスイッチは、それぞれのコミットがどちら側に存在するのかを表示します。これを使うとデータをより活用しやすくなるでしょう。</p>

<pre><code>$ git log --left-right master...experiment
&lt; F
&lt; E
&gt; D
&gt; C
</code></pre>

<p>これらのツールを使えば、より簡単に「どれを調べたいのか」を Git に伝えられるようになります。</p>

<h2>対話的なステージング</h2>

<p>Git には、コマンドラインでの作業をしやすくするためのスクリプトがいくつか付属しています。ここでは、対話コマンドをいくつか紹介しましょう。これらを使うと、コミットの内容に細工をして特定のコミットだけとかファイルの中の一部だけとかを含めるようにすることが簡単にできるようになります。大量のファイルを変更した後に、それをひとつの馬鹿でかいコミットにしてしまうのではなくテーマごとの複数のコミットに分けて処理したい場合などに非常に便利です。このようにして各コミットを論理的に独立した状態にしておけば、同僚によるレビューも容易になります。<code>git add</code> に <code>-i</code> あるいは <code>--interactive</code> というオプションをつけて実行すると、Git は対話シェルモードに移行し、このように表示されます。</p>

<pre><code>$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt;
</code></pre>

<p>このコマンドは、ステージングエリアに関する情報を違った観点で表示します。<code>git status</code> で得られる情報と基本的には同じですが、より簡潔で有益なものとなっています。ステージした変更が左側、そしてステージしていない変更が右側に表示されます。</p>

<p>Commands セクションでは、さまざまなことができるようになっています。ファイルをステージしたりステージングエリアから戻したり、ファイルの一部だけをステージしたりまだ追跡されていないファイルを追加したり、あるいは何がステージされたのかを diff で見たりといったことが可能です。</p>

<h3>ファイルのステージとその取り消し</h3>

<p><code>What now&gt;</code> プロンプトで <code>2</code> または <code>u</code> と入力すると、どのファイルをステージするかを聞いてきます。</p>

<pre><code>What now&gt; 2
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;
</code></pre>

<p>TODO と index.html をステージするには、その番号を入力します。</p>

<pre><code>Update&gt;&gt; 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;
</code></pre>

<p>ファイル名の横に <code>*</code> がついていれば、そのファイルがステージ対象として選択されたことを意味します。<code>Update&gt;&gt;</code> プロンプトで何も入力せずに Enter を押すと、選択されたすべてのファイルを Git がステージします。</p>

<pre><code>Update&gt;&gt;
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
</code></pre>

<p>TODO と index.html がステージされ、simplegit.rb はまだステージされていないままです。ここで仮に TODO ファイルのステージを取り消したくなったとしたら、<code>3</code> あるいは <code>r</code> (revert の r) を選択します。</p>

<pre><code>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; [enter]
reverted one path
</code></pre>

<p>もう一度 Git のステータスを見ると、TODO ファイルのステージが取り消されていることがわかります。</p>

<pre><code>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
</code></pre>

<p>ステージした変更の diff を見るには、<code>6</code> あるいは <code>d</code> (diff の d) を使用します。このコマンドは、ステージしたファイルの一覧を表示します。その中から、ステージされた diff を見たいファイルを選択します。これは、コマンドラインで <code>git diff --cached</code> を使用するのと同じようなことです。</p>

<pre><code>*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff&gt;&gt; 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 &lt;p id="out"&gt;...&lt;/p&gt;

-&lt;div id="footer"&gt;contact : support@github.com&lt;/div&gt;
+&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;

 &lt;script type="text/javascript"&gt;
</code></pre>

<p>これらの基本的なコマンドを使えば、ステージングエリアでの対話的な追加モードを多少簡単に扱えるようになるでしょう。</p>

<h3>パッチのステージ</h3>

<p>Git では、ファイルの特定の箇所だけをステージして他の部分はそのままにしておくということもできます。たとえば、simplegit.rb のふたつの部分を変更したけれど、そのうちの一方だけをステージしたいという場合があります。Git なら、そんなことも簡単です。対話モードのプロンプトで <code>5</code> あるいは <code>p</code> (patch の p) と入力しましょう。Git は、どのファイルを部分的にステージしたいのかを聞いてきます。その後、選択したファイルのそれぞれについて diff のハンクを順に表示し、ステージするかどうかをひとつひとつたずねます。</p>

<pre><code>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log -n 25 #{treeish}")
+    command("git log -n 30 #{treeish}")
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?
</code></pre>

<p>ここでは多くの選択肢があります。何ができるのかを見るには <code>?</code> を入力しましょう。</p>

<pre><code>Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk
n - do not stage this hunk
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help
</code></pre>

<p>たいていは、<code>y</code> か <code>n</code> で各ハンクをステージするかどうかを指定していくでしょう。しかし、それ以外にも「このファイルの残りのハンクをすべてステージする」とか「このハンクをステージするかどうかの判断を先送りする」などというオプションも便利です。あるファイルのひとつの箇所だけをステージして残りはそのままにした場合、ステータスの出力はこのようになります。</p>

<pre><code>What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb
</code></pre>

<p>simplegit.rb のステータスがおもしろいことになっています。ステージされた行もあれば、ステージされていない行もあるという状態です。つまり、このファイルを部分的にステージしたというわけです。この時点で対話的追加モードを抜けて <code>git commit</code> を実行すると、ステージした部分だけをコミットすることができます。</p>

<p>最後に、この対話的追加モードを使わずに部分的なステージを行いたい場合は、コマンドラインから <code>git add -p</code> あるいは <code>git add --patch</code> を実行すれば同じことができます。</p>

<h2>作業を隠す</h2>

<p>何らかのプロジェクトの一員として作業している場合にありがちなのですが、ある作業が中途半端な状態になっているときに、ブランチを切り替えてちょっとだけ別の作業をしたくなることがあります。中途半端な状態をコミットしてしまうのはいやなので、できればコミットせずにしておいて後でその状態から作業を再開したいものです。そんなときに使うのが <code>git stash</code> コマンドです。</p>

<p>これは、作業ディレクトリのダーティな状態 (追跡しているファイルのうち変更されたもの、そしてステージされた変更) を受け取って未完了の作業をスタックに格納し、あとで好きなときに再度それを適用できるようにするものです。</p>

<h3>自分の作業を隠す</h3>

<p>例を見てみましょう。自分のプロジェクトでいくつかのファイルを編集し、その中のひとつをステージしたとします。ここで <code>git status</code> を実行すると、ダーティな状態を確認することができます。</p>

<pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#      modified:   index.html
#
# Changes not staged for commit:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
</code></pre>

<p>ここで別のブランチに切り替えることになりましたが、現在の作業内容はまだコミットしたくありません。そこで、変更をいったん隠すことにします。新たにスタックに隠すには <code>git stash</code> を実行します。</p>

<pre><code>$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file
(To restore them type "git stash apply")
</code></pre>

<p>これで、作業ディレクトリはきれいな状態になりました。</p>

<pre><code>$ git status
# On branch master
nothing to commit, working directory clean
</code></pre>

<p>これで、簡単にブランチを切り替えて別の作業をできるようになりました。これまでの変更内容はスタックに格納されています。今までに格納した内容を見るには <code>git stash list</code> を使います。</p>

<pre><code>$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
</code></pre>

<p>この例では、以前にも二回ほど作業を隠していたようです。そこで、三種類の異なる作業にアクセスできるようになっています。先ほど隠した変更を再度適用するには、stash コマンドの出力に書かれていたように <code>git stash apply</code> コマンドを実行します。それよりもっと前に隠したものを適用したい場合は <code>git stash apply stash@{2}</code> のようにして名前を指定することもできます。名前を指定しなければ、Git は直近に隠された変更を再適用します。</p>

<pre><code>$ git stash apply
# On branch master
# Changes not staged for commit:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#
#      modified:   index.html
#      modified:   lib/simplegit.rb
#
</code></pre>

<p>Git がファイルを変更して、未コミットのファイルが先ほどスタックに隠したときと同じ状態に戻ったことがわかるでしょう。今回は、作業ディレクトリがきれいな状態で変更を書き戻しました。また、変更を隠したときと同じブランチに書き戻しています。しかし、隠した内容を再適用するためにこれらが必須条件であるというわけではありません。あるブランチの変更を隠し、別のブランチに移動して移動先のブランチにそれを書き戻すこともできます。また、隠した変更を書き戻す際に、現在のブランチに未コミットの変更があってもかまいません。もしうまく書き戻せなかった場合は、マージ時のコンフリクトと同じようになります。</p>

<p>さて、ファイルへの変更はもとどおりになりましたが、以前にステージしていたファイルはステージされていません。これを行うには、<code>git stash apply</code> コマンドに <code>--index</code> オプションをつけて実行し、変更のステージ処理も再適用するよう指示しなければなりません。先ほどのコマンドのかわりにこれを実行すると、元の状態に戻ります。</p>

<pre><code>$ git stash apply --index
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#      modified:   index.html
#
# Changes not staged for commit:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
</code></pre>

<p>apply オプションは、スタックに隠した作業を再度適用するだけで、スタックにはまだその作業が残ったままになります。スタックから削除するには、<code>git stash drop</code> に削除したい作業の名前を指定して実行します。</p>

<pre><code>$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
</code></pre>

<p>あるいは <code>git stash pop</code> を実行すれば、隠した内容を再適用してその後スタックからも削除してくれます。</p>

<h3>隠した内容の適用の取り消し</h3>

<p>隠した変更を適用して何らかの作業をした後に、先ほどの適用を取り消してしまいたくなることもあるでしょう。そんなときに使えそうな <code>stash unapply</code> コマンドは git にはありませんが、同じような操作をすることはできます。適用した変更を表すパッチを取得して、それを逆に適用すればいいのです。</p>

<pre><code>$ git stash show -p stash@{0} | git apply -R
</code></pre>

<p>名前を指定しなければ、Git は直近に隠した変更を使うものとみなします。</p>

<pre><code>$ git stash show -p | git apply -R
</code></pre>

<p>次の例のようにエイリアスを作れば、Git に <code>stash-unapply</code> コマンドを追加したのと事実上同じことになります。</p>

<pre><code>$ git config --global alias.stash-unapply '!git stash show -p | git apply -R'
$ git stash
$ #... 何か作業をして ...
$ git stash-unapply
</code></pre>

<h3>隠した変更からのブランチの作成</h3>

<p>作業をいったん隠し、しばらくそのブランチで作業を続けていると、隠した内容を再適用するときに問題が発生する可能性があります。隠した後に何らかの変更をしたファイルに変更を再適用しようとすると、マージ時にコンフリクトが発生してそれを解決しなければならなくなるでしょう。もう少しお手軽な方法で以前の作業を確認したい場合は <code>git stash branch</code> を実行します。このコマンドは、まず新しいブランチを作成し、作業をスタックに隠したときのコミットをチェックアウトし、スタックにある作業を再適用し、それに成功すればスタックからその作業を削除します。</p>

<pre><code>$ git stash branch testchanges
Switched to a new branch "testchanges"
# On branch testchanges
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#      modified:   index.html
#
# Changes not staged for commit:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)
</code></pre>

<p>これを使うと、保存していた作業をお手軽に復元して新しいブランチで作業をすることができます。</p>

<h2>歴史の書き換え</h2>

<p>Git を使って作業をしていると、何らかの理由でコミットの歴史を書き換えたくなることが多々あります。Git のすばらしい点のひとつは、何をどうするかの決断をぎりぎりまで先送りできることです。どのファイルをどのコミットに含めるのかは、ステージングエリアの内容をコミットする直前まで変更することができますし、既に作業した内容でも stash コマンドを使えばまだ作業していないことにできます。また、すでにコミットしてしまった変更についても、それを書き換えてまるで別の方法で行ったかのようにすることもできます。コミットの順序を変更したり、コミットメッセージやコミットされるファイルを変更したり、複数のコミットをひとつにまとめたりひとつのコミットを複数に分割したり、コミットそのものをなかったことにしたり……といった作業を、変更内容を他のメンバーに公開する前ならいつでもすることができます。</p>

<p>このセクションでは、これらの便利な作業の方法について扱います。これで、あなたのコミットの歴史を思い通りに書き換えてから他の人と共有できるようになります。</p>

<h3>直近のコミットの変更</h3>

<p>直近のコミットを変更するというのは、歴史を書き換える作業のうちもっともよくあるものでしょう。直近のコミットに対して手を加えるパターンとしては、コミットメッセージを変更したりそのコミットで記録されるスナップショットを変更 (ファイルを追加・変更あるいは削除) したりといったものがあります。</p>

<p>単に直近のコミットメッセージを変更したいだけの場合は非常にシンプルです。</p>

<pre><code>$ git commit --amend
</code></pre>

<p>これを実行するとテキストエディタが開きます。すでに直近のコミットメッセージが書き込まれた状態になっており、それを変更することができます。変更を保存してエディタを終了すると、変更後のメッセージを含む新しいコミットを作成して直近のコミットをそれで置き換えます。</p>

<p>いったんコミットしたあとで、そこにさらにファイルを追加したり変更したりしたくなったとしましょう。「新しく作ったファイルを追加し忘れた」とかがありそうですね。この場合の手順も基本的には同じです。ファイルを編集して <code>git add</code> したり追跡中のファイルを <code>git rm</code> したりしてステージングエリアをお好みの状態にしたら、続いて <code>git commit --amend</code> を実行します。すると、現在のステージングエリアの状態を次回のコミット用のスナップショットにします。</p>

<p>この技を使う際には注意が必要です。この処理を行うとコミットの SHA-1 が変わるからです。いわば、非常に小規模なリベースのようなものです。すでにプッシュしているコミットは書き換えないようにしましょう。</p>

<h3>複数のコミットメッセージの変更</h3>

<p>さらに歴史をさかのぼったコミットを変更したい場合は、もう少し複雑なツールを使わなければなりません。Git には歴史を修正するツールはありませんが、リベースツールを使って一連のコミットを (別の場所ではなく) もともとあった場所と同じ HEAD につなげるという方法を使うことができます。対話的なリベースツールを使えば、各コミットについてメッセージを変更したりファイルを追加したりお望みの変更をすることができます。対話的なリベースを行うには、<code>git rebase</code> に <code>-i</code> オプションを追加します。どこまでさかのぼってコミットを書き換えるかを指示するために、どのコミットにリベースするかを指定しなければなりません。</p>

<p>直近の三つのコミットメッセージあるいはそのいずれかを変更したくなった場合、変更したい最古のコミットの親を <code>git rebase -i</code> の引数に指定します。ここでは <code>HEAD~2^</code> あるいは <code>HEAD~3</code> となります。直近の三つのコミットを編集しようと考えているのだから、<code>~3</code> のほうが覚えやすいでしょう。しかし、実際のところは四つ前 (変更したい最古のコミットの親) のコミットを指定していることに注意しましょう。</p>

<pre><code>$ git rebase -i HEAD~3
</code></pre>

<p>これはリベースコマンドであることを認識しておきましょう。 <code>HEAD~3..HEAD</code> に含まれるすべてのコミットは、実際にメッセージを変更したか否かにかかわらずすべて書き換えられます。すでに中央サーバーにプッシュしたコミットをここに含めてはいけません。含めてしまうと、同じ変更が別のバージョンで見えてしまうことになって他の開発者が混乱します。</p>

<p>このコマンドを実行すると、テキストエディタが開いてコミットの一覧が表示され、このようになります。</p>

<pre><code>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>

<p>このコミット一覧の表示順は、<code>log</code> コマンドを使ったときの通常の表示順とは逆になることに注意しましょう。<code>log</code> を実行すると、このようになります。</p>

<pre><code>$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
</code></pre>

<p>逆順になっていますね。対話的なリベースを実行するとスクリプトが出力されるので、それをあとで実行することになります。このスクリプトはコマンドラインで指定したコミット (<code>HEAD~3</code>) から始まり、それ以降のコミットを古い順に再現していきます。最新のものからではなく古いものから表示されているのは、最初に再現するのがいちばん古いコミットだからです。</p>

<p>このスクリプトを編集し、手を加えたいコミットのところでスクリプトを停止させるようにします。そのためには、各コミットのうちスクリプトを停止させたいものについて「pick」を「edit」に変更します。たとえば、三番目のコミットメッセージだけを変更したい場合はこのようにファイルを変更します。</p>

<pre><code>edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
</code></pre>

<p>これを保存してエディタを終了すると、Git はそのリストの最初のコミットまで処理を巻き戻し、次のようなメッセージとともにコマンドラインを返します。</p>

<pre><code>$ git rebase -i HEAD~3
Stopped at 7482e0d... updated the gemspec to hopefully work better
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
</code></pre>

<p>この指示が、まさにこれからすべきことを教えてくれています。</p>

<pre><code>$ git commit --amend
</code></pre>

<p>と打ち込んでコミットメッセージを変更してからエディタを終了し、次に</p>

<pre><code>$ git rebase --continue
</code></pre>

<p>を実行します。このコマンドはその他のふたつのコミットも自動的に適用するので、これで作業は終了です。複数行で「pick」を「edit」に変更した場合は、これらの作業を各コミットについてくりかえすことになります。それぞれの場面で Git が停止するので、amend でコミットを書き換えて continue で処理を続けます。</p>

<h3>コミットの並べ替え</h3>

<p>対話的なリベースで、コミットの順番を変更したり完全に消し去ってしまったりすることもできます。"added cat-file" のコミットを削除して残りの二つのコミットの適用順を反対にしたい場合は、リベーススクリプトを</p>

<pre><code>pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
</code></pre>

<p>から</p>

<pre><code>pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
</code></pre>

<p>のように変更します。これを保存してエディタを終了すると、Git はまずこれらのコミットの親までブランチを巻き戻してから <code>310154e</code> を適用し、その次に <code>f7f3f6d</code> を適用して停止します。これで、効率的にコミット順を変更して "added cat-file" のコミットは完全に取り除くことができました。</p>

<h3>コミットのまとめ</h3>

<p>一連のコミット群をひとつのコミットにまとめて押し込んでしまうことも、対話的なリベースツールで行うことができます。リベースメッセージの中に、その手順が出力されています。</p>

<pre><code>#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>

<p>「pick」や「edit」のかわりに「squash」を指定すると、Git はその変更と直前の変更をひとつにまとめて新たなコミットメッセージを書き込めるようにします。つまり、これらの三つのコミットをひとつのコミットにまとめたい場合は、スクリプトをこのように変更します。</p>

<pre><code>pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
</code></pre>

<p>これを保存してエディタを終了すると、Git は三つの変更をすべて適用してからエディタに戻るので、そこでコミットメッセージを変更します。</p>

<pre><code># This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
</code></pre>

<p>これを保存すると、さきほどの三つのコミットの内容をすべて含んだひとつのコミットができあがります。</p>

<h3>コミットの分割</h3>

<p>コミットの分割は、いったんコミットを取り消してから部分的なステージとコミットを繰り返して行います。たとえば、先ほどの三つのコミットのうち真ん中のものを分割することになったとしましょう。"updated README formatting and added blame" のコミットを、"updated README formatting" と "added blame" のふたつに分割します。そのためには、<code>rebase -i</code> スクリプトを実行してそのコミットの指示を「edit」に変更します。</p>

<pre><code>pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
</code></pre>

<p>変更を保存してエディタを終了すると、Git はリストの最初のコミットの親まで処理を巻き戻します。そして最初のコミット (<code>f7f3f6d</code>) と二番目のコミット (<code>310154e</code>) を適用してからコンソールに戻ります。コミットをリセットするには <code>git reset HEAD^</code> を実行します。これはコミット自体を取り消し、変更されたファイルはステージしていない状態にします。ここまでくれば､取り消された変更点から必要なものだけを選択してコミットすることができます｡一連のコミットが終わったら､以下のように<code>git rebase --continue</code> を実行しましょう｡</p>

<pre><code>$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
</code></pre>

<p>Git はスクリプトの最後のコミット (<code>a5f4a0d</code>) を適用し、歴史はこのようになります。</p>

<pre><code>$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
</code></pre>

<p>念のためにもう一度言いますが、この変更はリスト内のすべてのコミットの SHA を変更します。すでに共有リポジトリにプッシュしたコミットは、このリストに表示させないようにしましょう。</p>

<h3>最強のオプション: filter-branch</h3>

<p>歴史を書き換える方法がもうひとつあります。これは、大量のコミットの書き換えを機械的に行いたい場合 (メールアドレスを一括変更したりすべてのコミットからあるファイルを削除したりなど) に使うものです。そのためのコマンドが <code>filter-branch</code> です。これは歴史を大規模にばさっと書き換えることができるものなので、プロジェクトを一般に公開した後や書き換え対象のコミットを元にしてだれかが作業を始めている場合はまず使うことはありません。しかし、これは非常に便利なものでもあります。一般的な使用例をいくつか説明するので、それをもとにこの機能を使いこなせる場面を考えてみましょう。</p>

<h4>全コミットからのファイルの削除</h4>

<p>これは、相当よくあることでしょう。誰かが不注意で <code>git add .</code> をした結果、巨大なバイナリファイルが間違えてコミットされてしまったとしましょう。これを何とか削除してしまいたいものです。あるいは、間違ってパスワードを含むファイルをコミットしてしまったとしましょう。このプロジェクトをオープンソースにしたいと思ったときに困ります。<code>filter-branch</code> は、こんな場合に歴史全体を洗うために使うツールです。passwords.txt というファイルを歴史から完全に抹殺してしまうには、<code>filter-branch</code> の <code>--tree-filter</code> オプションを使います。</p>

<pre><code>$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
</code></pre>

<p><code>--tree-filter</code> オプションは、プロジェクトの各チェックアウトに対して指定したコマンドを実行し、結果を再コミットします。この場合は、すべてのスナップショットから passwords.txt というファイルを削除します。間違えてコミットしてしまったエディタのバックアップファイルを削除するには、<code>git filter-branch --tree-filter "rm -f *~" HEAD</code> のように実行します。</p>

<p>Git がツリーを書き換えてコミットし、ブランチのポインタを末尾に移動させる様子がごらんいただけるでしょう。この作業は、まずはテスト用ブランチで実行してから結果をよく吟味し、それから master ブランチに適用することをおすすめします。<code>filter-branch</code> をすべてのブランチで実行するには、このコマンドに <code>--all</code> を渡します。</p>

<h4>サブディレクトリを新たなルートへ</h4>

<p>別のソース管理システムからのインポートを終えた後、無意味なサブディレクトリ (trunk、tags など) が残っている状態を想定しましょう。すべてのコミットの <code>trunk</code> ディレクトリを新たなプロジェクトルートとしたい場合にも、<code>filter-branch</code> が助けになります。</p>

<pre><code>$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
</code></pre>

<p>これで、新たなプロジェクトルートはそれまで <code>trunk</code> ディレクトリだった場所になります。Git は、このサブディレクトリに影響を及ぼさないコミットを自動的に削除します。</p>

<h4>メールアドレスの一括変更</h4>

<p>もうひとつよくある例としては、「作業を始める前に <code>git config</code> で名前とメールアドレスを設定することを忘れていた」とか「業務で開発したプロジェクトをオープンソースにするにあたって、職場のメールアドレスをすべて個人アドレスに変更したい」などがあります。どちらの場合についても、複数のコミットのメールアドレスを一括で変更することになりますが、これも <code>filter-branch</code> ですることができます。注意して、あなたのメールアドレスのみを変更しなければなりません。そこで、<code>--commit-filter</code> を使います。</p>

<pre><code>$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
</code></pre>

<p>これで、すべてのコミットであなたのアドレスを新しいものに書き換えます。コミットにはその親の SHA-1 値が含まれるので、このコマンドは (マッチするメールアドレスが存在するものだけではなく) すべてのコミットを書き換えます。</p>

<h2>Git によるデバッグ</h2>

<p>Git には、プロジェクトで発生した問題をデバッグするためのツールも用意されています。Git はほとんどあらゆる種類のプロジェクトで使えるように設計されているので、このツールも非常に汎用的なものです。しかし、バグを見つけたり不具合の原因を探したりするための助けとなるでしょう。</p>

<h3>ファイルの注記</h3>

<p>コードのバグを追跡しているときに「それが、いつどんな理由で追加されたのか」が知りたくなることがあるでしょう。そんな場合にもっとも便利なのが、ファイルの注記です。これは、ファイルの各行について、その行を最後に更新したのがどのコミットかを表示します。もしコードの中の特定のメソッドにバグがあることを見つけたら、そのファイルを <code>git blame</code> しましょう。そうすれば、そのメソッドの各行がいつ誰によって更新されたのかがわかります。この例では、<code>-L</code> オプションを使って 12 行目から 22 行目までに出力を限定しています。</p>

<pre><code>$ git blame -L 12,22 simplegit.rb
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command("git show #{tree}")
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command("git log #{tree}")
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command("git blame #{path}")
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end
</code></pre>

<p>最初の項目は、その行を最後に更新したコミットの SHA-1 の一部です。次のふたつの項目は、そのコミットから抽出した作者情報とコミット日時です。これで、いつ誰がその行を更新したのかが簡単にわかります。それに続いて、行番号とファイルの中身が表示されます。<code>^4832fe2</code> のコミットに関する行に注目しましょう。これらの行は、ファイルが最初にコミットされたときのままであることを表します。このコミットはファイルがプロジェクトに最初に追加されたときのものであり、これらの行はそれ以降変更されていません。これはちょっと戸惑うかも知れません。Git では、これまで紹介してきただけで少なくとも三種類以上の意味で <code>^</code> を使っていますからね。しかし、ここではそういう意味になるのです。</p>

<p>Git のすばらしいところのひとつに、ファイルのリネームを明示的には追跡しないということがあります。スナップショットだけを記録し、もしリネームされていたのなら暗黙のうちにそれを検出します。この機能の興味深いところは、ファイルのリネームだけでなくコードの移動についても検出できるということです。<code>git blame</code> に <code>-C</code> を渡すと Git はそのファイルを解析し、別のところからコピーされたコード片がないかどうかを探します。最近私は <code>GITServerHandler.m</code> というファイルをリファクタリングで複数のファイルに分割しました。そのうちのひとつが <code>GITPackUpload.m</code> です。ここで <code>-C</code> オプションをつけて <code>GITPackUpload.m</code> を調べると、コードのどの部分をどのファイルからコピーしたのかを知ることができます。</p>

<pre><code>$ git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)
</code></pre>

<p>これはほんとうに便利です。通常は、そのファイルがコピーされたときのコミットを知ることになります。コピー先のファイルにおいて最初にその行をさわったのが、その内容をコピーしてきたときだからです。Git は、その行が本当に書かれたコミットがどこであったのかを (たとえ別のファイルであったとしても) 教えてくれるのです。</p>

<h3>二分探索</h3>

<p>ファイルの注記を使えば、その問題がどの時点で始まったのかを知ることができます。何がおかしくなったのかがわからず、最後にうまく動作していたときから何十何百ものコミットが行われている場合などは、<code>git bisect</code> に頼ることになるでしょう。<code>bisect</code> コマンドはコミットの歴史に対して二分探索を行い、どのコミットで問題が混入したのかを可能な限り手早く見つけ出せるようにします。</p>

<p>自分のコードをリリースして運用環境にプッシュしたあとに、バグ報告を受け取ったと仮定しましょう。そのバグは開発環境では再現せず、なぜそんなことになるのか想像もつきません。コードをよく調べて問題を再現させることはできましたが、何が悪かったのかがわかりません。こんな場合に、二分探索で原因を特定することができます。まず、<code>git bisect start</code> を実行します。そして次に <code>git bisect bad</code> を使って、現在のコミットが壊れた状態であることをシステムに伝えます。次に、まだ壊れていなかったとわかっている直近のコミットを <code>git bisect good [good_commit]</code> で伝えます。</p>

<pre><code>$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo
</code></pre>

<p>Git は、まだうまく動いていたと指定されたコミット (v1.0) と現在の壊れたバージョンの間には 12 のコミットがあるということを検出しました。そして、そのちょうど真ん中にあるコミットをチェックアウトしました。ここでテストを実行すれば、このコミットで同じ問題が発生するかどうかがわかります。もし問題が発生したなら、実際に問題が混入したのはそれより前のコミットだということになります。そうでなければ、それ以降のコミットで問題が混入したのでしょう。ここでは、問題が発生しなかったものとします。<code>git bisect good</code> で Git にその旨を伝え、旅を続けましょう。</p>

<pre><code>$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing
</code></pre>

<p>また別のコミットがやってきました。先ほど調べたコミットと「壊れている」と伝えたコミットの真ん中にあるものです。ふたたびテストを実行し、今度はこのコミットで問題が再現したものとします。それを Git に伝えるには <code>git bisect bad</code> を使います。</p>

<pre><code>$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table
</code></pre>

<p>このコミットはうまく動きました。というわけで、問題が混入したコミットを特定するための情報がこれですべて整いました。Git は問題が混入したコミットの SHA-1 を示し、そのコミット情報とどのファイルが変更されたのかを表示します。これを使って、いったい何が原因でバグが発生したのかを突き止めます。</p>

<pre><code>$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &lt;pjhyett@example.com&gt;
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config
</code></pre>

<p>原因がわかったら、作業を始める前に <code>git bisect reset</code> を実行して HEAD を作業前の状態に戻さなければなりません。そうしないと面倒なことになってしまいます。</p>

<pre><code>$ git bisect reset
</code></pre>

<p>この強力なツールを使えば、何百ものコミットの中からバグの原因となるコミットを数分で見つけだせるようになります。実際、プロジェクトが正常なときに 0 を返してどこかおかしいときに 0 以外を返すスクリプトを用意しておけば、<code>git bisect</code> を完全に自動化することもできます。まず、先ほどと同じく、壊れているコミットと正しく動作しているコミットを指定します。これは <code>bisect start</code> コマンドで行うこともできます。まず最初に壊れているコミット、そしてその後に正しく動作しているコミットを指定します。</p>

<pre><code>$ git bisect start HEAD v1.0
$ git bisect run test-error.sh
</code></pre>

<p>こうすると、チェックアウトされたコミットに対して自動的に <code>test-error.sh</code> を実行し、壊れる原因となるコミットを見つけ出すまで自動的に処理を続けます。<code>make</code> や <code>make tests</code>、その他自動テストを実行するためのプログラムなどをここで実行させることもできます。</p>

<h2>サブモジュール</h2>

<p>あるプロジェクトで作業をしているときに、プロジェクト内で別のプロジェクトを使わなければならなくなることがよくあります。サードパーティが開発しているライブラリや、自身が別途開発していて複数の親プロジェクトから利用しているライブラリなどがそれにあたります。こういったときに出てくるのが「ふたつのプロジェクトはそれぞれ別のものとして管理したい。だけど、一方を他方の一部としても使いたい」という問題です。</p>

<p>例を考えてみましょう。ウェブサイトを制作しているあなたは、Atom フィードを作成することになりました。Atom 生成コードを自前で書くのではなく、ライブラリを使うことに決めました。この場合、CPAN や gem などの共有ライブラリからコードをインクルードするか、ソースコードそのものをプロジェクトのツリーに取り込むかのいずれかが必要となります。ライブラリをインクルードする方式の問題は、ライブラリのカスタマイズが困難であることと配布が面倒になるということです。すべてのクライアントにそのライブラリを導入させなければなりません。コードをツリーに取り込む方式の問題は、手元でコードに手を加えてしまうと本家の更新に追従しにくくなるということです。</p>

<p>Git では、サブモジュールを使ってこの問題に対応します。サブモジュールを使うと、ある Git リポジトリを別の Git リポジトリのサブディレクトリとして扱うことができるようになります。これで、別のリポジトリをプロジェクト内にクローンしても自分のコミットは別管理とすることができるようになります。</p>

<h3>サブモジュールの作り方</h3>

<p>Rack ライブラリ (Ruby のウェブサーバーゲートウェイインターフェイス) を自分のプロジェクトに取り込むことになったとしましょう。手元で変更を加えるかもしれませんが、本家で更新があった場合にはそれを取り込み続けるつもりです。まず最初にしなければならないことは、外部のリポジトリをサブディレクトリにクローンすることです。外部のプロジェクトをサブモジュールとして追加するには <code>git submodule add</code> コマンドを使用します。</p>

<pre><code>$ git submodule add git://github.com/chneukirchen/rack.git rack
Initialized empty Git repository in /opt/subtest/rack/.git/
remote: Counting objects: 3181, done.
remote: Compressing objects: 100% (1534/1534), done.
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
Receiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.
Resolving deltas: 100% (1951/1951), done.
</code></pre>

<p>これで、プロジェクト内の <code>rack</code> サブディレクトリに Rack プロジェクトが取り込まれました。このサブディレクトリに入って変更を加えたり、書き込み権限のあるリモートリポジトリを追加してそこに変更をプッシュしたり、本家のリポジトリの内容を取得してマージしたり、さまざまなことができるようになります。サブモジュールを追加した直後に <code>git status</code> を実行すると、二つのものが見られます。</p>

<pre><code>$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
#      new file:   .gitmodules
#      new file:   rack
#
</code></pre>

<p>まず気づくのが <code>.gitmodules</code> ファイルです。この設定ファイルには、プロジェクトの URL とそれを取り込んだローカルサブディレクトリの対応が格納されています。</p>

<pre><code>$ cat .gitmodules
[submodule "rack"]
      path = rack
      url = git://github.com/chneukirchen/rack.git
</code></pre>

<p>複数のサブモジュールを追加した場合は、このファイルに複数のエントリが書き込まれます。このファイルもまた他のファイルと同様にバージョン管理下に置かれることに注意しましょう。<code>.gitignore</code> ファイルと同じことです。プロジェクトの他のファイルと同様、このファイルもプッシュやプルの対象となります。プロジェクトをクローンした人は、このファイルを使ってサブモジュールの取得元を知ることになります。</p>

<p><code>git status</code> の出力に、もうひとつ rack というエントリが含まれています。これに対して <code>git diff</code> を実行すると、ちょっと興味深い結果が得られます。</p>

<pre><code>$ git diff --cached rack
diff --git a/rack b/rack
new file mode 160000
index 0000000..08d709f
--- /dev/null
+++ b/rack
@@ -0,0 +1 @@
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
</code></pre>

<p><code>rack</code> は作業ディレクトリ内にあるサブディレクトリですが、Git はそれがサブモジュールであるとみなし、あなたがそのディレクトリにいない限りその中身を追跡することはありません。そのかわりに、Git はこのサブディレクトリを元のプロジェクトの特定のコミットとして記録します。このサブディレクトリ内に変更を加えてコミットすると、親プロジェクト側で HEAD が変わったことを検知し、実際の作業内容をコミットとして記録します。そうすることで、他の人がこのプロジェクトをクローンしたときに正しく環境を作れるようになります。</p>

<p>ここがサブモジュールのポイントです。サブモジュールは、それがある場所の実際のコミットとして記録され、<code>master</code> やその他の参照として記録することはできません。</p>

<p>コミットすると、このようになります。</p>

<pre><code>$ git commit -m 'first commit with submodule rack'
[master 0550271] first commit with submodule rack
 2 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 .gitmodules
 create mode 160000 rack
</code></pre>

<p>rack エントリのモードが 160000 となったことに注目しましょう。これは Git における特別なモードで、サブディレクトリやファイルではなくディレクトリエントリとしてこのコミットを記録したことを意味します。</p>

<p><code>rack</code> ディレクトリを独立したプロジェクトとして扱い、ときどき親プロジェクトをアップデートして親プロジェクトの最新コミットにポインタを移動させることができます。すべての Git コマンドが、これらふたつのディレクトリで独立して使用可能です。</p>

<pre><code>$ git log -1
commit 0550271328a0038865aad6331e620cd7238601bb
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Apr 9 09:03:56 2009 -0700

    first commit with submodule rack
$ cd rack/
$ git log -1
commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
Author: Christian Neukirchen &lt;chneukirchen@gmail.com&gt;
Date:   Wed Mar 25 14:49:04 2009 +0100

    Document version change
</code></pre>

<h3>サブモジュールを含むプロジェクトのクローン</h3>

<p>ここでは、内部にサブモジュールを含むプロジェクトをクローンしてみます。すると、サブモジュールを含むディレクトリは取得できますがその中にはまだ何もファイルが入っていません。</p>

<pre><code>$ git clone git://github.com/schacon/myproject.git
Initialized empty Git repository in /opt/myproject/.git/
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (6/6), done.
$ cd myproject
$ ls -l
total 8
-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README
drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack
$ ls rack/
$
</code></pre>

<p><code>rack</code> ディレクトリは存在しますが、中身がからっぽです。ここで、ふたつのコマンドを実行しなければなりません。まず <code>git submodule init</code> でローカルの設定ファイルを初期化し、次に <code>git submodule update</code> でプロジェクトからのデータを取得し、親プロジェクトで指定されている適切なコミットをチェックアウトします。</p>

<pre><code>$ git submodule init
Submodule 'rack' (git://github.com/chneukirchen/rack.git) registered for path 'rack'
$ git submodule update
Initialized empty Git repository in /opt/myproject/rack/.git/
remote: Counting objects: 3181, done.
remote: Compressing objects: 100% (1534/1534), done.
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
Receiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.
Resolving deltas: 100% (1951/1951), done.
Submodule path 'rack': checked out '08d709f78b8c5b0fbeb7821e37fa53e69afcf433'
</code></pre>

<p>これで、サブディレクトリ <code>rack</code> の中身が先ほどコミットしたときとまったく同じ状態になりました。別の開発者が rack のコードを変更してコミットしたときにそれを取り込んでマージするには、もう少し付け加えます。</p>

<pre><code>$ git merge origin/master
Updating 0550271..85a3eee
Fast forward
 rack |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
[master*]$ git status
# On branch master
# Changes not staged for commit:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
#
#      modified:   rack
#
</code></pre>

<p>このマージで、サブモジュールが指すポインタの位置が変わりました。しかしサブモジュールディレクトリ内のコードは更新されていません。つまり、作業ディレクトリ内でダーティな状態になっています。</p>

<pre><code>$ git diff
diff --git a/rack b/rack
index 6c5e70b..08d709f 160000
--- a/rack
+++ b/rack
@@ -1 +1 @@
-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
</code></pre>

<p>これは、サブモジュールのポインタが指す位置と実際のサブモジュールディレクトリの中身が異なるからです。これを修正するには、ふたたび <code>git submodule update</code> を実行します。</p>

<pre><code>$ git submodule update
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 2 (delta 0)
Unpacking objects: 100% (3/3), done.
From git@github.com:schacon/rack
   08d709f..6c5e70b  master     -&gt; origin/master
Submodule path 'rack': checked out '6c5e70b984a60b3cecd395edd5b48a7575bf58e0'
</code></pre>

<p>サブモジュールの変更をプロジェクトに取り込んだときには、毎回これをしなければなりません。ちょっと奇妙ですが、これでうまく動作します。</p>

<p>よくある問題が、開発者がサブモジュール内でローカルに変更を加えたけれどそれを公開サーバーにプッシュしていないときに起こります。ポインタの指す先を非公開の状態にしたまま、それを親プロジェクトにプッシュしてしまうと、他の開発者が <code>git submodule update</code> をしたときにサブモジュールが参照するコミットを見つけられなくなります。そのコミットは最初の開発者の環境にしか存在しないからです。この状態になると、次のようなエラーとなります。</p>

<pre><code>$ git submodule update
fatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Unable to checkout '6c5e70b984a60b3cecd395edd5ba7575bf58e0' in submodule path 'rack'
</code></pre>

<p>サブモジュールを最後に更新したのがいったい誰なのかを突き止めなければなりません。</p>

<pre><code>$ git log -1 rack
commit 85a3eee996800fcfa91e2119372dd4172bf76678
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Apr 9 09:19:14 2009 -0700

    added a submodule reference I will never make public. hahahahaha!
</code></pre>

<p>犯人がわかったら、メールで彼に怒鳴りつけてやりましょう。</p>

<h3>親プロジェクト</h3>

<p>時には、大規模なプロジェクトのサブディレクトリから今自分がいるチームに応じた組み合わせを取得したくなることもあるでしょう。これは、CVS や Subversion から移行した場合によくあることでしょう。モジュールを定義したりサブディレクトリのコレクションを定義していたりといったかつてのワークフローをそのまま維持したいというような状況です。</p>

<p>Git でこれと同じことをするためのよい方法は、それぞれのサブディレクトリを別々の Git リポジトリにして、それらのサブモジュールとして含む親プロジェクトとなる Git リポジトリを作ることです。この方式の利点は、親プロジェクトのタグやブランチを活用してプロジェクト間の関係をより細やかに定義できることです。</p>

<h3>サブモジュールでの問題</h3>

<p>しかし、サブモジュールを使っているとなにかしらちょっとした問題が出てくるものです。まず、サブモジュールのディレクトリで作業をするときはいつも以上に注意深くならなければなりません。<code>git submodule update</code> を実行すると、プロジェクトの特定のバージョンをチェックアウトしますが、それはブランチの中にあるものではありません。これを、切り離された HEAD (detached HEAD) と呼びます。つまり、HEAD が何らかの参照ではなく直接特定のコミットを指している状態です。通常は、HEAD が切り離された状態で作業をしようとは思わないでしょう。手元の変更が簡単に失われてしまうからです。最初に <code>submodule update</code> し、作業用のブランチを作らずにサブモジュールディレクトリ内にコミットし、<code>git submodule update</code> を再び実行すると、親プロジェクトでコミットが何もなくても Git は手元の変更を断りなく上書きしてしまいます。技術的な意味では手元の作業は失われたわけではないのですが、それを指すブランチが存在しない以上、先ほどの作業を取り戻すのは困難です。</p>

<p>この問題を回避するには、サブモジュールのディレクトリで作業をするときに <code>git checkout -b work</code> などとしてブランチを作っておきます。次にサブモジュールを更新するときにあなたの作業は消えてしまいますが、少なくとも元に戻すためのポインタは残っています。</p>

<p>サブモジュールを含むブランチを切り替えるのは、これまた用心が必要です。新しいブランチを作成してそこにサブモジュールを追加し、サブモジュールを含まないブランチに戻ったとしましょう。そこには、サブモジュールのディレクトリが「追跡されていないディレクトリ」として残ったままになります。</p>

<pre><code>$ git checkout -b rack
Switched to a new branch "rack"
$ git submodule add git@github.com:schacon/rack.git rack
Initialized empty Git repository in /opt/myproj/rack/.git/
...
Receiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
$ git commit -am 'added rack submodule'
[rack cc49a69] added rack submodule
 2 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 .gitmodules
 create mode 160000 rack
$ git checkout master
Switched to branch "master"
$ git status
# On branch master
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be committed)
#
#      rack/
</code></pre>

<p>これをどこか別の場所に移すか、削除しなければなりません。いずれにせよ、先ほどのブランチに戻ったときには改めてクローンしなおさなければならず、ローカルでの変更やプッシュしていないブランチは失われてしまうことになります。</p>

<p>最後にもうひとつ、多くの人がハマるであろう点を指摘しておきましょう。これは、サブディレクトリからサブモジュールへ切り替えるときに起こることです。プロジェクト内で追跡しているファイルをサブモジュール内に移動したくなったとしましょう。よっぽど注意しないと、Git に怒られてしまいます。rack のファイルをプロジェクト内のサブディレクトリで管理しており、それをサブモジュールに切り替えたくなったとしましょう。サブディレクトリをいったん削除してから <code>submodule add</code> と実行すると、Git に怒鳴りつけられてしまいます。</p>

<pre><code>$ rm -Rf rack/
$ git submodule add git@github.com:schacon/rack.git rack
'rack' already exists in the index
</code></pre>

<p>まず最初に <code>rack</code> ディレクトリをアンステージしなければなりません。それからだと、サブモジュールを追加することができます。</p>

<pre><code>$ git rm -r rack
$ git submodule add git@github.com:schacon/rack.git rack
Initialized empty Git repository in /opt/testsub/rack/.git/
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
</code></pre>

<p>これをどこかのブランチで行ったとしましょう。そこから、(まだサブモジュールへの切り替えがすんでおらず実際のツリーがある状態の) 別のブランチに切り替えようとすると、このようなエラーになります。</p>

<pre><code>$ git checkout master
error: Untracked working tree file 'rack/AUTHORS' would be overwritten by merge.
</code></pre>

<p>いったん <code>rack</code> サブモジュールのディレクトリを別の場所に追い出してからでないと、サブモジュールを持たないブランチに切り替えることはできません。</p>

<pre><code>$ mv rack /tmp/
$ git checkout master
Switched to branch "master"
$ ls
README  rack
</code></pre>

<p>さて、戻ってきたら、空っぽの <code>rack</code> ディレクトリが得られました。ここで <code>git submodule update</code> を実行して再クローンするか、あるいは <code>/tmp/rack</code> ディレクトリを書き戻します。</p>

<h2>サブツリーマージ</h2>

<p>サブモジュールの仕組みに関する問題を見てきました。今度は同じ問題を解決するための別の方法を見ていきましょう。Git でマージを行うときには、何をマージしなければならないのかを Git がまず調べてそれに応じた適切なマージ手法を選択します。ふたつのブランチをマージするときに Git が使うのは、<em>再帰 (recursive)</em> 戦略です。三つ以上のブランチをマージするときには、Git は <em>たこ足 (octopus)</em> 戦略を選択します。どちらの戦略を使うかは、Git が自動的に選択します。再帰戦略は複雑な三方向のマージ (共通の先祖が複数あるなど) もこなせますが、ふたつのブランチしか処理できないからです。たこ足マージは三つ以上のブランチを扱うことができますが、難しいコンフリクトを避けるためにより慎重になります。そこで、三つ以上のブランチをマージするときのデフォルトの戦略として選ばれています。しかし、それ以外にも選べる戦略があります。そのひとつが <em>サブツリー (subtree)</em> マージで、これを使えば先ほどのサブプロジェクト問題に対応することができます。先ほどのセクションと同じような rack の取り込みを、サブツリーマージを用いて行う方法を紹介しましょう。</p>

<p>サブツリーマージの考え方は、ふたつのプロジェクトがあるときに一方のプロジェクトをもうひとつのプロジェクトのサブディレクトリに位置づけたりその逆を行ったりするというものです。サブツリーマージを指定すると、Git は一方が他方のサブツリーであることを理解して適切にマージを行います。驚くべきことです。</p>

<p>まずは Rack アプリケーションをプロジェクトに追加します。つまり、Rack プロジェクトをリモート参照として自分のプロジェクトに追加し、そのブランチにチェックアウトします。</p>

<pre><code>$ git remote add rack_remote git@github.com:schacon/rack.git
$ git fetch rack_remote
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From git@github.com:schacon/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"
</code></pre>

<p>これで Rack プロジェクトのルートが <code>rack_branch</code> ブランチに取得でき、あなたのプロジェクトが <code>master</code> ブランチにある状態になりました。まずどちらかをチェックアウトしてそれからもう一方に移ると、それぞれ別のプロジェクトルートとなっていることがわかります。</p>

<pre><code>$ ls
AUTHORS        KNOWN-ISSUES   Rakefile      contrib        lib
COPYING        README         bin           example        test
$ git checkout master
Switched to branch "master"
$ ls
README
</code></pre>

<p>Rack プロジェクトを <code>master</code> プロジェクトのサブディレクトリとして取り込みたくなったときには、<code>git read-tree</code> を使います。<code>read-tree</code> とその仲間たちについては第 9 章で詳しく説明します。現時点では、とりあえず「あるブランチのルートツリーを読み込んで、それを現在のステージングエリアと作業ディレクトリに書き込むもの」だと認識しておけばよいでしょう。まず <code>master</code> ブランチに戻り、<code>rack</code> ブランチの内容を <code>master</code> ブランチの <code>rack</code> サブディレクトリに取り込みます。</p>

<pre><code>$ git read-tree --prefix=rack/ -u rack_branch
</code></pre>

<p>これをコミットすると、Rack のファイルをすべてサブディレクトリに取り込んだようになります。そう、まるで tarball からコピーしたかのような状態です。おもしろいのは、あるブランチでの変更を簡単に別のブランチにマージできるということです。もし Rack プロジェクトが更新されたら、そのブランチに切り替えてプルするだけで本家の変更を取得できます。</p>

<pre><code>$ git checkout rack_branch
$ git pull
</code></pre>

<p>これで、変更を master ブランチにマージできるようになりました。<code>git merge -s subtree</code> を使えばうまく動作します。が、Git は歴史もともにマージしようとします。おそらくこれはお望みの動作ではないでしょう。変更をプルしてコミットメッセージを埋めるには、戦略を指定するオプション <code>-s subtree</code> のほかに <code>--squash</code> オプションと <code>--no-commit</code> オプションを使います。</p>

<pre><code>$ git checkout master
$ git merge --squash -s subtree --no-commit rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested
</code></pre>

<p>Rack プロジェクトでのすべての変更がマージされ、ローカルにコミットできる準備が整いました。この逆を行うこともできます。master ブランチの <code>rack</code> サブディレクトリで変更した内容を後で <code>rack_branch</code> ブランチにマージし、それをメンテナに投稿したり本家にプッシュしたりといったことも可能です。</p>

<p><code>rack</code> サブディレクトリの内容と <code>rack_branch</code> ブランチのコードの差分を取得する (そして、マージしなければならない内容を知る) には、通常の <code>diff</code> コマンドを使うことはできません。そのかわりに、<code>git diff-tree</code> で比較対象のブランチを指定します。</p>

<pre><code>$ git diff-tree -p rack_branch
</code></pre>

<p>あるいは、<code>rack</code> サブディレクトリの内容と前回取得したときのサーバーの <code>master</code> ブランチとを比較するには、次のようにします。</p>

<pre><code>$ git diff-tree -p rack_remote/master
</code></pre>

<h2>まとめ</h2>

<p>さまざまな高度な道具を使い、コミットやステージングエリアをより細やかに操作できる方法をまとめました。何か問題が起こったときには、いつ誰がどのコミットでそれを仕込んだのかを容易に見つけられるようになったことでしょう。また、プロジェクトの中で別のプロジェクトを使いたくなったときのための方法もいくつか紹介しました。Git を使った日々のコマンドラインでの作業の大半を、自信を持ってできるようになったことでしょう。</p>
<h1>Git のカスタマイズ</h1>

<p>ここまで本書では、Git の基本動作やその使用法について扱ってきました。また、Git をより簡単に効率よく使うためのさまざまなツールについても紹介しました。本章では、Git をよりカスタマイズするための操作方法を扱います。重要な設定項目やフックシステムについても説明します。これらを利用すれば、みなさん自身やその勤務先、所属グループのニーズにあわせた方法で Git を活用できるようになるでしょう。</p>

<h2>Git の設定</h2>

<p>第 1 章で手短にごらんいただいたように、<code>git config</code> コマンドで Git の設定をすることができます。まず最初にすることと言えば、名前とメールアドレスの設定でしょう。</p>

<pre><code>$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
</code></pre>

<p>ここでは、同じようにして設定できるより興味深い項目をいくつか身につけ、Git をカスタマイズしてみましょう。</p>

<p>Git の設定については最初の章でちらっと説明しましたが、ここでもう一度振り返っておきます。Git では、いくつかの設定ファイルを使ってデフォルト以外の挙動を定義します。まず最初に Git が見るのは <code>/etc/gitconfig</code> で、ここにはシステム上の全ユーザーの全リポジトリ向けの設定値を記述します。<code>git config</code> にオプション <code>--system</code> を指定すると、このファイルの読み書きを行います。</p>

<p>次に Git が見るのは <code>~/.gitconfig</code> で、これは各ユーザー専用のファイルです。Git でこのファイルの読み書きをするには、<code>--global</code> オプションを指定します。</p>

<p>最後に Git が設定値を探すのは、現在使用中のリポジトリの設定ファイル (<code>.git/config</code>) です。この値は、そのリポジトリだけで有効なものです。後から読んだ値がその前の値を上書きします。したがって、たとえば <code>.git/config</code> に書いた値は <code>/etc/gitconfig</code> での設定よりも優先されます。これらのファイルを手動で編集して正しい構文で値を追加することもできますが、通常は <code>git config</code> コマンドを使ったほうが簡単です。</p>

<h3>基本的なクライアントのオプション</h3>

<p>Git の設定オプションは、おおきく二種類に分類できます。クライアント側のオプションとサーバー側のオプションです。大半のオプションは、クライアント側のもの、つまり個人的な作業環境を設定するためのものとなります。大量のオプションがありますが、ここでは一般的に使われているものやワークフローに大きな影響を及ぼすものに絞っていくつかを紹介します。その他のオプションの多くは特定の場合にのみ有用なものなので、ここでは扱いません。Git で使えるすべてのオプションを知りたい場合は、次のコマンドを実行しましょう。</p>

<pre><code>$ git config --help
</code></pre>

<p>また、<code>git config</code> のマニュアルページには、利用できるすべてのオプションについて詳しい説明があります。</p>

<h4>core.editor</h4>

<p>コミットやタグのメッセージを編集するときに使うエディタは、ユーザーがデフォルトエディタとして設定したものとなります。デフォルトエディタが設定されていない場合は Vi エディタを使います。このデフォルト設定を別のものに変更するには <code>core.editor</code> を設定します。</p>

<pre><code>$ git config --global core.editor emacs
</code></pre>

<p>これで、シェルのデフォルトエディタを設定していない場合に Git が起動するエディタが Emacs に変わりました。</p>

<h4>commit.template</h4>

<p>システム上のファイルへのパスをここに設定すると、Git はそのファイルをコミット時のデフォルトメッセージとして使います。たとえば、次のようなテンプレートファイルを作って <code>$HOME/.gitmessage.txt</code> においたとしましょう。</p>

<pre><code>subject line

what happened

[ticket: X]
</code></pre>

<p><code>git commit</code> のときにエディタに表示されるデフォルトメッセージをこれにするには、<code>commit.template</code> の設定を変更します。</p>

<pre><code>$ git config --global commit.template $HOME/.gitmessage.txt
$ git commit
</code></pre>

<p>すると、コミットメッセージの雛形としてこのような内容がエディタに表示されます。</p>

<pre><code>subject line

what happened

[ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C
</code></pre>

<p>コミットメッセージについて所定の決まりがあるのなら、その決まりに従ったテンプレートをシステム上に作って Git にそれを使わせるようにするとよいでしょう。そうすれば、その決まりに従ってもらいやすくなります。</p>

<h4>core.pager</h4>

<p>core.pager は、Git が <code>log</code> や <code>diff</code> などを出力するときに使うページャを設定します。<code>more</code> などのお好みのページャを設定したり (デフォルトは <code>less</code> です)、空文字列を設定してページャを使わないようにしたりすることができます。</p>

<pre><code>$ git config --global core.pager ''
</code></pre>

<p>これを実行すると、すべてのコマンドの出力を、どんなに長くなったとしても全部 Git が出力するようになります。</p>

<h4>user.signingkey</h4>

<p>署名入りの注釈付きタグ (第 2 章で取り上げました) を作る場合は、GPG 署名用の鍵を登録しておくと便利です。鍵の ID を設定するには、このようにします。</p>

<pre><code>$ git config --global user.signingkey &lt;gpg-key-id&gt;
</code></pre>

<p>これで、<code>git tag</code> コマンドでいちいち鍵を指定しなくてもタグに署名できるようになりました。</p>

<pre><code>$ git tag -s &lt;tag-name&gt;
</code></pre>

<h4>core.excludesfile</h4>

<p>プロジェクトごとの <code>.gitignore</code> ファイルでパターンを指定すると、<code>git add</code> したときに Git がそのファイルを無視してステージしないようになります。これについては第 2 章で説明しました。しかし、これらの内容をプロジェクトの外部で管理したい場合は、そのファイルがどこにあるのかを <code>core.excludesfile</code> で設定します。ここに設定する内容はファイルのパスです。ファイルの中身は <code>.gitignore</code> と同じ形式になります。</p>

<h4>help.autocorrect</h4>

<p>このオプションが使えるのは Git 1.6.1 以降だけです。Git でコマンドを打ち間違えると、こんなふうに表示されます。</p>

<pre><code>$ git com
git: 'com' is not a git-command. See 'git --help'.

Did you mean this?
     commit
</code></pre>

<p><code>help.autocorrect</code> を 1 にしておくと、同じような場面でもし候補がひとつしかなければ自動的にそれを実行します。</p>

<h3>Git における色</h3>

<p>Git では、ターミナルへの出力に色をつけることができます。ぱっと見て、すばやくお手軽に出力内容を把握できるようになるでしょう。さまざまなオプションで、お好みに合わせて色を設定しましょう。</p>

<h4>color.ui</h4>

<p>あらかじめ指定しておけば、Git は自動的に大半の出力に色づけをします。何にどのような色をつけるかをこと細かに指定することもできますが、すべてをターミナルのデフォルト色設定にまかせるなら <code>color.ui</code> を true にします。</p>

<pre><code>$ git config --global color.ui true
</code></pre>

<p>これを設定すると、出力がターミナルに送られる場合に Git がその出力を色づけします。ほかに false という値を指定することもでき、これは出力に決して色をつけません。また always を指定すると、すべての場合に色をつけます。すべての場合とは、Git コマンドをファイルにリダイレクトしたり他のコマンドにパイプでつないだりする場合も含みます。</p>

<p><code>color.ui = always</code> を使うことは、まずないでしょう。たいていの場合は、カラーコードを含む結果をリダイレクトしたい場合は Git コマンドに <code>--color</code> フラグを渡してカラーコードの使用を強制します。ふだんは <code>color.ui = true</code> の設定で要望を満たせるでしょう。</p>

<h4><code>color.*</code></h4>

<p>どのコマンドをどのように色づけするかをより細やかに指定したい場合、コマンド単位の色づけ設定を使用します。これらの項目には <code>true</code>、<code>false</code> あるいは <code>always</code> を指定することができます。</p>

<pre><code>color.branch
color.diff
color.interactive
color.status
</code></pre>

<p>さらに、これらの項目ではサブ設定が使え、出力の一部について特定の色を使うように指定することもできます。たとえば、diff の出力でのメタ情報を青の太字で出力させたい場合は次のようにします。</p>

<pre><code>$ git config --global color.diff.meta "blue black bold"
</code></pre>

<p>色として指定できる値は normal、black、red、green、yellow、blue、magenta、cyan あるいは white のいずれかです。先ほどの例の bold のように属性を指定することもできます。bold、dim、ul、blink および reverse のいずれかを指定できます。</p>

<p><code>git config</code> のマニュアルページに、すべてのサブ設定がまとめられていますので参照ください。</p>

<h3>外部のマージツールおよび Diff ツール</h3>

<p>Git には diff の実装が組み込まれておりそれを使うことができますが、外部のツールを使うよう設定することもできます。また、コンフリクトを手動で解決するのではなくグラフィカルなコンフリクト解消ツールを使うよう設定することもできます。ここでは Perforce Visual Merge Tool (P4Merge) を使って diff の表示とマージの処理を行えるようにする例を示します。これはすばらしいグラフィカルツールで、しかもフリーだからです。</p>

<p>P4Merge はすべての主要プラットフォーム上で動作するので、実際に試してみたい人は試してみるとよいでしょう。この例では、Mac や Linux 形式のパス名を例に使います。Windows の場合は、<code>/usr/local/bin</code> のところを環境に合わせたパスに置き換えてください。</p>

<p>まず、P4Merge をここからダウンロードします。</p>

<pre><code>http://www.perforce.com/perforce/downloads/component.html
</code></pre>

<p>最初に、コマンドを実行するための外部ラッパースクリプトを用意します。この例では、Mac 用の実行パスを使います。他のシステムで使う場合は、<code>p4merge</code> のバイナリがインストールされた場所に置き換えてください。次のようなマージ用ラッパースクリプト <code>extMerge</code> を用意しました。これは、すべての引数を受け取ってバイナリをコールします。</p>

<pre><code>$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*
</code></pre>

<p>diff のラッパーは、7 つの引数が渡されていることを確認したうえでそのうちのふたつをマージスクリプトに渡します。デフォルトでは、Git は次のような引数を diff プログラムに渡します。</p>

<pre><code>path old-file old-hex old-mode new-file new-hex new-mode
</code></pre>

<p>ここで必要な引数は <code>old-file</code> と <code>new-file</code> だけなので、ラッパースクリプトではこれらを渡すようにします。</p>

<pre><code>$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge "$2" "$5"
</code></pre>

<p>また、これらのツールは実行可能にしておかなければなりません。</p>

<pre><code>$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff
</code></pre>

<p>これで、自前のマージツールや diff ツールを使えるように設定する準備が整いました。設定項目はひとつだけではありません。まず <code>merge.tool</code> でどんなツールを使うのかを Git に伝え、<code>mergetool.*.cmd</code> でそのコマンドを実行する方法を指定し、<code>mergetool.trustExitCode</code> では「そのコマンドの終了コードでマージが成功したかどうかを判断できるのか」を指定し、<code>diff.external</code> では diff の際に実行するコマンドを指定します。つまり、このような 4 つのコマンドを実行することになります。</p>

<pre><code>$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
    'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
$ git config --global mergetool.trustExitCode false
$ git config --global diff.external extDiff
</code></pre>

<p>あるいは、<code>~/.gitconfig</code> ファイルを編集してこのような行を追加します。</p>

<pre><code>[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"
  trustExitCode = false
[diff]
  external = extDiff
</code></pre>

<p>すべて設定し終えたら、</p>

<pre><code>$ git diff 32d1776b1^ 32d1776b1
</code></pre>

<p>このような diff コマンドを実行すると、結果をコマンドラインに出力するかわりに P4Merge を立ち上げ、図 7-1 のようになります。</p>

<p><img src="figures/7.1.png" title="7.1 P4Merge" alt="7.1 P4Merge" /></p>

<p>ふたつのブランチをマージしてコンフリクトが発生した場合は <code>git mergetool</code> を実行します。すると P4Merge が立ち上がり、コンフリクトの解決を GUI ツールで行えるようになります。</p>

<p>このようなラッパーを設定しておくと、あとで diff ツールやマージツールを変更したくなったときにも簡単に変更することができます。たとえば <code>extDiff</code> や <code>extMerge</code> で KDiff3 を実行させるように変更するには <code>extMerge</code> ファイルをこのように変更するだけでよいのです。</p>

<pre><code>$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*
</code></pre>

<p>これで、Git での diff の閲覧やコンフリクトの解決の際に KDiff3 が立ち上がるようになりました。</p>

<p>Git にはさまざまなマージツール用の設定が事前に準備されており、特に設定しなくても利用することができます。事前に設定が準備されているツールは kdiff3、opendiff、tkdiff、meld、xxdiff、emerge、vimdiff そして gvimdiff です。KDiff3 を diff ツールとしてではなくマージのときにだけ使いたい場合は、kdiff3 コマンドにパスが通っている状態で次のコマンドを実行します。</p>

<pre><code>$ git config --global merge.tool kdiff3
</code></pre>

<p><code>extMerge</code> や <code>extDiff</code> を準備せずにこのコマンドを実行すると、マージの解決の際には KDiff3 を立ち上げて diff の際には通常の Git の diff ツールを使うようになります。</p>

<h3>書式設定と空白文字</h3>

<p>書式設定や空白文字の問題は微妙にうっとうしいもので、とくにさまざまなプラットフォームで開発している人たちと共同作業をするときに問題になりがちです。使っているエディタが知らぬ間に空白文字を埋め込んでしまっていたり Windows で開発している人が行末にキャリッジリターンを付け加えてしまったりなどしてパッチが面倒な状態になってしまうことも多々あります。Git では、こういった問題に対処するための設定項目も用意しています。</p>

<h4>core.autocrlf</h4>

<p>自分が Windows で開発していたり、チームの中に Windows で開発している人がいたりといった場合に、改行コードの問題に巻き込まれることがありがちです。Windows ではキャリッジリターンとラインフィードでファイルの改行を表すのですが、Mac や Linux ではラインフィードだけで改行を表すという違いが原因です。ささいな違いではありますが、さまざまなプラットフォームにまたがる作業では非常に面倒なものです。</p>

<p>Git はこの問題に対処するために、コミットする際には行末の CRLF を LF に自動変換し、ファイルシステム上にチェックアウトするときには逆の変換を行うようにすることができます。この機能を使うには <code>core.autocrlf</code> を設定します。Windows で作業をするときにこれを <code>true</code> に設定すると、コードをチェックアウトするときに行末の LF を CRLF に自動変換してくれます。</p>

<pre><code>$ git config --global core.autocrlf true
</code></pre>

<p>Linux や Mac などの行末に LF を使うシステムで作業をしている場合は、Git にチェックアウト時の自動変換をされてしまうと困ります。しかし、行末が CRLF なファイルが紛れ込んでしまった場合には Git に自動修正してもらいたいものです。コミット時の CRLF から LF への変換はさせたいけれどもそれ以外の自動変換が不要な場合は、<code>core.autocrlf</code> を input に設定します。</p>

<pre><code>$ git config --global core.autocrlf input
</code></pre>

<p>この設定は、Windows にチェックアウトしたときの CRLF への変換は行いますが、Mac や Linux へのチェックアウト時は LF のままにします。またリポジトリにコミットする際には LF への変換を行います。</p>

<p>Windows のみのプロジェクトで作業をしているのなら、この機能を無効にしてキャリッジリターンをそのままリポジトリに記録してもよいでしょう。その場合は、値 <code>false</code> を設定します。</p>

<pre><code>$ git config --global core.autocrlf false
</code></pre>

<h4>core.whitespace</h4>

<p>Git には、空白文字に関する問題を見つけて修正するための設定もあります。空白文字に関する主要な四つの問題に対応するもので、そのうち二つはデフォルトで有効になっています。残りの二つはデフォルトでは有効になっていませんが、有効化することができます。</p>

<p>デフォルトで有効になっている設定は、行末の空白文字を見つける <code>trailing-space</code> と行頭のタブ文字より前にある空白文字を見つける <code>space-before-tab</code> です。</p>

<p>デフォルトでは無効だけれども有効にすることもできる設定は、行頭にある八文字以上の空白文字を見つける <code>indent-with-non-tab</code> と行末のキャリッジリターンを許容する <code>cr-at-eol</code> です。</p>

<p>これらのオン・オフを切り替えるには、<code>core.whitespace</code> にカンマ区切りで項目を指定します。無効にしたい場合は、設定文字列でその項目を省略するか、あるいは項目名の前に <code>-</code> をつけます。たとえば <code>cr-at-eol</code> 以外のすべてを設定したい場合は、このようにします。</p>

<pre><code>$ git config --global core.whitespace \
    trailing-space,space-before-tab,indent-with-non-tab
</code></pre>

<p><code>git diff</code> コマンドを実行したときに Git がこれらの問題を検出すると、その部分を色付けして表示します。修正してからコミットするようにしましょう。この設定は、<code>git apply</code> でパッチを適用する際にも助けとなります。空白に関する問題を含むパッチを適用するときに警告を発してほしい場合には、次のようにします。</p>

<pre><code>$ git apply --whitespace=warn &lt;patch&gt;
</code></pre>

<p>あるいは、問題を自動的に修正してからパッチを適用したい場合は、次のようにします。</p>

<pre><code>$ git apply --whitespace=fix &lt;patch&gt;
</code></pre>

<p>これらの設定は、<code>git rebase</code>コマンドにも適用されます。空白に関する問題を含むコミットをしたけれどまだそれを公開リポジトリにプッシュしていない場合は、<code>rebase</code> に <code>--whitespace=fix</code> オプションをつけて実行すれば、パッチを書き換えて空白問題を自動修正してくれます。</p>

<h3>サーバーの設定</h3>

<p>Git のサーバー側の設定オプションはそれほど多くありませんが、いくつか興味深いものがあるので紹介します。</p>

<h4>receive.fsckObjects</h4>

<p>デフォルトでは、Git はプッシュで受け取ったオブジェクトの一貫性をチェックしません。各オブジェクトの SHA-1 チェックサムが一致していて有効なオブジェクトを指しているということを Git にチェックさせることもできますが、デフォルトでは毎回のプッシュ時のチェックは行わないようになっています。このチェックは比較的重たい処理であり、リポジトリのサイズが大きかったりプッシュする量が多かったりすると、毎回チェックさせるのには時間がかかるでしょう。毎回のプッシュの際に Git にオブジェクトの一貫性をチェックさせたい場合は、<code>receive.fsckObjects</code> を true にして強制的にチェックさせるようにします。</p>

<pre><code>$ git config --system receive.fsckObjects true
</code></pre>

<p>これで、Git がリポジトリの整合性を確認してからでないとプッシュが認められないようになります。壊れたデータをまちがって受け入れてしまうことがなくなりました。</p>

<h4>receive.denyNonFastForwards</h4>

<p>すでにプッシュしたコミットをリベースしてもう一度プッシュした場合、あるいはリモートブランチが現在指しているコミットを含まないコミットをプッシュしようとした場合は、プッシュが拒否されます。これは悪くない方針でしょう。しかしリベースの場合は、自分が何をしているのかをきちんと把握していれば、プッシュの際に <code>-f</code> フラグを指定して強制的にリモートブランチを更新することができます。</p>

<p>このような強制更新機能を無効にするには、<code>receive.denyNonFastForwards</code> を設定します。</p>

<pre><code>$ git config --system receive.denyNonFastForwards true
</code></pre>

<p>もうひとつの方法として、サーバー側の receive フックを使うこともできます。こちらの方法については後ほど簡単に説明します。receive フックを使えば、特定のユーザーだけ強制更新を無効にするなどより細やかな制御ができるようになります。</p>

<h4>receive.denyDeletes</h4>

<p><code>denyNonFastForwards</code> の制限を回避する方法として、いったんブランチを削除してから新しいコミットを参照するブランチをプッシュしなおすことができます。その対策として、新しいバージョン (バージョン 1.6.1 以降) の Git では <code>receive.denyDeletes</code> を true に設定することができます。</p>

<pre><code>$ git config --system receive.denyDeletes true
</code></pre>

<p>これは、プッシュによるブランチやタグの削除を一切拒否し、誰も削除できないようにします。リモートブランチを削除するには、サーバー上の ref ファイルを手で削除しなければなりません。ACL を使って、ユーザー単位でこれを制限することもできますが、その方法は本章の最後で扱います。</p>

<h2>Git の属性</h2>

<p>設定項目の中には、パスにも指定できるものがあります。Git はその設定を、指定したパスのサブディレクトリやファイルにのみ適用するのです。これらのパス固有の設定は Git の属性と呼ばれ、あるディレクトリ (通常はプロジェクトのルートディレクトリ) の直下の <code>.gitattributes</code> か、あるいはそのファイルをプロジェクトとともにコミットしたくない場合は <code>.git/info/attributes</code> に設定します。</p>

<p>属性を使うと、ファイルやディレクトリ単位で個別のマージ戦略を指定したりテキストファイル以外での diff の取得方法を指示したり、あるいはチェックインやチェックアウトの前に Git にフィルタリングさせたりすることができます。このセクションでは、Git プロジェクトでパスに設定できる属性のいくつかについて学び、実際にその機能を使う例を見ていきます。</p>

<h3>バイナリファイル</h3>

<p>Git の属性を使ってできるちょっとした技として、どのファイルがバイナリファイルなのかを (その他の方法で判別できない場合のために) 指定して Git に対してバイナリファイルの扱い方を指示するというものがあります。たとえば、機械で生成したテキストファイルの中には diff が取得できないものがありますし、バイナリファイルであっても diff が取得できるものもあります。それを Git に指示する方法を紹介します。</p>

<h4>バイナリファイルの特定</h4>

<p>テキストファイルのように見えるファイルであっても、何らかの目的のために意図的にバイナリデータとして扱いたいこともあります。たとえば、Mac の Xcode プロジェクトの中には <code>.pbxproj</code> で終わる名前のファイルがあります。これは JSON (プレーンテキスト形式の javascript のデータフォーマット) のデータセットで、IDE がビルド設定などをディスクに書き出したものです。すべて ASCII で構成されるので、理論上はこれはテキストファイルです。しかしこのファイルをテキストファイルとして扱いたくはありません。実際のところ、このファイルは軽量なデータベースとして使われているからです。他の人が変更した内容をマージすることはできませんし、diff をとってもあまり意味がありません。このファイルは、基本的に機械が処理するものなのです。要するに、バイナリファイルと同じように扱いたいということです。</p>

<p>すべての <code>pbxproj</code> ファイルをバイナリデータとして扱うよう Git に指定するには、次の行を <code>.gitattributes</code> ファイルに追加します。</p>

<pre><code>*.pbxproj -crlf -diff
</code></pre>

<p>これで、Git が CRLF 問題の対応をすることもなくなりますし、<code>git show</code> や <code>git diff</code> を実行したときにもこのファイルの diff を調べることはなくなります。また､次のようなマクロ<code>binary</code>を使うこともできます。これは <code>-crlf -diff</code> と同じ意味です。</p>

<pre><code>*.pbxproj binary
</code></pre>

<h4>バイナリファイルの差分</h4>

<p>Gitでは、バイナリファイルの差分を効果的に扱うためにGitの属性機能を使うことができます。通常のdiff機能を使って比較を行うことができるように、バイナリデータをテキストデータに変換する方法をGitに教えればいいのです。ただし問題があります。<em>バイナリ</em>データをどうやってテキストに変換するか？ということです。この場合、一番いい方法はバイナリファイル形式ごとに専用の変換ツールを使うことです。とはいえ、判読可能なテキストに変換可能なバイナリファイル形式はそう多くありません(音声データをテキスト形式に変換？うまくいかなさそうです...)。ただ、仮にそういった事例に出くわしデータをテキスト形式にできなかったとしても、ファイルの内容についての説明、もしくはメタデータを取得することはそれほど難しくないでしょう。もちろん、そのファイルについての全てがメタデータから読み取れるわけではありませんが、何もないよりはよっぽどよいはずです。</p>

<p>これから、上述の2手法を用い、よく使われてるバイナリファイル形式から有用な差分を取得する方法を説明します。</p>

<p>補足： バイナリファイル形式で、かつデータがテキストで記述されているけれど、テキスト形式に変換するためのツールがないケースがよくあります。そういった場合、<code>strings</code> プログラムを使ってそのファイルからテキストを抽出できるかどうか、試してみるとよいでしょう。UTF-16 などのエンコーディングで記述されている場合だと、<code>strings</code> プログラムではうまくいかないかもしれません。どこまで変換できるかはケースバイケースでしょう。とはいえ、<code>strings</code> プログラムは 大半の Mac と Linux で使えるので、バイナリファイル形式を取り扱う最初の一手としては十分でしょう。</p>

<h5>MS Word ファイル</h5>

<p>あなたはまずこれらのテクニックを使って、人類にとって最も厄介な問題のひとつ、Wordで作成した文書のバージョン管理を解決したいと思うでしょう。奇妙なことに、Wordは最悪のエディタだと全ての人が知っているにも係わらず、皆がWordを使っています。Word文書をバージョン管理したいと思ったなら、Gitのリポジトリにそれらを追加して、まとめてコミットすればいいのです。しかし、それでいいのでしょうか？ あなたが <code>git diff</code> をいつも通りに実行すると、次のように表示されるだけです。</p>

<pre><code>$ git diff
diff --git a/chapter1.doc b/chapter1.doc
index 88839c4..4afcb7c 100644
Binary files a/chapter1.doc and b/chapter1.doc differ
</code></pre>

<p>これでは2つのバージョンをcheckoutしてそれらを自分で見比べてみない限り、比較することは出来ませんよね？ Gitの属性を使えば、うまく解決できます。<code>.gitattributes</code>に次の行を追加して下さい。</p>

<pre><code>*.doc diff=word
</code></pre>

<p>これは、指定したパターン(.doc)にマッチした全てのファイルに対して、差分を表示する時には"word"というフィルタを使うべきであるとGitに教えているのです。"word"フィルタとは何でしょうか？ それはあなたが用意しなければなりません。Word文書をテキストファイルに変換するプログラムとして <code>catdoc</code> を使うように次のようにGitを設定してみましょう。なお、<code>catdoc</code> とは、差分を正しく表示するために、Word文書からテキストを取り出す専用のツール( <code>http://www.wagner.pp.ru/~vitus/software/catdoc/</code> からダウンロードできます。)です。</p>

<pre><code>$ git config diff.word.textconv catdoc
</code></pre>

<p>このコマンドは、<code>.git/config</code> に次のようなセクションを追加します。</p>

<pre><code>[diff "word"]
    textconv = catdoc
</code></pre>

<p>これで、<code>.doc</code> という拡張子をもったファイルはそれぞれのファイルに <code>catdoc</code> というプログラムとして定義された"word"フィルタを通してからdiffを取るべきだということをGitは知っていることになります。こうすることで、Wordファイルに対して直接差分を取るのではなく、より効果的なテキストベースでの差分を取ることができるようになります。</p>

<p>例を示しましょう。この本の第1章をGitリポジトリに登録した後、ある段落にいくつかの文章を追加して保存し、それから、変更箇所を確認するために<code>git diff</code>を実行しました。</p>

<pre><code>$ git diff
diff --git a/chapter1.doc b/chapter1.doc
index c1c8a0a..b93c9e4 100644
--- a/chapter1.doc
+++ b/chapter1.doc
@@ -128,7 +128,7 @@ and data size)
 Since its birth in 2005, Git has evolved and matured to be easy to use
 and yet retain these initial qualities. It’s incredibly fast, it’s
 very efficient with large projects, and it has an incredible branching
-system for non-linear development.
+system for non-linear development (See Chapter 3).
</code></pre>

<p>Gitは、追加した"(See Chapter 3)"という文字列を首尾よく、かつ、簡潔に知らせてくれました。正確で、申し分のない動作です！</p>

<h5>OpenDocument Text ファイル</h5>

<p>MS Word ファイル (<code>*.doc</code>) と同じ考えかたで、OpenOffice.org の OpenDocument Text ファイル (<code>*.odt</code>) も扱えます。</p>

<p>次の行を <code>.gitattributes</code> ファイルに追加しましょう。</p>

<pre><code>*.odt diff=odt
</code></pre>

<p>そして、<code>odt</code> diff フィルタを <code>.git/config</code> に追加します。</p>

<pre><code>[diff "odt"]
    binary = true
    textconv = /usr/local/bin/odt-to-txt
</code></pre>

<p>OpenDocument ファイルの正体は zip で、複数のファイル (XML 形式のコンテンツやスタイルシート、画像など) を含むディレクトリをまとめたものです。このコンテンツを展開し、プレーンテキストとして返すスクリプトが必要です。<code>/usr/local/bin/odt-to-txt</code> というファイルを作って (ディレクトリはどこでもかまいません)、次のような内容を書きましょう。</p>

<pre><code>#! /usr/bin/env perl
# Simplistic OpenDocument Text (.odt) to plain text converter.
# Author: Philipp Kempgen

if (! defined($ARGV[0])) {
    print STDERR "No filename given!\n";
    print STDERR "Usage: $0 filename\n";
    exit 1;
}

my $content = '';
open my $fh, '-|', 'unzip', '-qq', '-p', $ARGV[0], 'content.xml' or die $!;
{
    local $/ = undef;  # slurp mode
    $content = &lt;$fh&gt;;
}
close $fh;
$_ = $content;
s/&lt;text:span\b[^&gt;]*&gt;//g;           # remove spans
s/&lt;text:h\b[^&gt;]*&gt;/\n\n*****  /g;   # headers
s/&lt;text:list-item\b[^&gt;]*&gt;\s*&lt;text:p\b[^&gt;]*&gt;/\n    --  /g;  # list items
s/&lt;text:list\b[^&gt;]*&gt;/\n\n/g;       # lists
s/&lt;text:p\b[^&gt;]*&gt;/\n  /g;          # paragraphs
s/&lt;[^&gt;]+&gt;//g;                      # remove all XML tags
s/\n{2,}/\n\n/g;                   # remove multiple blank lines
s/\A\n+//;                         # remove leading blank lines
print "\n", $_, "\n\n";
</code></pre>

<p>そして実行権限をつけます。</p>

<pre><code>chmod +x /usr/local/bin/odt-to-txt
</code></pre>

<p>これで、<code>git diff</code> で <code>.odt</code> ファイルの変更点を確認できるようになりました。</p>

<h5>画像ファイル</h5>

<p>その他の興味深い問題としては画像ファイルの差分があります。PNGファイルに対するひとつの方法としては、EXIF情報(多くのファイルでメタデータとして使われています)を抽出するフィルタを使う方法です。<code>exiftool</code>をダウンロードしインストールすれば、画像データをメタデータの形でテキストデータとして扱うことができます。従って、次のように設定すれば、画像データの差分をメタデータの差分という形で表示することができます。</p>

<pre><code>$ echo '*.png diff=exif' &gt;&gt; .gitattributes
$ git config diff.exif.textconv exiftool
</code></pre>

<p>上記の設定をしてからプロジェクトで画像データを置き換えて<code>git diff</code>と実行すれば、次のように表示されることになるでしょう。</p>

<pre><code>diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:17 10:12:35-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha
</code></pre>

<p>ファイルのサイズと画像のサイズが変更されたことが簡単に見て取れるでしょう。</p>

<h3>キーワード展開</h3>

<p>SubversionやCVSを使っていた開発者から、キーワード展開機能をリクエストされることがよくあります。これについてGitにおける主な問題は、Gitはまずファイルのチェックサムを生成するためにcommitした後にファイルに関する情報を変更できないという点です。しかし、commitするためにaddする前にファイルをcheckoutしremoveするという手順を踏めば、その時にファイルにテキストを追加することが可能です。Gitの属性はそうするための方法を2つ提供します。</p>

<p>ひとつめの方法として、ファイルの<code>$Id$</code>フィールドを自動的にblobのSHA-1 checksumを挿入するようにできます。あるファイル、もしくはいくつかのファイルに対してこの属性を設定すれば、次にcheckoutする時、Gitはこの置き換えを行うようになるでしょう。ただし、挿入されるチェックサムはcommitに対するものではなく、対象となるblobものであるという点に注意して下さい。</p>

<pre><code>$ echo '*.txt ident' &gt;&gt; .gitattributes
$ echo '$Id$' &gt; test.txt
</code></pre>

<p>次にtest.txtをcheckoutする時、GitはSHA-1チェックサムを挿入します。</p>

<pre><code>$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $
</code></pre>

<p>しかし、このやりかたには制限があります。CVSやSubversionのキーワード展開ではタイムスタンプを含めることができます。対して、SHA-1チェックサムは完全にランダムな値ですから、2つの値の新旧を知るための助けにはなりません。</p>

<p>これには、commit/checkout時にキーワード展開を行うためのフィルタを書いてやることで対応できます。このために"clean"と"smudge"フィルタがあります。特定のファイルに対して使用するフィルタを設定し、checkoutされる前("smudge" 図7-2参照)もしくはcommitされる前("clean" 図7-3参照)に指定したスクリプトが実行させるよう、<code>.gitattributes</code>ファイルで設定できます。これらのフィルタはあらゆる種類の面白い内容を実行するように設定できます。</p>

<p><img src="figures/7.2.png" title="7.2 checkoutする時に&quot;smudge&quot;フィルタを実行する" alt="7.2 checkoutする時に&quot;smudge&quot;フィルタを実行する" /></p>

<p><img src="figures/7.3.png" title="7.3 ステージする時に&quot;clean&quot;フィルタを実行する。" alt="7.3 ステージする時に&quot;clean&quot;フィルタを実行する。" /></p>

<p>この機能に対してオリジナルのcommitメッセージは簡単な例を与えてくれています。それはcommit前にあなたのCのソースコードを<code>indent</code>プログラムに通すというものです。<code>*.c</code>ファイルに対して"indent"フィルタを実行するように、<code>.gitattributes</code>ファイルにfilter属性を設定することができます。</p>

<pre><code>*.c     filter=indent
</code></pre>

<p>それから、smudgeとcleanで"indent"フィルタが何を行えばいいのかをGitに教えます。</p>

<pre><code>$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat
</code></pre>

<p>このケースでは、<code>*.c</code>にマッチするファイルをcommitした時、Gitはcommit前にindentプログラムにファイルを通し、checkoutする前には<code>cat</code>を通すようにします。<code>cat</code>は基本的に何もしません。入力されたデータと同じデータを吐き出すだけです。この組み合わせでCのソースコードに対してcommit前に<code>indent</code>を通すことが効果的に行えます。</p>

<p>RCSスタイルの<code>$Date$</code>キーワード展開もまた別の興味深い例です。満足のいく形でこれを行うには、ファイル名を受け取って、プロジェクトの最新のcommitの日付を見付けだし、その日付をファイルに挿入するちょっとしたスクリプトが必要になります。そのようなRubyスクリプトが以下です。</p>

<pre><code>#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')
</code></pre>

<p>このスクリプトは、<code>git log</code>コマンドの出力から最新のcommitの日付を取得し、標準入力からの入力中のすべての<code>$Date$</code>文字列にその日付を追加し、結果を表示します。あなたのお気に入りのどのような言語でスクリプトを書くにしても、簡潔にすべきです。このスクリプトファイルに<code>expand_date</code>と名前をつけ、実行パスのどこかに置きます。次に、Gitが使うフィルタ(<code>dater</code>と呼びましょうか)を設定し、checkout時に<code>expand_date</code>が実行されるようにGitに教えてあげましょう。</p>

<pre><code>$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'
</code></pre>

<p>このPerlのスクリプトは、開始点に戻るために<code>$Date$</code>文字列内の他の文字列を削除します。さあ、フィルタの準備ができました。ファイルに<code>$Date$</code>キーワードを追加して新しいフィルタに仕事をさせるためにGitの属性を設定して、テストしてみましょう。</p>

<pre><code>$ echo '# $Date$' &gt; date_test.txt
$ echo 'date*.txt filter=dater' &gt;&gt; .gitattributes
</code></pre>

<p>これらの変更をcommitして再度ファイルをcheckoutすれば、キーワード展開が正しく行われているのがわかります。</p>

<pre><code>$ git add date_test.txt .gitattributes
$ git commit -m "Testing date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$
</code></pre>

<p>アプリケーションをカスタマイズするためのこのテクニックがどれほど強力か、おわかりいただけたと思います。しかし、注意が必要です。<code>.gitattributes</code>ファイルはcommitされ、プロジェクト内で共有されますが、ドライバ(このケースで言えば、<code>dater</code>)はそうはいきません。そう、すべての環境で動くとは限らないのです。あなたがこうしたフィルタをデザインする時、たとえフィルタが正常に動作しなかったとしても、プロジェクトは適切に動き続けられるようにすべきです。</p>

<h3>リポジトリをエクスポートする</h3>

<p>あなたのプロジェクトのアーカイブをエクスポートする時には、Gitの属性データを使って興味深いことを行うことができます。</p>

<h4>export-ignore</h4>

<p>アーカイヴを生成するとき、あるファイルやディレクトリをエクスポートしないように設定することができます。プロジェクトにはcheckinしたいがアーカイブファイルには含めたくないディレクトリやファイルがあるなら、それらに<code>export-ignore</code>を設定してやることができます。</p>

<p>例えば、<code>test/</code>ディレクトリ以下にいくつかのテストファイルがあって、それらをプロジェクトのtarballには含めたくないとしましょう。その場合、次の1行をGitの属性ファイルに追加します。</p>

<pre><code>test/ export-ignore
</code></pre>

<p>これで、プロジェクトのtarballを作成するために<code>git archive</code>を実行した時、アーカイブには<code>test/</code>ディレクトリが含まれないようになります。</p>

<h4>export-subst</h4>

<p>アーカイブ作成時にできる別のこととして、いくつかの簡単なキーワード展開があります。第2章で紹介した<code>--pretty=format</code>で指定できるフォーマット指定子とともに<code>$Format:$</code>文字列をファイルに追加することができます。例えば、<code>LAST_COMMIT</code>という名前のファイルをプロジェクトに追加し、<code>git archive</code>を実行した時にそれを最新のcommitの日付に変換したい場合、次のように設定します。</p>

<pre><code>$ echo 'Last commit date: $Format:%cd$' &gt; LAST_COMMIT
$ echo "LAST_COMMIT export-subst" &gt;&gt; .gitattributes
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'
</code></pre>

<p><code>git archive</code>を実行したあと、アーカイブを展開すると、<code>LAST_COMMIT</code>は以下のような内容になっているでしょう。</p>

<pre><code>$ cat LAST_COMMIT
Last commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$
</code></pre>

<h3>マージの戦略</h3>

<p>Git属性を使えば、プロジェクトにある指定したファイルに対して異なるマージ戦略を使うようにすることができます。とても有効なオプションのひとつは、指定したファイルで競合が発生した場合に、マージを行わずにあなたの変更内容で他の誰かの変更を上書きするように設定するというものです。</p>

<p>これはブランチを分岐させ特別な作業をしている時、そのブランチでの変更をマージさせたいが、いくつかのファイルの変更はなかったことにしたいというような時に助けになります。例えば、database.xmlというデータベースの設定ファイルがあり、ふたつのブランチでその内容が異なっているとしましょう。そして、そのデータベースファイルを台無しすることなしに、一方のブランチへとマージしたいとします。これは、次のように属性を設定すれば実現できます。</p>

<pre><code>database.xml merge=ours
</code></pre>

<p>マージを実行すると、database.xmlに関する競合は発生せず、次のような結果になります。</p>

<pre><code>$ git merge topic
Auto-merging database.xml
Merge made by recursive.
</code></pre>

<p>この場合、database.xmlは元々のバージョンのまま、書き変わりません。</p>

<h2>Git フック</h2>

<p>他のバージョンコントロールシステムと同じように、Gitにも特定のアクションが発生した時にスクリプトを叩く方法があります。フックはクライアントサイドとサーバーサイドの二つのグループに分けられます。クライアントサイドフックはコミットやマージといったクライアントでの操作用に、サーバーサイドフックはプッシュされたコミットを受け取るといったサーバーでの操作用に利用されます。これらのフックをさまざまなな理由に用いることができます。ここではそのうちのいくつかをご紹介しましょう。</p>

<h3>フックをインストールする</h3>

<p>フックはGitディレクトリの<code>hooks</code>サブディレクトリに格納されています。一般的なプロジェクトでは、<code>.git/hooks</code>がそれにあたります。Gitはデフォルトでこのディレクトリに例となるスクリプトを生成します。それらの多くはそのままでも十分有用ですし、引数も記載されています。全ての例は基本的にシェルスクリプトで書かれています。いくつかPerlを含むものもありますが、適切に命名されたそれらの実行可能スクリプトはうまく動きます。RubyやPython等で自作していただいてもかまいません｡それらのフックファイルの末尾は.sampleとなっていますので適時リネームしてください。</p>

<p>フックスクリプトを有効にするには、Gitディレクトリの<code>hooks</code>サブディレクトリに適切な名前の実行可能なファイルを配置する必要があります。これによってファイルが呼び出されることになります。ここでは重要なフックファイル名をいくつか取り上げます。</p>

<h3>クライアントサイドフック</h3>

<p>クライアントサイドフックにはたくさんの種類があります。ここではコミットワークフローフック、Eメールワークフロースクリプト、その他クライアントサイドフックに分類します。</p>

<h4>コミットワークフローフック</h4>

<p>最初の4つのフックはコミットプロセスに関するものです。<code>pre-commit</code>フックはコミットメッセージが入力される前に実行されます。これはいまからコミットされるであろうスナップショットを検査したり、何かし忘れた事を確認したり、事前にテストを実行したり、何かしらコードを検査する目的で使用されます。<code>git commit --no-verify</code>で回避することもできますが、このフックから0でない値が返るとコミットが中断されます。コーディングスタイルの検査（lintを実行する等）や、行末の空白文字の検査（デフォルトのフックがまさにそうです）、新しく追加されたメソッドのドキュメントが正しいかどうかの検査といったことが可能です。</p>

<p><code>prepare-commit-msg</code>フックは、コミットメッセージエディターが起動する直前、デフォルトメッセージが生成された直後に実行されます。コミットの作者がそれを目にする前にデフォルトメッセージを編集することができます。このフックはオプションを必要とします: 現在までのコミットメッセージを保存したファイルへのパス、コミットのタイプ、さらにamendされたコミットの場合はコミットSHA-1が必要です。このフックは普段のコミットにおいてあまり有用ではありませんが、テンプレートのコミットメッセージ・mergeコミット・squashコミット・amendコミットのようなデフォルトメッセージが自動で挿入されるコミットにおいて効果を発揮します。テンプレートのコミットメッセージと組み合わせて、動的な情報をプログラムで挿入することができます。</p>

<p><code>commit-msg</code>フックも、現在のコミットメッセージを保存した一時ファイルへのパスをパラメータに持つ必要があります。このスクリプトが0以外の値を返した場合Gitはコミットプロセスを中断しますので、プロジェクトの状態や許可待ちになっているコミットメッセージを有効にすることができます 。この章の最後のセクションでは、このフックを使用してコミットメッセージが要求された様式に沿っているか検査するデモンストレーションを行います。</p>

<p>コミットプロセスが全て完了した後に、<code>post-commit</code>フックが実行されます。パラメータは必要無く、<code>git log -1 HEAD</code>を実行することで直前のコミットを簡単に取り出すことができます。一般的にこのスクリプトは何かしらの通知といった目的に使用されます。</p>

<p>コミットワークフロークライアントサイドスクリプトはあらゆるワークフローに使用することができます。clone中にスクリプトが転送される事はありませんが、これらはしばしばサーバー側で決められたポリシーを強制する目的で使用されます。これらのスクリプトは開発者を支援するために存在するのですから、いつでもオーバーライドされたり変更されたりすることがありえるとしても開発者らによってセットアップされ、メンテナンスされてしかるべきです。</p>

<h4>Eメールワークフローフック</h4>

<p>Eメールを使ったワークフロー用として、三種類のクライアントサイドフックを設定することができます。これらはすべて <code>git am</code> コマンドに対して起動されるものなので、ふだんの作業でこのコマンドを使っていない場合は次のセクションを読み飛ばしてもかまいません。<code>git format-patch</code> で作ったパッチを受け取ることがある場合は、ここで説明する内容が有用になるかもしれません。</p>

<p>まず最初に実行されるフックは <code>applypatch-msg</code> です。これは引数をひとつだけ受け取ります。コミットメッセージを含む一時ファイル名です。このスクリプトがゼロ以外の値で終了した場合、Git はパッチの処理を強制終了させます。このフックを使うと、コミットメッセージの書式が正しいかどうかを確認したり、スクリプトで正しい書式に手直ししたりすることができます。</p>

<p><code>git am</code> でパッチを適用するときに二番目に実行されるフックは <code>pre-applypatch</code> です。これは引数を受け取らず、パッチが適用された後に実行されます。このフックを使うと、パッチ適用後の状態をコミットする前に調べることができます。つまり、このスクリプトでテストを実行したり、その他の調査をしたりといったことができるということです。なにか抜けがあったりテストが失敗したりした場合はスクリプトをゼロ以外の値で終了させます。そうすれば、<code>git am</code> はパッチをコミットせずに強制終了します。</p>

<p><code>git am</code> において最後に実行されるフックは <code>post-applypatch</code> です。これを使うと、グループのメンバーやそのパッチの作者に対して処理の完了を伝えることができます。このスクリプトでは、パッチの適用を中断させることはできません。</p>

<h4>その他のクライアントフック</h4>

<p><code>pre-rebase</code> フックは何かをリベースする前に実行され、ゼロ以外を返すとその処理を中断させることができます。このフックを使うと、既にプッシュ済みのコミットのリベースを却下することができます。Gitに含まれているサンプルの <code>pre-rebase</code> フックがちょうどこの働きをします。ただしこのサンプルは、公開ブランチの名前が next であることを想定したものです。実際に使っている安定版公開ブランチの名前に変更する必要があるでしょう。</p>

<p><code>git checkout</code> が正常に終了すると、<code>post-checkout</code> フックが実行されます。これを使うと、作業ディレクトリを自分のプロジェクトの環境にあわせて設定することができます。たとえば、バージョン管理対象外の巨大なバイナリファイルや自動生成ドキュメントなどを作業ディレクトリに取り込むといった処理です。</p>

<p>最後に説明する <code>post-merge</code> フックは、<code>merge</code> コマンドが正常に終了したときに実行されます。これを使うと、Git では追跡できないパーミッション情報などを作業ツリーに復元することができます。作業ツリーに変更が加わったときに取り込みたい Git の管理対象外のファイルの存在確認などにも使えます。</p>

<h3>サーバーサイドフック</h3>

<p>クライアントサイドフックの他に、いくつかのサーバーサイドフックを使うこともできます。これは、システム管理者がプロジェクトのポリシーを強制させるために使うものです。これらのスクリプトは、サーバへのプッシュの前後に実行されます。pre フックをゼロ以外の値で終了させると、プッシュを却下してエラーメッセージをクライアントに返すことができます。つまり、プッシュに関するポリシーをここで設定することができるということです。</p>

<h4>pre-receive および post-receive</h4>

<p>クライアントからのプッシュを処理するときに最初に実行されるスクリプトが <code>pre-receive</code> です。このスクリプトは、プッシュされた参照のリストを標準入力から受け取ります。ゼロ以外の値で終了させると、これらはすべて却下されます。このフックを使うと、更新内容がすべてfast-forwardであることをチェックしたり、プッシュしてきたユーザーがそれらのファイルに対する適切なアクセス権を持っているかを調べたりといったことができます。</p>

<p><code>post-receive</code> フックは処理が終了した後で実行されるもので、他のサービスの更新やユーザーへの通知などに使えます。<code>pre-receive</code> フックと同様、データを標準入力から受け取ります。サンプルのスクリプトには、メーリングリストへの投稿や継続的インテグレーションサーバーへの通知、チケット追跡システムの更新などの処理が含まれています。コミットメッセージを解析して、チケットのオープン・修正・クローズなどの必要性を調べることだってできます。このスクリプトではプッシュの処理を中断させることはできませんが、クライアント側ではこのスクリプトが終了するまで接続を切断することができません。このスクリプトで時間のかかる処理をさせるときには十分注意しましょう。</p>

<h4>update</h4>

<p>update スクリプトは <code>pre-receive</code> スクリプトと似ていますが、プッシュしてきた人が更新しようとしているブランチごとに実行されるという点が異なります。複数のブランチへのプッシュがあったときに <code>pre-receive</code> が実行されるのは一度だけですが、update はブランチ単位でそれぞれ一度ずつ実行されます。このスクリプトは、標準入力を読み込むのではなく三つの引数を受け取ります。参照 (ブランチ) の名前、プッシュ前を指す参照の SHA-1、そしてプッシュしようとしている参照の SHA-1 です。update スクリプトをゼロ以外で終了させると、その参照のみが却下されます。それ以外の参照はそのまま更新を続行します。</p>

<h2>Git ポリシーの実施例</h2>

<p>このセクションでは、これまでに学んだ内容を使って実際に Git のワークフローを確立してみます。コミットメッセージの書式をチェックし、プッシュは fast-forward 限定にし、そしてプロジェクト内の各サブディレクトリに対して特定のユーザーだけが変更を加えられるようにするというものです。開発者に対して「なぜプッシュが却下されたのか」を伝えるためのクライアントスクリプト、そして実際にそのポリシーを実施するためのサーバースクリプトを作成します。</p>

<p>スクリプトは Ruby を使って書きます。その理由のひとつは私が Ruby を好きなこと、そしてもうひとつの理由はその他のスクリプト言語の疑似コードとしてもそれっぽく見えるであろうということです。Ruby 使いじゃなくても、きっとコードの大まかな流れは追えるはずです。しかし、Ruby 以外の言語であってもきちんと動作します。Git に同梱されているサンプルスクリプトはすべて Perl あるいは Bash で書かれているので、それらの言語のサンプルも大量に見ることができます。</p>

<h3>サーバーサイドフック</h3>

<p>サーバーサイドの作業は、すべて hooks ディレクトリの update ファイルにまとめます。update ファイルはプッシュされるブランチごとに実行されるもので、プッシュされる参照と操作前のブランチのリビジョン、そしてプッシュされる新しいリビジョンを受け取ります。また、SSH 経由でのプッシュの場合は、プッシュしたユーザーを知ることもできます。全員に共通のユーザー ("git" など) を使って公開鍵認証をさせている場合は、公開鍵の情報に基づいて実際のユーザーを判断して環境変数を設定するというラッパーが必要です。ここでは、接続しているユーザー名が環境変数 <code>$USER</code> に格納されているものとします。スクリプトは、まずこれらの情報を取得するところから始まります。</p>

<pre><code>#!/usr/bin/env ruby

refname = ARGV[0]
oldrev  = ARGV[1]
newrev  = ARGV[2]
user    = ENV['USER']

puts "Enforcing Policies... \n(#{refname}) (#{oldrev[0,6]}) (#{newrev[0,6]})"
</code></pre>

<h4>特定のコミットメッセージ書式の強制</h4>

<p>まずは、コミットメッセージを特定の書式に従わせることに挑戦してみましょう。ここでは、コミットメッセージには必ず "ref: 1234" 形式の文字列を含むこと、というルールにします。個々のコミットをチケットシステムとリンクさせたいという意図です。やらなければならないことは、プッシュされてきた各コミットのコミットメッセージにその文字列があるかどうかを調べ、もしなければゼロ以外の値で終了してプッシュを却下することです。</p>

<p>プッシュされたすべてのコミットの SHA-1 値を取得するには、<code>$newrev</code> と <code>$oldrev</code> の内容を <code>git rev-list</code> という低レベル Git コマンドに渡します。これは基本的には <code>git log</code> コマンドのようなものですが、デフォルトでは SHA-1 値だけを表示してそれ以外の情報は出力しません。ふたつのコミットの間のすべてのコミットの SHA を得るには、次のようなコマンドを実行します。</p>

<pre><code>$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475
</code></pre>

<p>この出力を受け取ってループさせて各コミットの SHA を取得し、個々のメッセージを取り出し、正規表現でそのメッセージを調べることができます。</p>

<p>さて、これらのコミットからコミットメッセージを取り出す方法を見つけなければなりません。生のコミットデータを取得するには、別の低レベルコマンド <code>git cat-file</code> を使います。低レベルコマンドについては第 9 章で詳しく説明しますが、とりあえずはこのコマンドがどんな結果を返すのだけを示します。</p>

<pre><code>$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number
</code></pre>

<p>SHA-1 値がわかっているときにコミットからコミットメッセージを得るシンプルな方法は、空行を探してそれ以降をすべて取得するというものです。これには、Unix システムの <code>sed</code> コマンドが使えます。</p>

<pre><code>$ git cat-file commit ca82a6 | sed '1,/^$/d'
changed the version number
</code></pre>

<p>この呪文を使ってコミットメッセージを取得し、もし条件にマッチしないものがあれば終了させればよいのです。スクリプトを抜けてプッシュを却下するには、ゼロ以外の値で終了させます。以上を踏まえると、このメソッドは次のようになります。</p>

<pre><code>$regex = /\[ref: (\d+)\]/

# enforced custom commit message format
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[POLICY] Your message is not formatted correctly"
      exit 1
    end
  end
end
check_message_format
</code></pre>

<p>これを <code>update</code> スクリプトに追加すると、ルールを守らないコミットメッセージが含まれるコミットのプッシュを却下するようになります。</p>

<h4>ユーザーベースのアクセス制御</h4>

<p>アクセス制御リスト (ACL) を使って、ユーザーごとにプロジェクトのどの部分を変更できるのかを指定できるようにしてみましょう。全体にアクセスできるユーザーもいれば、特定のサブディレクトリやファイルだけにしか変更をプッシュできないユーザーもいる、といった仕組みです。これを実施するには、ルールを書いたファイル <code>acl</code> をサーバー上のベア Git リポジトリに置きます。<code>update</code> フックにこのファイルを読ませ、プッシュされたコミットにどのファイルが含まれているのかを調べ、そしてプッシュしたユーザーがそれらのファイルを変更する権限があるのかどうかを判断します。</p>

<p>まずは ACL を作るところから始めましょう。ここでは、CVS の ACL と似た書式を使います。これは各項目を一行で表すもので、最初のフィールドは <code>avail</code> あるいは <code>unavail</code>、そして次の行がそのルールを適用するユーザーの一覧 (カンマ区切り)、そして最後のフィールドがそのルールを適用するパス (ブランクは全体へのアクセスを意味します) です。フィールドの区切りには、パイプ文字 (<code>|</code>) を使います。</p>

<p>ここでは、全体にアクセスする管理者と <code>doc</code> ディレクトリにアクセスするドキュメント担当者、そして <code>lib</code> と <code>tests</code> サブディレクトリだけにアクセスできる開発者を設定します。ACL ファイルは次のようになります。</p>

<pre><code>avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests
</code></pre>

<p>まずはこのデータを読み込んで、スクリプト内で使えるデータ構造にしてみましょう。例をシンプルにするために、ここでは <code>avail</code> ディレクティブだけを使います。次のメソッドは連想配列を返すものです。ユーザー名が配列のキー、そのユーザーが書き込み権を持つパスの配列が対応する値となります。</p>

<pre><code>def get_acl_access_data(acl_file)
  # read in ACL data
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] &lt;&lt; path
    end
  end
  access
end
</code></pre>

<p>先ほどの ACL ファイルをこの <code>get_acl_access_data</code> メソッドに渡すと、このようなデータ構造を返します。</p>

<pre><code>{"defunkt"=&gt;[nil],
 "tpw"=&gt;[nil],
 "nickh"=&gt;[nil],
 "pjhyett"=&gt;[nil],
 "schacon"=&gt;["lib", "tests"],
 "cdickens"=&gt;["doc"],
 "usinclair"=&gt;["doc"],
 "ebronte"=&gt;["doc"]}
</code></pre>

<p>これで権限がわかったので、あとはプッシュされた各コミットがどのパスを変更しようとしているのかを調べれば、そのユーザーがプッシュすることができるのかどうかを判断できます。</p>

<p>あるコミットでどのファイルが変更されるのかを知るのはとても簡単で、<code>git log</code> コマンドに <code>--name-only</code> オプションを指定するだけです (第 2 章で簡単に説明しました)。</p>

<pre><code>$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb
</code></pre>

<p><code>get_acl_access_data</code> メソッドが返す ACL のデータとこのファイルリストを付き合わせれば、そのユーザーがコミットをプッシュする権限があるかどうかを判断できます。</p>

<pre><code># only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('acl')

  # see if anyone is trying to push something they can't
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path || # user has access to everything
          (path.index(access_path) == 0) # access to this path
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[POLICY] You do not have access to push to #{path}"
        exit 1
      end
    end
  end
end

check_directory_perms
</code></pre>

<p>それほど難しい処理ではありません。まず最初に <code>git rev-list</code> でコミットの一覧を取得し、それぞれに対してどのファイルが変更されるのかを調べ、ユーザーがそのファイルを変更する権限があることを確かめています。Ruby を知らない人にはわかりにくいところがあるとすれば <code>path.index(access_path) == 0</code> でしょうか。これは、パスが <code>access_path</code> で始まるときに真となります。つまり、<code>access_path</code> がパスの一部に含まれるのではなく、パスがそれで始まっているということを確認しています。</p>

<p>これで、まずい形式のコミットメッセージや権利のないファイルの変更を含むコミットはプッシュできなくなりました。</p>

<h4>Fast-Forward なプッシュへの限定</h4>

<p>最後は、fast-forward なプッシュに限るという仕組みです。 <code>receive.denyDeletes</code> および <code>receive.denyNonFastForwards</code> という設定項目で設定できます｡また､フックを用いてこの制限を課すこともできますし､特定のユーザーにだけこの制約を加えたいなどといった変更にも対応できます。</p>

<p>これを調べるには、旧リビジョンからたどれるすべてのコミットについて、新リビジョンから到達できないものがないかどうかを探します。もしひとつもなければ、それは fast-forward なプッシュです。ひとつでも見つかれば、却下することになります。</p>

<pre><code># enforces fast-forward only pushes
def check_fast_forward
  missed_refs = `git rev-list #{$newrev}..#{$oldrev}`
  missed_ref_count = missed_refs.split("\n").size
  if missed_ref_count &gt; 0
    puts "[POLICY] Cannot push a non fast-forward reference"
    exit 1
  end
end

check_fast_forward
</code></pre>

<p>これですべてがととのいました。これまでのコードを書き込んだファイルに対して <code>chmod u+x .git/hooks/update</code> を実行し、fast-forward ではない参照をプッシュしてみましょう。すると、こんなメッセージが表示されるでしょう。</p>

<pre><code>$ git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Cannot push a non fast-forward reference
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
</code></pre>

<p>この中には、いくつか興味深い点があります。まず、フックの実行が始まったときの次の表示に注目しましょう。</p>

<pre><code>Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
</code></pre>

<p>これは、スクリプトの先頭で標準出力に表示した内容でした。ここで重要なのは「スクリプトから標準出力に送った内容は、すべてクライアントにも送られる」ということです。</p>

<p>次に注目するのは、エラーメッセージです。</p>

<pre><code>[POLICY] Cannot push a non fast-forward reference
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
</code></pre>

<p>最初の行はスクリプトから出力したもので、その他の 2 行は Git が出力したものです。この 2 行では、スクリプトがゼロ以外の値で終了したためにプッシュが却下されたということを説明しています。最後に、次の部分に注目します。</p>

<pre><code>To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
</code></pre>

<p>フックで却下したすべての参照について、remote rejected メッセージが表示されます。これを見れば、フック内での処理のせいで却下されたのだということがわかります。</p>

<p>さらに、もしコミットメッセージに適切な ref が含まれていなければ、それを示す次のようなエラーメッセージが表示されるでしょう。</p>

<pre><code>[POLICY] Your message is not formatted correctly
</code></pre>

<p>また、変更権限のないファイルを変更してそれを含むコミットをプッシュしようとしたときも、同様にエラーが表示されます。たとえば、ドキュメント担当者が <code>lib</code> ディレクトリ内の何かを変更しようとした場合のメッセージは次のようになります。</p>

<pre><code>[POLICY] You do not have access to push to lib/test.rb
</code></pre>

<p>以上です。この <code>update</code> スクリプトが動いてさえいれば、もう二度とリポジトリが汚されることはありません。コミットメッセージは決まりどおりのきちんとしたものになるし、ユーザーに変なところをさわられる心配もなくなります。</p>

<h3>クライアントサイドフック</h3>

<p>この方式の弱点は、プッシュが却下されたときにユーザーが泣き寝入りせざるを得なくなるということです。手間暇かけて仕上げた作業が最後の最後で却下されるというのは、非常にストレスがたまるし不可解です。プッシュするためには歴史を修正しなければならないのですが、気弱な人にとってそれはかなりつらいことです。</p>

<p>このジレンマに対する答えとして、サーバーが却下するであろう作業をするときにそれをユーザーに伝えるためのクライアントサイドフックを用意します。そうすれば、何か問題があるときにそれをコミットする前に知ることができるので、取り返しのつかなくなる前に問題を修正することができます。プロジェクトをクローンしてもフックはコピーされないので、別の何らかの方法で各ユーザーにスクリプトを配布しなければなりません。各ユーザーはそれを <code>.git/hooks</code> にコピーし、実行可能にします。フックスクリプト自体をプロジェクトに含めたり別のプロジェクトにしたりすることはできますが、各自の環境でそれをフックとして自動的に設定することはできないのです。</p>

<p>はじめに、コミットを書き込む直前にコミットメッセージをチェックしなければなりません。そして、サーバーに却下されないようにコミットメッセージの書式を調べるのです。そのためには <code>commit-msg</code> フックを使います。最初の引数で渡されたファイルからコミットメッセージを読み込んでパターンと比較し、もしマッチしなければ Git の処理を中断させます。</p>

<pre><code>#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[POLICY] Your message is not formatted correctly"
  exit 1
end
</code></pre>

<p>このスクリプトを適切な場所 (<code>.git/hooks/commit-msg</code>) に置いて実行可能にしておくと、不適切なメッセージを書いてコミットしようとしたときに次のような結果となります。</p>

<pre><code>$ git commit -am 'test'
[POLICY] Your message is not formatted correctly
</code></pre>

<p>このとき、実際にはコミットされません。もしメッセージが適切な書式になっていれば、Git はコミットを許可します。</p>

<pre><code>$ git commit -am 'test [ref: 132]'
[master e05c914] test [ref: 132]
 1 files changed, 1 insertions(+), 0 deletions(-)
</code></pre>

<p>次に、ACL で決められた範囲以外のファイルを変更していないことを確認しましょう。先ほど使った ACL ファイルのコピーがプロジェクトの <code>.git</code> ディレクトリにあれば、次のような <code>pre-commit</code> スクリプトでチェックすることができます。</p>

<pre><code>#!/usr/bin/env ruby

$user    = ENV['USER']

# [ insert acl_access_data method from above ]

# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[POLICY] You do not have access to push to #{path}"
      exit 1
    end
  end
end

check_directory_perms
</code></pre>

<p>大まかにはサーバーサイドのスクリプトと同じですが、重要な違いがふたつあります。まず、ACL ファイルの場所が違います。このスクリプトは作業ディレクトリから実行するものであり、Git ディレクトリから実行するものではないからです。ACL ファイルの場所を、先ほどの</p>

<pre><code>access = get_acl_access_data('acl')
</code></pre>

<p>から次のように変更しなければなりません。</p>

<pre><code>access = get_acl_access_data('.git/acl')
</code></pre>

<p>もうひとつの違いは、変更されたファイルの一覧を取得する方法です。サーバーサイドのメソッドではコミットログを調べていました。しかしこの時点ではまだコミットが記録されていないので、ファイルの一覧はステージング・エリアから取得しなければなりません。つまり、先ほどの</p>

<pre><code>files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`
</code></pre>

<p>は次のようになります。</p>

<pre><code>files_modified = `git diff-index --cached --name-only HEAD`
</code></pre>

<p>しかし、違うのはこの二点だけ。それ以外はまったく同じように動作します。ただ、このスクリプトは、ローカルで実行しているユーザーとリモートマシンにプッシュするときのユーザーが同じであることを前提にしています。もし異なる場合は、変数 <code>$user</code> を手動で設定しなければなりません。</p>

<p>最後に残ったのは fast-forward でないプッシュを止めることですが、これは多少特殊です。fast-forward でない参照を取得するには、すでにプッシュした過去のコミットにリベースするか、別のローカルブランチにリモートブランチと同じところまでプッシュしなければなりません。</p>

<p>サーバーサイドでは fast-forward ではないプッシュをできないようにしているので、それ以外にあり得るのは、すでにプッシュ済みのコミットをリベースしようとするときくらいです。</p>

<p>それをチェックする pre-rebase スクリプトの例を示します。これは書き換えようとしているコミットの一覧を取得し、それがリモート参照の中に存在するかどうかを調べます。リモート参照から到達可能なコミットがひとつでもあれば、リベースを中断します。</p>

<pre><code>#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[POLICY] Commit #{sha} has already been pushed to #{remote_ref}"
      exit 1
    end
  end
end
</code></pre>

<p>このスクリプトでは、第 6 章の「リビジョンの選択」ではカバーしていない構文を使っています。既にプッシュ済みのコミットの一覧を得るために、次のコマンドを実行します。</p>

<pre><code>git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}
</code></pre>

<p><code>SHA^@</code> 構文は、そのコミットのすべての親を解決します。リモートの最後のコミットから到達可能で、これからプッシュしようとするコミットの親のいずれかからアクセスできないコミットを探します。</p>

<p>この方式の弱点は非常に時間がかかることで、多くの場合このチェックは不要です。<code>-f</code> つきで強制的にプッシュしようとしない限り、サーバーが警告を出してプッシュできないからです。しかし練習用の課題としてはおもしろいもので、あとでリベースを取り消してやりなおすはめになることを理屈上は防げるようになります。</p>

<h2>まとめ</h2>

<p>Git クライアントとサーバーをカスタマイズして自分たちのプロジェクトやワークフローにあてはめるための主要な方法を説明しました。あらゆる設定項目やファイルベースの属性、そしてイベントフックについて学び、特定のポリシーを実現するサーバーを構築するサンプルを示しました。これで、あなたが思い描くであろうほぼすべてのワークフローにあわせて Git を調整できるようになったはずです。</p>
<h1>Gitとその他のシステムの連携</h1>

<p>世の中はそんなにうまくいくものではありません。あなたが関わることになったプロジェクトで使うバージョン管理システムを、すぐさまGitに切り替えられることはほとんどないでしょう。また、関わっているプロジェクトが他のVCSを使っていることも時々あるでしょうし、多くの場合 Subversion が使われているのではないかと思います。この章の前半では、まず Subversion と Git を繋ぐ双方向ゲートウェイである <code>git svn</code> について説明します。</p>

<p>どこかの時点で、プロジェクトで Git を使うようにしたくなることもあるでしょう。この章の後半では、プロジェクトのVCSを Git へ移行する方法について説明します。Subversion と Perforce からの移行について説明したあと、特殊なケースにおいてスクリプトを使ったインポートの方法を説明します。</p>

<h2>Git と Subversion</h2>

<p>現在のところ、オープンソースや企業のプロジェクトの大多数が、ソースコードの管理に Subversion を利用しています。Subversion は最も人気のあるオープンソースのVCSで、10年近く前から使われています。Subversion 以前は CVS がソースコード管理に広く用いられていたのですが、多くの点で両者はよく似ています。</p>

<p>Git の素晴しい機能のひとつに、Git と Subversion を双方向にブリッジする <code>git svn</code> があります。このツールを使うと、Subversion のクライアントとして Git を使うことができます。つまり、ローカルの作業では Git の機能を十分に活用することができて、あたかも Subversion を使っているかのように Subversion サーバーに変更をコミットすることができます。共同作業をしている人達が古き良き方法を使っているのと
同時に、ローカルでのブランチ作成やマージ、ステージング・エリア、リベース、チェリーピックなどの Git の機能を使うことができるということです。共同の作業環境に Git を忍び込ませておいて、仲間の開発者たちが Git より効率良く作業できるように手助けをしつつ、Git の全面的な採用のための根回しをしてゆく、というのが賢いやり方です。Subversion ブリッジは、分散VCS の素晴しい世界へのゲートウェイ・ドラッグといえるでしょう。</p>

<h3>git svn</h3>

<p>Git と Subversion の橋渡しをするコマンド群のベースとなるコマンドが <code>git svn</code> です。すべてはここから始めることができます。この後に続くコマンドはかなりたくさんあるので、いくつかのワークフローを通して一般的なものから身につけていきましょう。</p>

<p>注意すべきことは、<code>git svn</code> を使っているときは Subversion を相手にしているのだということです。これは、Git ほど洗練されてはいません。ローカルでのブランチ作成やマージは簡単にできますが、作業内容をリベースするなどして歴史をできるだけ一直線に保つようにし、Git リモートリポジトリを相手にするときのように考えるのは避けましょう。</p>

<p>歴史を書き換えてもう一度プッシュしようなどとしてはいけません。また、他の開発者との共同作業のために複数の Git リポジトリに並行してプッシュするのもいけません。Subversion が扱えるのは一本の直線上の歴史だけで、ちょっとしたことですぐに混乱してしまいます。チームのメンバーの中に SVN を使う人と Git を使う人がいる場合は、全員が SVN サーバーを使って共同作業するようにしましょう。そうすれば、少しは生きやすくなります。</p>

<h3>準備</h3>

<p>この機能を説明するには、書き込みアクセス権を持つ標準的な SVN リポジトリが必要です。もしこのサンプルをコピーして試したいのなら、私のテスト用リポジトリの書き込み可能なコピーを作らなければなりません。これを簡単に行うには、<code>svnsync</code> というツールを使います。最近のバージョンの Subversion、少なくとも 1.4 以降に付属しているツールです。テスト用として、新しい Subversion リポジトリを Google code 上に作りました。これは <code>protobuf</code> プロジェクトの一部で、<code>protobuf</code> は構造化されたデータを符号化してネットワーク上で転送するためのツールです。</p>

<p>まずはじめに、新しいローカル Subversion リポジトリを作ります。</p>

<pre><code>$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn
</code></pre>

<p>そして、すべてのユーザーが revprop を変更できるようにします。簡単な方法は、常に 0 で終了する pre-revprop-change スクリプトを追加することです。</p>

<pre><code>$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change
</code></pre>

<p>これで、ローカルマシンにこのプロジェクトを同期できるようになりました。同期元と同期先のリポジトリを指定して <code>svnsync init</code> を実行します。</p>

<pre><code>$ svnsync init file:///tmp/test-svn http://progit-example.googlecode.com/svn/
</code></pre>

<p>このコマンドは、同期を実行するためのプロパティを設定します。次に、このコマンドでコードをコピーします。</p>

<pre><code>$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Committed revision 3.
...
</code></pre>

<p>この操作は数分で終わりますが、もし元のリポジトリのコピー先がローカルではなく別のリモートリポジトリだった場合、この処理には約一時間かかります。総コミット数はたかだか 100 にも満たないにもかかわらず。Subversion では、リビジョンごとにクローンを作ってコピー先のリポジトリに投入していかなければなりません。これはばかばかしいほど非効率的ですが、簡単に済ませるにはこの方法しかないのです。</p>

<h3>はじめましょう</h3>

<p>書き込み可能な Subversion リポジトリが手に入ったので、一般的なワークフローに沿って進めましょう。まずは <code>git svn clone</code> コマンドを実行します。このコマンドは、Subversion リポジトリ全体をローカルの Git リポジトリにインポートします。どこかにホストされている実際の Subversion リポジトリから取り込む場合は <code>file:///tmp/test-svn</code> の部分を Subversion リポジトリの URL に変更しましょう。</p>

<pre><code>$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /Users/schacon/projects/testsvnsync/svn/.git/
r1 = b4e387bc68740b5af56c2a5faf4003ae42bd135c (trunk)
      A    m4/acx_pthread.m4
      A    m4/stl_hash.m4
...
r75 = d1957f3b307922124eec6314e15bcda59e3d9610 (trunk)
Found possible branch point: file:///tmp/test-svn/trunk =&gt; \
    file:///tmp/test-svn /branches/my-calc-branch, 75
Found branch parent: (my-calc-branch) d1957f3b307922124eec6314e15bcda59e3d9610
Following parent with do_switch
Successfully followed parent
r76 = 8624824ecc0badd73f40ea2f01fce51894189b01 (my-calc-branch)
Checked out HEAD:
 file:///tmp/test-svn/branches/my-calc-branch r76
</code></pre>

<p>これは、指定した URL に対して <code>git svn init</code> に続けて <code>git svn fetch</code> を実行するのと同じ意味です。しばらく時間がかかります。test プロジェクトには 75 のコミットしかなくてコードベースもそれほど大きくないので、数分しかかかりません。しかし、Git は各バージョンをそれぞれチェックアウトしては個別にコミットしています。もし数百数千のコミットがあるプロジェクトで試すと、終わるまでには数時間から下手をすると数日かかってしまうかもしれません。</p>

<p><code>-T trunk -b branches -t tags</code> の部分は、この Subversion リポジトリが標準的なブランチとタグの規約に従っていることを表しています。trunk、branches、tags にもし別の名前をつけているのなら、この部分を変更します。この規約は一般に使われているものなので、単に <code>-s</code> とだけ指定することもできます。これは、先の 3 つのオプションを指定したのと同じ標準のレイアウトを表します。つまり、次のようにしても同じ意味になるということです。</p>

<pre><code>$ git svn clone file:///tmp/test-svn -s
</code></pre>

<p>これで、ブランチやタグも取り込んだ Git リポジトリができあがりました。</p>

<pre><code>$ git branch -a
* master
  my-calc-branch
  tags/2.0.2
  tags/release-2.0.1
  tags/release-2.0.2
  tags/release-2.0.2rc1
  trunk
</code></pre>

<p>このツールがリモート参照を取り込むときの名前空間が通常と異なることに注意しましょう。Git リポジトリのクローンを作成した場合は、リモートサーバー上のすべてのブランチが <code>origin/[branch]</code> のような形式で取り込まれます。つまりリモートの名前で名前空間が作られます。しかし、<code>git svn</code> はリモートが複数あることを想定しておらず、すべてのリモートサーバーを名前空間なしに保存します。Git のコマンド <code>show-ref</code> を使うと、すべての参照名を完全な形式で見ることができます。</p>

<pre><code>$ git show-ref
1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/heads/master
aee1ecc26318164f355a883f5d99cff0c852d3c4 refs/remotes/my-calc-branch
03d09b0e2aad427e34a6d50ff147128e76c0e0f5 refs/remotes/tags/2.0.2
50d02cc0adc9da4319eeba0900430ba219b9c376 refs/remotes/tags/release-2.0.1
4caaa711a50c77879a91b8b90380060f672745cb refs/remotes/tags/release-2.0.2
1c4cb508144c513ff1214c3488abe66dcb92916f refs/remotes/tags/release-2.0.2rc1
1cbd4904d9982f386d87f88fce1c24ad7c0f0471 refs/remotes/trunk
</code></pre>

<p>通常の Git リポジトリは、このようになります。</p>

<pre><code>$ git show-ref
83e38c7a0af325a9722f2fdc56b10188806d83a1 refs/heads/master
3e15e38c198baac84223acfc6224bb8b99ff2281 refs/remotes/gitserver/master
0a30dd3b0c795b80212ae723640d4e5d48cabdff refs/remotes/origin/master
25812380387fdd55f916652be4881c6f11600d6f refs/remotes/origin/testing
</code></pre>

<p>2 つのリモートサーバーがあり、一方の <code>gitserver</code> には <code>master</code> ブランチが、そしてもう一方の <code>origin</code> には <code>master</code> と <code>testing</code> の 2 つのブランチがあります。</p>

<p>サンプルのリモート参照が <code>git svn</code> でどのように取り込まれたかに注目しましょう。タグはリモートブランチとして取り込まれており、Git のタグにはなっていません。Subversion から取り込んだ内容は、まるで tags という名前のリモートからブランチを取り込んだように見えます。</p>

<h3>Subversion へのコミットの書き戻し</h3>

<p>作業リポジトリを手に入れたあなたはプロジェクト上で何らかの作業を終え、コミットを上流に書き戻すことになりました。Git を SVN クライアントとして使います。どれかひとつのファイルを変更してコミットした時点では、Git上でローカルに存在するそのコミットはSubversionサーバー上には存在しません。</p>

<pre><code>$ git commit -am 'Adding git-svn instructions to the README'
[master 97031e5] Adding git-svn instructions to the README
 1 files changed, 1 insertions(+), 1 deletions(-)
</code></pre>

<p>次に、これをプッシュして上流を変更しなければなりません。この変更が Subversion に対してどのように作用するのかに注意しましょう。オフラインで行った複数のコミットを、すべて一度に Subversion サーバーにプッシュすることができます。Subversion サーバーにプッシュするには <code>git svn dcommit</code> コマンドを使います。</p>

<pre><code>$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
       M      README.txt
Committed r79
       M      README.txt
r79 = 938b1a547c2cc92033b74d32030e86468294a5c8 (trunk)
No changes between current HEAD and refs/remotes/trunk
Resetting to the latest refs/remotes/trunk
</code></pre>

<p>このコマンドは、Subversionサーバーからのコード上で行われたすべてのコミットに対して個別に Subversion 上にコミットし、ローカルの Git のコミットを書き換えて一意な識別子を含むようにします。ここで重要なのは、書き換えによってすべてのローカルコミットの SHA-1 チェックサムが変化するということです。この理由もあって、Git ベースのリモートリポジトリにあるプロジェクトと Subversion サーバーを同時に使うことはおすすめできません。直近のコミットを調べれば、新たに <code>git-svn-id</code> が追記されたことがわかります。</p>

<pre><code>$ git log -1
commit 938b1a547c2cc92033b74d32030e86468294a5c8
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sat May 2 22:06:44 2009 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@79 4c93b258-373f-11de-be05-5f7a86268029
</code></pre>

<p>元のコミットの SHA チェックサムが <code>97031e5</code> で始まっていたのに対して今は <code>938b1a5</code> に変わっていることに注目しましょう。Git と Subversion の両方のサーバーにプッシュしたい場合は、まず Subversion サーバーにプッシュ (<code>dcommit</code>) してから Git のほうにプッシュしなければなりません。dcommit でコミットデータが書き換わるからです。</p>

<h3>新しい変更の取り込み</h3>

<p>複数の開発者と作業をしていると、遅かれ早かれ、誰かがプッシュしたあとに他の人がプッシュしようとして衝突を起こすということが発生します。他の人の作業をマージするまで、その変更は却下されます。<code>git svn</code> では、このようになります。</p>

<pre><code>$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
Merge conflict during commit: Your file or directory 'README.txt' is probably \
out-of-date: resource out of date; try updating at /Users/schacon/libexec/git-\
core/git-svn line 482
</code></pre>

<p>この状態を解決するには <code>git svn rebase</code> を実行します。これは、サーバー上の変更のうちまだ取り込んでいない変更をすべて取り込んでから、自分の作業をリベースします。</p>

<pre><code>$ git svn rebase
       M      README.txt
r80 = ff829ab914e8775c7c025d741beb3d523ee30bc4 (trunk)
First, rewinding head to replay your work on top of it...
Applying: first user change
</code></pre>

<p>これで手元の作業が Subversion サーバー上の最新状態の上でなされたことになったので、無事に <code>dcommit</code> することができます。</p>

<pre><code>$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
       M      README.txt
Committed r81
       M      README.txt
r81 = 456cbe6337abe49154db70106d1836bc1332deed (trunk)
No changes between current HEAD and refs/remotes/trunk
Resetting to the latest refs/remotes/trunk
</code></pre>

<p>ここで注意すべき点は、Git の場合は上流での変更をすべてマージしてからでなければプッシュできないけれど、<code>git svn</code> の場合は衝突さえしなければマージしなくてもプッシュできるということです。だれかがあるファイルを変更した後で自分が別のファイルを変更してプッシュしても、<code>dcommit</code> は正しく動作します。</p>

<pre><code>$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
       M      configure.ac
Committed r84
       M      autogen.sh
r83 = 8aa54a74d452f82eee10076ab2584c1fc424853b (trunk)
       M      configure.ac
r84 = cdbac939211ccb18aa744e581e46563af5d962d0 (trunk)
W: d2f23b80f67aaaa1f6f5aaef48fce3263ac71a92 and refs/remotes/trunk differ, \
  using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 \
  015e4c98c482f0fa71e4d5434338014530b37fa6 M   autogen.sh
First, rewinding head to replay your work on top of it...
Nothing to do.
</code></pre>

<p>これは忘れずに覚えておきましょう。というのも、プッシュした後の結果はどの開発者の作業環境にも存在しない状態になっているからです。たまたま衝突しなかっただけで互換性のない変更をプッシュしてしまったときに、その問題を見つけるのが難しくなります。これが、Git サーバーを使う場合と異なる点です。Git の場合はクライアントの状態をチェックしてからでないと変更を公開できませんが、SVN の場合はコミットの直前とコミット後の状態が同等であるかどうかすら確かめられないのです。</p>

<p>もし自分のコミット準備がまだできていなくても、Subversion から変更を取り込むときにもこのコマンドを使わなければなりません。<code>git svn fetch</code> でも新しいデータを取得することはできますが、<code>git svn rebase</code> はデータを取得するだけでなくローカルのコミットの更新も行います。</p>

<pre><code>$ git svn rebase
       M      generate_descriptor_proto.sh
r82 = bd16df9173e424c6f52c337ab6efa7f7643282f1 (trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/trunk.
</code></pre>

<p><code>git svn rebase</code> をときどき実行しておけば、手元のコードを常に最新の状態に保っておけます。しかし、このコマンドを実行するときには作業ディレクトリがクリーンな状態であることを確認しておく必要があります。手元で変更をしている場合は、stash で作業を退避させるか一時的にコミットしてからでないと <code>git svn rebase</code> を実行してはいけません。さもないと、もしリベースの結果としてマージが衝突すればコマンドの実行が止まってしまいます。</p>

<h3>Git でのブランチに関する問題</h3>

<p>Git のワークフローに慣れてくると、トピックブランチを作ってそこで作業を行い、それをマージすることもあるでしょう。<code>git svn</code> を使って Subversion サーバーにプッシュする場合は、それらのブランチをまとめてプッシュするのではなく一つのブランチ上にリベースしてからプッシュしたくなるかもしれません。リベースしたほうがよい理由は、Subversion はリニアに歴史を管理していて Git のようなマージができないからです。<code>git svn</code> がスナップショットを Subversion のコミットに変換するときには、最初の親だけに続けます。</p>

<p>歴史が次のような状態になっているものとしましょう。<code>experiment</code> ブランチを作ってそこで 2 回のコミットを済ませ、それを <code>master</code> にマージしたところです。ここで <code>dcommit</code> すると、出力はこのようになります。</p>

<pre><code>$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
       M      CHANGES.txt
Committed r85
       M      CHANGES.txt
r85 = 4bfebeec434d156c36f2bcd18f4e3d97dc3269a2 (trunk)
No changes between current HEAD and refs/remotes/trunk
Resetting to the latest refs/remotes/trunk
COPYING.txt: locally modified
INSTALL.txt: locally modified
       M      COPYING.txt
       M      INSTALL.txt
Committed r86
       M      INSTALL.txt
       M      COPYING.txt
r86 = 2647f6b86ccfcaad4ec58c520e369ec81f7c283c (trunk)
No changes between current HEAD and refs/remotes/trunk
Resetting to the latest refs/remotes/trunk
</code></pre>

<p>歴史をマージしたブランチで <code>dcommit</code> を実行してもうまく動作します。ただし、Git プロジェクト上での歴史を見ると、<code>experiment</code> ブランチ上でのコミットは書き換えられていません。そこでのすべての変更は、SVN 上での単一のマージコミットとなっています。</p>

<p>他の人がその作業をクローンしたときには、すべての作業をひとまとめにしたマージコミットしか見ることができません。そのコミットがどこから来たのか、そしていつコミットされたのかを知ることができないのです。</p>

<h3>Subversion のブランチ</h3>

<p>Subversion のブランチは Git のブランチとは異なります。可能ならば、Subversion のブランチは使わないようにするのがベストでしょう。しかし、Subversion のブランチの作成やコミットも、<code>git svn</code> を使ってすることができます。</p>

<h4>新しい SVN ブランチの作成</h4>

<p>Subversion に新たなブランチを作るには <code>git svn branch [branchname]</code> を実行します。</p>

<pre><code>$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r87 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk =&gt; \
  file:///tmp/test-svn/branches/opera, 87
Found branch parent: (opera) 1f6bfe471083cbca06ac8d4176f7ad4de0d62e5f
Following parent with do_switch
Successfully followed parent
r89 = 9b6fe0b90c5c9adf9165f700897518dbc54a7cbf (opera)
</code></pre>

<p>これは Subversion の <code>svn copy trunk branches/opera</code> コマンドと同じ意味で、Subversion サーバー上で実行されます。ここで注意すべき点は、このコマンドを実行しても新しいブランチに入ったことにはならないということです。この後コミットをすると、そのコミットはサーバーの <code>trunk</code> に対して行われます。<code>opera</code> ではありません。</p>

<h3>アクティブなブランチの切り替え</h3>

<p>Git が dcommit の行き先のブランチを決めるときには、あなたの手元の歴史上にある Subversion ブランチのいずれかのヒントを使います。手元にはひとつしかないはずで、それは現在のブランチの歴史上の直近のコミットにある <code>git-svn-id</code> です。</p>

<p>複数のブランチを同時に操作するときは、ローカルブランチを <code>dcommit</code> でその Subversion ブランチにコミットするのかを設定することができます。そのためには、Subversion のブランチをインポートしてローカルブランチを作ります。<code>opera</code> ブランチを個別に操作したい場合は、このようなコマンドを実行します。</p>

<pre><code>$ git branch opera remotes/opera
</code></pre>

<p>これで、<code>opera</code> ブランチを <code>trunk</code> (手元の <code>master</code> ブランチ) にマージするときに通常の <code>git merge</code> が使えるようになりました。しかし、そのときには適切なコミットメッセージを (<code>-m</code> で) 指定しなければなりません。さもないと、有用な情報ではなく単なる "Merge branch opera" というメッセージになってしまいます。</p>

<p><code>git merge</code> を使ってこの操作を行ったとしても、そしてそれが Subversion でのマージよりもずっと簡単だったとしても (Git は自動的に適切なマージベースを検出してくれるからね)、これは通常の Git のマージコミットとは違うということを覚えておきましょう。このデータを Subversion に書き戻すことになりますが Subversion では複数の親を持つコミットは処理できません。そのため、プッシュした後は、別のブランチ上で行ったすべての操作をひとまとめにした単一のコミットに見えてしまいます。あるブランチを別のブランチにマージしたら、元のブランチに戻って作業を続けるのは困難です。Git なら簡単なのですが。<code>dcommit</code> コマンドを実行すると、どのブランチからマージしたのかという情報はすべて消えてしまいます。そのため、それ以降のマージ元の算出は間違ったものとなります。dcommit は、<code>git merge</code> の結果をまるで <code>git merge --squash</code> を実行したのと同じ状態にしてしまうのです。残念ながら、これを回避するよい方法はありません。Subversion 側にこの情報を保持する方法がないからです。Subversion をサーバーに使う以上は、常にこの制約に縛られることになります。問題を回避するには、trunk にマージしたらローカルブランチ (この場合は <code>opera</code>) を削除しなければなりません。</p>

<h3>Subversion コマンド</h3>

<p><code>git svn</code> ツールセットには、Git への移行をしやすくするための多くのコマンドが用意されています。Subversion で使い慣れていたのと同等の機能を提供するコマンド群です。その中からいくつかを紹介します。</p>

<h4>SVN 形式のログ</h4>

<p>Subversion に慣れているので SVN が出力する形式で歴史を見たい、という場合は <code>git svn log</code> を実行しましょう。すると、コミットの歴史が SVN 形式で表示されます。</p>

<pre><code>$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2009-05-02 16:00:21 -0700 (Sat, 02 May 2009) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2009-05-02 16:00:09 -0700 (Sat, 02 May 2009) | 2 lines

updated the changelog
</code></pre>

<p><code>git svn log</code> に関して知っておくべき重要なことがふたつあります。まず。このコマンドはオフラインで動作します。実際の <code>svn log</code> コマンドのように Subversion サーバーにデータを問い合わせたりしません。次に、すでに Subversion サーバーにコミット済みのコミットしか表示されません。つまり、ローカルの Git へのコミットのうちまだ dcommit していないものは表示されないし、その間に他の人が Subversion サーバーにコミットした内容も表示されません。最後に Subversion サーバーの状態を調べたときのログが表示されると考えればよいでしょう。</p>

<h4>SVN アノテーション</h4>

<p><code>git svn log</code> コマンドが <code>svn log</code> コマンドをオフラインでシミュレートしているのと同様に、<code>svn annotate</code> と同様のことを <code>git svn blame [FILE]</code> で実現できます。出力は、このようになります。</p>

<pre><code>$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal
</code></pre>

<p>先ほどと同様、このコマンドも Git にローカルにコミットした内容や他から Subversion にプッシュされていたコミットは表示できません。</p>

<h4>SVN サーバ情報</h4>

<p><code>svn info</code> と同様のサーバー情報を取得するには <code>git svn info</code> を実行します。</p>

<pre><code>$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)
</code></pre>

<p><code>blame</code> や <code>log</code> と同様にこれもオフラインで動作し、最後に Subversion サーバーと通信した時点での情報しか表示されません。</p>

<h4>Subversion が無視するものを無視する</h4>

<p>どこかに <code>svn:ignore</code> プロパティが設定されている Subversion リポジトリをクローンした場合は、対応する <code>.gitignore</code> ファイルを用意したくなることでしょう。コミットすべきではないファイルを誤ってコミットしてしまうことを防ぐためにです。<code>git svn</code> には、この問題に対応するためのコマンドが二つ用意されています。まず最初が <code>git svn create-ignore</code> で、これは、対応する <code>.gitignore</code> ファイルを自動生成して次のコミットに含めます。</p>

<p>もうひとつは <code>git svn show-ignore</code> で、これは <code>.gitignore</code> に書き込む内容を標準出力に送ります。この出力を、プロジェクトの exclude ファイルにリダイレクトしましょう。</p>

<pre><code>$ git svn show-ignore &gt; .git/info/exclude
</code></pre>

<p>これで、プロジェクトに <code>.gitignore</code> ファイルを散らかさなくてもよくなります。Subversion 使いのチームの中で Git を使うのが自分だけだという場合、他のメンバーにとっては <code>.gitignore</code> ファイルは目障りでしょう。そのような場合はこの方法が使えます。</p>

<h3>Git-Svn のまとめ</h3>

<p><code>git svn</code> ツール群は、Subversion サーバーに行き詰まっている場合や使っている開発環境が Subversion サーバー前提になっている場合などに便利です。Git のできそこないだと感じるかもしれません。また、他のメンバーとの間で混乱が起こるかもしれません。トラブルを避けるために、次のガイドラインに従いましょう。</p>

<ul>
<li>Git の歴史をリニアに保ち続け、<code>git merge</code> によるマージコミットを含めないようにする。本流以外のブランチでの作業を書き戻すときは、マージではなくリベースすること。</li>
<li>Git サーバーを別途用意したりしないこと、新しい開発者がクローンするときのスピードをあげるためにサーバーを用意することはあるでしょうが、そこに <code>git-svn-id</code> エントリを持たないコミットをプッシュしてはいけません。<code>pre-receive</code> フックを追加してコミットメッセージをチェックし、<code>git-svn-id</code> がなければプッシュを拒否するようにしてもよいでしょう。</li>
</ul>


<p>これらのガイドラインを守れば、Subversion サーバーでの作業にも耐えられることでしょう。しかし、もし本物の Git サーバーに移行できるのなら、そうしたほうがチームにとってずっと利益になります。</p>

<h2>Git への移行</h2>

<p>別の VCS で管理している既存のコードベースを Git で管理しようと思ったら、何らかの方法でそのプロジェクトを移行しなければなりません。この節では、一般的なシステム上の Git に含まれているインポートツールについて説明します。そして、インポートツールを自作する方法も扱います。</p>

<h3>インポート</h3>

<p>ここでは、業務のソースコード管理に使われる2大ツールである Subversion と Perforce からデータをインポートする方法を説明します。現在 Git への移行を考えている人たちの多くがこれらを使っていると聞いています。そのため、これらからのインポート用に、Git には高品質のツールが付属しています。</p>

<h3>Subversion</h3>

<p>先ほどの節で <code>git svn</code> の使い方を読んでいれば、話は簡単です。まず <code>git svn clone</code> でリポジトリを作り、そして Subversion サーバーを使うのをやめ、新しい Git サーバーにプッシュし、あとはそれを使い始めればいいのです。これまでの歴史が欲しいのなら、それも Subversion サーバーからプルすることができます (多少時間がかかります)。</p>

<p>しかし、インポートは完全ではありません。また時間もかかるので、正しくやるのがいいでしょう。まず最初に問題になるのが作者 (author) の情報です。Subversion ではコミットした人すべてがシステム上にユーザーを持っており、それがコミット情報として記録されます。たとえば先ほどの節のサンプルで言うと <code>schacon</code> がそれで、<code>blame</code> の出力や <code>git svn log</code> の出力に含まれています。これをうまく Git の作者データとしてマップするには、Subversion のユーザーと Git の作者のマッピングが必要です。<code>users.txt</code> という名前のファイルを作り、このような書式でマッピングを記述します。</p>

<pre><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;
</code></pre>

<p>SVN で使っている作者の一覧を取得するには、このようにします。</p>

<pre><code>$ svn log ^/ --xml | grep -P "^&lt;author" | sort -u | \
      perl -pe 's/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = /' &gt; users.txt
</code></pre>

<p>これは、まずログを XML フォーマットで出力します。その中から作者を捜して重複を省き、XML を除去します (ちょっと見ればわかりますが、これは <code>grep</code> や <code>sort</code>、そして <code>perl</code> といったコマンドが使える環境でないと動きません)。この出力を users.txt にリダイレクトし、そこに Git のユーザーデータを書き足していきます。</p>

<p>このファイルを <code>git svn</code> に渡せば、作者のデータをより正確にマッピングできるようになります。また、Subversion が通常インポートするメタデータを含めないよう <code>git svn</code> に指示することもできます。そのためには <code>--no-metadata</code> を <code>clone</code> コマンドあるいは <code>init</code> コマンドに渡します。そうすると、 <code>import</code> コマンドは次のようになります。</p>

<pre><code>$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata -s my_project
</code></pre>

<p>これで、Subversion をちょっとマシにインポートした <code>my_project</code> ディレクトリができあがりました。コミットがこんなふうに記録されるのではなく、</p>

<pre><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029
</code></pre>

<p>次のように記録されています。</p>

<pre><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk
</code></pre>

<p>Author フィールドの見た目がずっとよくなっただけではなく、<code>git-svn-id</code> もなくなっています。</p>

<p>インポートした後に、ちょっとした後始末が必要です。たとえば、<code>git svn</code> が準備した変な参照などです。まずはタグを移動して、奇妙なリモートブランチではなくちゃんとしたタグとして扱えるようにします。そして、残りのブランチを移動してローカルで扱えるようにします。</p>

<p>タグを Git のタグとして扱うには、次のコマンドを実行します。</p>

<pre><code>$ git for-each-ref refs/remotes/tags | cut -d / -f 4- | grep -v @ | while read tagname; do git tag "$tagname" "tags/$tagname"; git branch -r -d "tags/$tagname"; done
</code></pre>

<p>これは、リモートブランチのうち <code>tag/</code> で始まる名前のものを、実際の (軽量な) タグに変えます。</p>

<p>次に、<code>refs/remotes</code> 以下にあるそれ以外の参照をローカルブランチに移動します。</p>

<pre><code>$ git for-each-ref refs/remotes | cut -d / -f 3- | grep -v @ | while read branchname; do git branch "$branchname" "refs/remotes/$branchname"; git branch -r -d "$branchname"; done
</code></pre>

<p>これで、今まであった古いブランチはすべて Git のブランチとなり、古いタグもすべて Git のタグになりました。最後に残る作業は、新しい Git サーバーをリモートに追加してプッシュすることです。自分のサーバーをリモートとして追加するには以下のようにします｡</p>

<pre><code>$ git remote add origin git@my-git-server:myrepository.git
</code></pre>

<p>すべてのブランチやタグを一緒にプッシュするには、このようにします。</p>

<pre><code>$ git push origin --all
$ git push origin --tags
</code></pre>

<p>これで、ブランチやタグも含めたすべてを、新しい Git サーバーにきれいにインポートできました。</p>

<h3>Perforce</h3>

<p>次のインポート元としてとりあげるのは Perforce です。Perforce からのインポートツールも Git に同梱されています｡ただし､使用しているGitのバージョンが1.7.11より古い場合は同梱されておらず､Gitソースコードの <code>contrib</code> から取り出す必要があります。ソースコードは git.kernel.org からダウンロードできます。</p>

<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/contrib/fast-import
</code></pre>

<p>この <code>fast-import</code> ディレクトリにある実行可能な Python スクリプト <code>git-p4</code> が、それです。このツールを使うには、Python と <code>p4</code> ツールがマシンにインストールされていなければなりません。たとえば、Jam プロジェクトを Perforce Public Depot からインポートします。クライアントをセットアップするには、環境変数 P4PORT をエクスポートして Perforce depot の場所を指すようにしなければなりません。</p>

<pre><code>$ export P4PORT=public.perforce.com:1666
</code></pre>

<p><code>git-p4 clone</code> コマンドを実行して Jam プロジェクトを Perforce サーバーからインポートし、depot とプロジェクトそしてプロジェクトの取り込み先のパスを指定します。</p>

<pre><code>$ git-p4 clone //public/jam/src@all /opt/p4import
Importing from //public/jam/src@all into /opt/p4import
Reinitialized existing Git repository in /opt/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 4409 (100%)
</code></pre>

<p><code>/opt/p4import</code> ディレクトリに移動して <code>git log</code> を実行すると、インポートされた内容を見ることができます。</p>

<pre><code>$ git log -2
commit 1fd4ec126171790efd2db83548b85b1bbbc07dc2
Author: Perforce staff &lt;support@perforce.com&gt;
Date:   Thu Aug 19 10:18:45 2004 -0800

    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into
    the main part of the document.  Built new tar/zip balls.

    Only 16 months later.

    [git-p4: depot-paths = "//public/jam/src/": change = 4409]

commit ca8870db541a23ed867f38847eda65bf4363371d
Author: Richard Geiger &lt;rmg@perforce.com&gt;
Date:   Tue Apr 22 20:51:34 2003 -0800

    Update derived jamgram.c

    [git-p4: depot-paths = "//public/jam/src/": change = 3108]
</code></pre>

<p><code>git-p4</code> という識別子が各コミットに含まれることがわかるでしょう。この識別子はそのままにしておいてもかまいません。後で万一 Perforce のチェンジ番号を参照しなければならなくなったときのために使えます。しかし、もし削除したいのならここで消しておきましょう。新しいリポジトリ上で何か作業を始める前のこの段階で。<code>git filter-branch</code> を使えば、この識別子を一括削除することができます。</p>

<pre><code>$ git filter-branch --msg-filter '
        sed -e "/^\[git-p4:/d"
'
Rewrite 1fd4ec126171790efd2db83548b85b1bbbc07dc2 (123/123)
Ref 'refs/heads/master' was rewritten
</code></pre>

<p><code>git log</code> を実行すれば各コミットの SHA-1 チェックサムがすべて変わったことがわかります。そして <code>git-p4</code> 文字列はコミットメッセージから消えました。</p>

<pre><code>$ git log -2
commit 10a16d60cffca14d454a15c6164378f4082bc5b0
Author: Perforce staff &lt;support@perforce.com&gt;
Date:   Thu Aug 19 10:18:45 2004 -0800

    Drop 'rc3' moniker of jam-2.5.  Folded rc2 and rc3 RELNOTES into
    the main part of the document.  Built new tar/zip balls.

    Only 16 months later.

commit 2b6c6db311dd76c34c66ec1c40a49405e6b527b2
Author: Richard Geiger &lt;rmg@perforce.com&gt;
Date:   Tue Apr 22 20:51:34 2003 -0800

    Update derived jamgram.c
</code></pre>

<p>これで、インポートした内容を新しい Git サーバーにプッシュする準備がととのいました。</p>

<h3>カスタムインポーター</h3>

<p>Subversion や Perforce 以外のシステムを使っている場合は、それ用のインポートツールを探さなければなりません。CVS、Clear Case、Visual Source Safe、あるいはアーカイブのディレクトリなどのためのツールはオンラインで公開されています。これらのツールがうまく動かなかったり手元で使っているバージョン管理ツールがもっとマイナーなものだったり、あるいはインポート処理で特殊な操作をしたりしたい場合は <code>git fast-import</code> を使います。このコマンドはシンプルな指示を標準入力から受け取って、特定の Git データを書き出します。生の Git コマンドを使ったり生のオブジェクトを書きだそうとしたりする (詳細は第 9 章を参照ください) よりもずっと簡単に Git オブジェクトを作ることができます。この方法を使えばインポートスクリプトを自作することができます。必要な情報を元のシステムから読み込み、単純な指示を標準出力に出せばよいのです。そして、このスクリプトの出力をパイプで <code>git fast-import</code> に送ります。</p>

<p>手軽に試してみるために、シンプルなインポーターを書いてみましょう。currentで作業をしており、プロジェクトのバックアップはディレクトリまるごとのコピーで行っているものとします。バックアップディレクトリの名前は、タイムスタンプをもとに <code>back_YYYY_MM_DD</code> としています。これらを Git にインポートしてみましょう。ディレクトリの構造は、このようになっています。</p>

<pre><code>$ ls /opt/import_from
back_2009_01_02
back_2009_01_04
back_2009_01_14
back_2009_02_03
current
</code></pre>

<p>Git のディレクトリにインポートするにはまず、これらのデータをどのように Git に格納するかをレビューしなければなりません。Git は基本的にはコミットオブジェクトのリンクリストであり、コミットオブジェクトがコンテンツのスナップショットを指しています。<code>fast-import</code> に指示しなければならないのは、コンテンツのスナップショットが何でどのコミットデータがそれを指しているのかということと、コミットデータを取り込む順番だけです。ここでは、スナップショットをひとつずつたどって各ディレクトリの中身をさすコミットオブジェクトを作り、それらを日付順にリンクさせるものとします。</p>

<p>第 7 章の「Git ポリシーの実施例」同様、ここでも Ruby を使って書きます。ふだんから使いなれており、きっと他の方にも読みやすいであろうからです。このサンプルをあなたの使いなれた言語で書き換えるのも簡単でしょう。単に適切な情報を標準出力に送るだけなのだから。また、Windows を使っている場合は、行末にキャリッジリターンを含めないように注意が必要です。<code>git fast-import</code> が想定している行末は LF だけであり、Windows で使われている CRLF は想定していません。</p>

<p>まず最初に対象ディレクトリに移動し、コミットとしてインポートするスナップショットとしてサブディレクトリを識別します。基本的なメインループは、このようになります。</p>

<pre><code>last_mark = nil

# 各ディレクトリをループ
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # 対象ディレクトリに移動
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end
</code></pre>

<p>各ディレクトリ内で実行している <code>print_export</code> は、前のスナップショットの内容とマークを受け取ってこのディレクトリの内容とマークを返します。このようにして、それぞれを適切にリンクさせます。「マーク」とは <code>fast-import</code> 用語で、コミットに対する識別子を意味します。コミットを作成するときにマークをつけ、それを使って他のコミットとリンクさせます。つまり、<code>print_export</code> メソッドで最初にやることは、ディレクトリ名からマークを生成することです。</p>

<pre><code>mark = convert_dir_to_mark(dir)
</code></pre>

<p>これを行うには、まずディレクトリの配列を作り、そのインデックスの値をマークとして使います。マークは整数値でなければならないからです。メソッドの中身はこのようになります。</p>

<pre><code>$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end
</code></pre>

<p>これで各コミットを整数値で表せるようになりました。次に必要なのは、コミットのメタデータ用の日付です。日付はディレクトリ名で表されているので、ここから取得します。<code>print_export</code> ファイルで次にすることは、これです。</p>

<pre><code>date = convert_dir_to_date(dir)
</code></pre>

<p><code>convert_dir_to_date</code> の定義は次のようになります。</p>

<pre><code>def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end
</code></pre>

<p>これは、各ディレクトリの日付に対応する整数値を返します。コミットのメタ情報として必要な最後の情報はコミッターのデータで、これはグローバル変数にハードコードします。</p>

<pre><code>$author = 'Scott Chacon &lt;schacon@example.com&gt;'
</code></pre>

<p>これで、コミットのデータをインポーターに流せるようになりました。最初の情報で示しているのは、今定義しているのがコミットオブジェクトであることとどのブランチにいるのかを表す宣言です。その後に先ほど生成したマークが続き、さらにコミッターの情報とコミットメッセージが続いた後にひとつ前のコミットが (もし存在すれば) 続きます。コードはこのようになります。</p>

<pre><code># インポート情報の表示
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark
</code></pre>

<p>タイムゾーン (-0700) をハードコードしているのは、そのほうがお手軽だったからです。別のシステムからインポートする場合は、タイムゾーンを適切に指定しなければなりません。コミットメッセージは、次のような特殊な書式にする必要があります。</p>

<pre><code>data (size)\n(contents)
</code></pre>

<p>まず最初に「data」という単語、そして読み込むデータのサイズ、改行、最後にデータがきます。同じ書式は後でファイルのコンテンツを指定するときにも使うので、ヘルパーメソッド <code>export_data</code> を作ります。</p>

<pre><code>def export_data(string)
  print "data #{string.size}\n#{string}"
end
</code></pre>

<p>残っているのは、各スナップショットが持つファイルのコンテンツを指定することです。今回の場合はどれも一つのディレクトリにまとまっているので簡単です。<code>deleteall</code> コマンドを表示し、それに続けてディレクトリ内の各ファイルの中身を表示すればよいのです。そうすれば、Git が各スナップショットを適切に記録します。</p>

<pre><code>puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end
</code></pre>

<p>注意: 多くのシステムではリビジョンを「あるコミットと別のコミットの差分」と考えているので、fast-importでもその形式でコマンドを受け取ることができます。つまりコミットを指定するときに、追加/削除/変更されたファイルと新しいコンテンツの中身で指定できるということです。各スナップショットの差分を算出してそのデータだけを渡すこともできますが、処理が複雑になります。すべてのデータを渡して、Git に差分を算出させたほうがよいでしょう。もし差分を渡すほうが手元のデータに適しているようなら、<code>fast-import</code> のマニュアルで詳細な方法を調べましょう。</p>

<p>新しいファイルの内容、あるいは変更されたファイルと変更後の内容を表す書式は次のようになります。</p>

<pre><code>M 644 inline path/to/file
data (size)
(file contents)
</code></pre>

<p>この 644 はモード (実行可能ファイルがある場合は、そのファイルについては 755 を指定する必要があります) を表し、inline とはファイルの内容をこの次の行に続けて指定するという意味です。<code>inline_data</code> メソッドは、このようになります。</p>

<pre><code>def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end
</code></pre>

<p>先ほど定義した <code>export_data</code> メソッドを再利用することができます。この書式はコミットメッセージの書式と同じだからです。</p>

<p>最後に必要となるのは、現在のマークを返して次の処理に渡せるようにすることです。</p>

<pre><code>return mark
</code></pre>

<p>注意: Windows 上で動かす場合はさらにもう一手間必要です。先述したように、Windows の改行文字は CRLF ですが <code>git fast-import</code> は LF にしか対応していません。この問題に対応して <code>git fast-import</code> をうまく動作させるには、CRLF ではなく LF を使うよう ruby に指示しなければなりません。</p>

<pre><code>$stdout.binmode
</code></pre>

<p>これで終わりです。このスクリプトを実行すれば、次のような結果が得られます。</p>

<pre><code>$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer Scott Chacon &lt;schacon@geemail.com&gt; 1230883200 -0700
data 29
imported from back_2009_01_02deleteall
M 644 inline file.rb
data 12
version two
commit refs/heads/master
mark :2
committer Scott Chacon &lt;schacon@geemail.com&gt; 1231056000 -0700
data 29
imported from back_2009_01_04from :1
deleteall
M 644 inline file.rb
data 14
version three
M 644 inline new.rb
data 16
new version one
(...)
</code></pre>

<p>インポーターを動かすには、インポート先の Git レポジトリにおいて､インポーターの出力をパイプで <code>git fast-import</code> に渡す必要があります。インポート先に新しいディレクトリを作成したら､以下のように <code>git init</code> を実行し、そしてスクリプトを実行してみましょう｡</p>

<pre><code>$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           18 (         1 duplicates                  )
      blobs  :            7 (         1 duplicates          0 deltas)
      trees  :            6 (         0 duplicates          1 deltas)
      commits:            5 (         0 duplicates          0 deltas)
      tags   :            0 (         0 duplicates          0 deltas)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              3
Memory total:          2255 KiB
       pools:          2098 KiB
     objects:           156 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize =   33554432
pack_report: core.packedGitLimit      =  268435456
pack_report: pack_used_ctr            =          9
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =       1356 /       1356
---------------------------------------------------------------------
</code></pre>

<p>ご覧のとおり、処理が正常に完了すると、処理内容に関する統計情報が表示されます。この場合は、全部で 18 のオブジェクトからなる 5 つのコミットが 1 つのブランチにインポートされたことがわかります。では、<code>git log</code> で新しい歴史を確認しましょう。</p>

<pre><code>$ git log -2
commit 10bfe7d22ce15ee25b60a824c8982157ca593d41
Author: Scott Chacon &lt;schacon@example.com&gt;
Date:   Sun May 3 12:57:39 2009 -0700

    imported from current

commit 7e519590de754d079dd73b44d695a42c9d2df452
Author: Scott Chacon &lt;schacon@example.com&gt;
Date:   Tue Feb 3 01:00:00 2009 -0700

    imported from back_2009_02_03
</code></pre>

<p>きれいな Git リポジトリができていますね。ここで重要なのは、この時点ではまだ何もチェックアウトされていないということです。作業ディレクトリには何もファイルがありません。ファイルを取得するには、ブランチをリセットして <code>master</code> の現在の状態にしなければなりません。</p>

<pre><code>$ ls
$ git reset --hard master
HEAD is now at 10bfe7d imported from current
$ ls
file.rb  lib
</code></pre>

<p><code>fast-import</code> ツールにはさらに多くの機能があります。さまざまなモードを処理したりバイナリデータを扱ったり、複数のブランチやそのマージ、タグ、進捗状況表示などです。より複雑なシナリオのサンプルは Git のソースコードの <code>contrib/fast-import</code> ディレクトリにあります。先ほど取り上げた <code>git-p4</code> スクリプトがよい例となるでしょう。</p>

<h2>まとめ</h2>

<p>Git を Subversion と組み合わせて使う方法を説明しました。また、既存のリポジトリのほぼすべてを、データを失うことなく新たな Git リポジトリにインポートできるようになりました。次章では、Git の内部に踏み込みます。必要とあらばバイト単位での操作もできることでしょう。</p>
<h1>Gitの内側</h1>

<p>あなたは前の章を飛ばしてこの章に来たのでしょうか、あるいは、この本の他の部分を読んだ後で来たのでしょうか。いずれにせよ、この章ではGit の内部動作と実装を辿っていくことになります。内部動作と実装を学ぶことは、Git がどうしてこんなに便利で有効なのかを根本的に理解するのに重要です。しかし初心者にとっては不必要に複雑で混乱を招いてしまうという人もいました。そのため、遅かれ早かれ学習の仕方に合わせて読めるように、この話題を最後の章に配置しました。いつ読むかって？　それは読者の判断にお任せします。</p>

<p>もう既にあなたはこの章を読んでいますので、早速、開始しましょう。まず、基本的にGit は連想記憶ファイル・システム（content-addressable filesystem）であり、その上にVCS ユーザー・インターフェイスが記述されているのです。これが意味することを、もう少し見て行きましょう。</p>

<p>初期のGit（主として1.5以前）は、洗練されたVCS というよりもむしろファイル・システムであることを（Gitの特徴として）強調しており、それ故に、ユーザー・インターフェイスは今よりも複雑なものでした。ここ数年の間に、世の中のどのシステムにも劣らないほどGit のユーザー・インターフェイスはシンプルで扱いやすいものに改良されました。しかし、複雑で学習するのが難しいという初期のGit に対する型にはまったイメージはまだ残っています。</p>

<p>連想記憶ファイル・システム層は驚くほど素晴らしいので、この章の最初にそれをカバーすることにします。その次に転送メカニズムと、今後あなたが行う必要があるかもしれないリポジトリの保守作業について学習することにします。</p>

<h2>配管（Plumbing）と磁器（Porcelain）</h2>

<p>本書は、<code>checkout</code> や <code>branch</code>、<code>remote</code> などの約30のコマンドを用いて、Git の使い方を説明しています。ですが、Git は元々、完全にユーザフレンドリーなバージョン管理システムというよりもむしろ、バージョン管理システムのためのツール類でした。そのため、下位レベルの仕事を行うためのコマンドが沢山あり、UNIXの形式（またはスクリプトから呼ばれる形式）と密に関わりながら設計されました。これらのコマンドは、通常は "配管（plumbing）" コマンドと呼ばれ、よりユーザフレンドリーなコマンドは "磁器（porcelain）" コマンドと呼ばれます。</p>

<p>本書のはじめの8つの章は、ほぼ例外なく磁器コマンドを取り扱いますが、本章では下位レベルの配管コマンドを専ら使用することになります。なぜなら、それらのコマンドは、Gitの内部動作にアクセスして、Gitの内部で、何を、どのように、どうして行うのかを確かめるのに役に立つからです。それらのコマンドは、コマンドラインから実行するのに使用されるのではなく、むしろ新規のツールとカスタムスクリプトのための構成要素（building blocks）として使用されます。</p>

<p>新規の、または既存のディレクトリで <code>git init</code> を実行すると、Git は <code>.git</code> というディレクトリを作ります。Git が保管して操作するほとんどすべてのものがそこに格納されます。もしもレポジトリをバックアップするかクローンを作りたいなら、この1つのディレクトリをどこかにコピーすることで、必要とするほとんどすべてのことが満たされます。この章では全体を通して、<code>.git</code> ディレクトリの中を基本的に取り扱います。その中は以下のようになっています。</p>

<pre><code>$ ls
HEAD
branches/
config
description
hooks/
index
info/
objects/
refs/
</code></pre>

<p>これは <code>git init</code> を実行した直後のデフォルトのレポジトリです。それ以外の場合は、他にも幾つかのファイルがそこに見つかるかもしれません。<code>branches</code> ディレクトリは、新しいバージョンのGitでは使用されません。<code>description</code> ファイルは、GitWeb プログラムのみで使用します。そのため、それらについての配慮は不要です。<code>config</code> ファイルには、あなたのプロジェクト固有の設定オプションが含まれます。<code>info</code> ディレクトリは、追跡されている <code>.gitignore</code> ファイルには記述したくない無視パターンを書くための、グローバルレベルの除外設定ファイルを保持します。<code>hooks</code> ディレクトリには、あなたのクライアントサイド、または、サーバサイドのフックスクリプトが含まれます。それについての詳細は7章に記述されています。</p>

<p>残りの4つ（<code>HEAD</code> ファイルと <code>index</code> ファイル、また、<code>objects</code> ディレクトリと <code>refs</code> ディレクトリ）は重要なエントリです。これらは、Git の中核（コア）の部分に相当します。<code>objects</code> ディレクトリはあなたのデータベースのすべてのコンテンツを保管します。<code>refs</code> ディレクトリは、そのデータ（ブランチ）内のコミットオブジェクトを指すポインターを保管します。<code>HEAD</code> ファイルは、現在チェックアウトしているブランチを指します。<code>index</code> ファイルは、Git がステージングエリアの情報の保管する場所を示します。これから各セクションで、Git がどのような仕組みで動くのかを詳細に見ていきます。</p>

<h2>Gitオブジェクト</h2>

<p>Git は連想記憶ファイル・システムです。素晴らしい。…で、それはどういう意味なのでしょう?それは、Git のコアの部分が単純なキーバリューから成り立つデータストアである、という意味です。<code>hash-object</code> という配管コマンドを使用することで、それを実際にお見せすることができます。そのコマンドはあるデータを取り出して、それを <code>.git</code> ディレクトリに格納し、そのデータが格納された場所を示すキーを返します。まずは、初期化された新しいGit レポジトリには <code>objects</code> ディレクトリが存在しないことを確認します。</p>

<pre><code>$ mkdir test
$ cd test
$ git init
Initialized empty Git repository in /tmp/test/.git/
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
$
</code></pre>

<p>Git は <code>objects</code> ディレクトリを初期化して、その中に <code>pack</code> と <code>info</code> というサブディレクトリを作ります。しかし、ファイルはひとつも作られません。今から Git データベースに幾つかのテキストを格納してみます。</p>

<pre><code>$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p><code>-w</code> オプションは <code>hash-object</code> に、オブジェクトを格納するように伝えます。<code>-w</code> オプションを付けない場合、コマンドはただオブジェクトのキーが何かを伝えます。<code>--stdin</code> オプションは、標準入力からコンテンツを読み込むようにコマンドに伝えます。これを指定しない場合、<code>hash-object</code> はファイルパスを探そうとします。コマンドを実行すると、40文字から成るチェックサムのハッシュ値が出力されます。これは、SHA-1ハッシュです。（後ほど知ることになりますが、これは格納するコンテンツにヘッダーを加えたデータに対するチェックサムです）これでGitがデータをどのようにして格納するかを知ることができました。</p>

<pre><code>$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p>ひとつのファイルが objectsディレクトリの中にあります。このようして Git は、最初にコンテンツを格納します。ひとつの部分のコンテンツにつき 1ファイルで、コンテンツとそのヘッダーに対する SHA-1のチェックサムを用いたファイル名で格納します。サブディレクトリは、SHA-1ハッシュのはじめの2文字で名付けられ、残りの38文字でファイル名が決まります。</p>

<p><code>cat-file</code> コマンドを使って、コンテンツを Git の外に引き出すことができます。これは Git オブジェクトを調べることにおいて、<code>cat-file</code> は万能ナイフ（Swiss army knife）のような便利なコマンドです。<code>-p</code> オプションを付けると、<code>cat-file</code> コマンドはコンテンツのタイプをわかりやすく表示してくれます。</p>

<pre><code>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
</code></pre>

<p>これであなたは Git にコンテンツを追加し、それを再び外に引き出すことができるようになりました。複数のファイルがあるコンテンツに対してもこれと同様のことを行うことができます。例えば、あるファイルに対して幾つかの簡単なバージョン管理行うことができます。まず、新規にファイルを作成し、あなたのデータベースにそのコンテンツを保存します。</p>

<pre><code>$ echo 'version 1' &gt; test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
</code></pre>

<p>それから、幾つか新しいコンテンツをそのファイルに書き込んで、再び保存します。</p>

<pre><code>$ echo 'version 2' &gt; test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
</code></pre>

<p>データベースには、そこに格納した最初のコンテンツのバージョンに加えて、そのファイルの新しいバージョンが二つ追加されています。</p>

<pre><code>$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p>これで、そのファイルを最初のバージョンに復帰（revert）することができます。</p>

<pre><code>$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
$ cat test.txt
version 1
</code></pre>

<p>あるいは、二つ目のバージョンに。</p>

<pre><code>$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
$ cat test.txt
version 2
</code></pre>

<p>しかし、それぞれのファイルのバージョンの SHA-1キーを覚えることは実用的ではありません。加えて、あなたはコンテンツのみを格納していてファイル名はシステム内に格納していません。このオブジェクトタイプはブロブ（blob）と呼ばれます。<code>cat-file -t</code> コマンドに SHA-1キーを渡すことで、あなたは Git 内にあるあらゆるオブジェクトのタイプを問い合わせることができます。</p>

<pre><code>$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
</code></pre>

<h3>ツリーオブジェクト</h3>

<p>次のタイプはツリーオブジェクトです。これは、ファイル名の格納の問題を解決して、さらに、あるグループに属するファイル群を一緒に格納します。Git がコンテンツを格納する方法は、UNIXのファイルシステムに似ていますが少し簡略されています。すべてのコンテンツはツリーとブロブのオブジェクトとして格納されます。ツリーは UNIXのディレクトリエントリーに対応しており、ブロブは幾分かは iノード またはファイルコンテンツに対応しています。1つのツリーオブジェクトは1つ以上のツリーエントリーを含んでいて、またそれらのツリーは、それに関連するモード、タイプ、そしてファイル名と一緒に、ブロブまたはサブツリーへの SHA-1ポインターを含んでいます。例えば、最も単純なプロジェクトの最新のツリーはこのように見えるかもしれません。</p>

<pre><code>$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
</code></pre>

<p><code>master^{tree}</code> のシンタックスは、<code>master</code> ブランチ上での最後のコミットによってポイントされたツリーオブジェクトを示します。<code>lib</code> サブディレクトリがブロブではなく、別のツリーへのポインタであることに注意してください。</p>

<pre><code>$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
</code></pre>

<p>概念的に、Git が格納するデータは図9-1のようなものです。</p>

<p><img src="figures/9.1.png" title="9.1 Gitデータモデルの簡略版" alt="9.1 Gitデータモデルの簡略版" /></p>

<p>独自のツリーを作ることも可能です。Git は通常、ステージングエリアもしくはインデックスの状態を取得することによってツリーを作成し、
そこからツリーオブジェクトを書き込みます。そのため、ツリーオブジェクトを作るには、まず幾つかのファイルをステージングしてインデックスをセットアップしなければなりません。
test.txt ファイルの最初のバージョンである単一エントリーのインデックスを作るには、<code>update-index</code> という配管コマンドを使います。
前バージョンの test.txt ファイルを新しいステージングエリアに人為的に追加するにはこのコマンドを使います。
ファイルはまだステージングエリアには存在しない（未だステージングエリアをセットアップさえしていない）ので、<code>--add</code> オプションを付けなければなりません。
また、追加しようとしているファイルはディレクトリには無くデータベースにあるので、<code>--cacheinfo</code>オプションを付ける必要があります。
その次に、モードと SHA-1、そしてファイル名を指定します。</p>

<pre><code>$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
</code></pre>

<p>この例では、<code>100644</code> のモードを指定しています。これは、それが通常のファイルであることを意味します。他には、実行可能ファイルであることを意味する <code>100755</code> や、シンボリックリンクであることを示す <code>120000</code> のオプションがあります。このモードは通常の UNIX モードから取り入れた概念ですが融通性はもっと劣ります。これら三つのモードは、（他のモードはディレクトリとサブモジュールに使用されますが）Git のファイル（ブロブ）に対してのみ有効です。</p>

<p>これであなたは <code>write-tree</code> コマンドを使って、ステージングエリアをツリーオブジェクトに書き出すことができます。<code>-w</code> オプションは一切必要とされません。<code>write-tree</code> コマンドを呼ぶことで、ツリーがまだ存在しない場合に、自動的にインデックスの状態からツリーオブジェクトを作ります。</p>

<pre><code>$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
</code></pre>

<p>また、これがツリーオブジェクトであることを検証することができます。</p>

<pre><code>$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
</code></pre>

<p>これから、二つ目のバージョンの test.txt に新しいファイルを加えて新しくツリーを作ります。</p>

<pre><code>$ echo 'new file' &gt; new.txt
$ git update-index test.txt
$ git update-index --add new.txt
</code></pre>

<p>これでステージングエリアには、new.txt という新しいファイルに加えて、新しいバージョンの test.txt を持つようになります。（ステージングエリアまたはインデックスの状態を記録している）そのツリーを書き出してみると、以下のように見えます。</p>

<pre><code>$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
</code></pre>

<p>このツリーは両方のファイルエントリを持っていて、さらに、test.txt の SHA-1ハッシュは最初の文字（<code>1f7a7a</code>）から "バージョン2" の SHA-1ハッシュとなっていることに注意してください。ちょっと試しに、最初のツリーをサブディレクトリとしてこの中の1つに追加してみましょう。<code>read-tree</code> を呼ぶことで、ステージングエリアの中にツリーを読み込むことができます。このケースでは、<code>--prefix</code> オプションを付けて <code>read-tree</code> コマンド使用することで、ステージングエリアの中に既存のツリーを、サブツリーとして読み込むことができます。</p>

<pre><code>$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
</code></pre>

<p>先ほど書き込んだ新しいツリーから作業ディレクトリを作っていれば、二つのファイルが作業ディレクトリのトップレベルに見つかり、また、最初のバージョンの test.txt ファイルが含まれている <code>bak</code> という名前のサブディレクトリが見つかります。これらの構造のために Git がデータをどのように含めているかは、図9-2のようにイメージすることができます。</p>

<p><img src="figures/9.2.png" title="9.2 現在のGitデータのコンテンツ構造" alt="9.2 現在のGitデータのコンテンツ構造" /></p>

<h3>コミットオブジェクト</h3>

<p>追跡（track）したいと思うプロジェクトの異なるスナップショットを特定するためのツリーが三つありますが、前の問題が残っています。スナップショットを呼び戻すためには3つすべての SHA-1 の値を覚えなければならない、という問題です。さらに、あなたはそれらのスナップショットがいつ、どのような理由で、誰が保存したのかについての情報を一切持っておりません。これはコミットオブジェクトがあなたのために保持する基本的な情報です。</p>

<p>コミットオブジェクトを作成するには、単一ツリーの SHA-1 と、もしそれに直に先行して作成されたコミットオブジェクトがあれば、それらを指定して <code>commit-tree</code> を呼びます。あなたが書き込んだ最初のツリーから始めましょう。</p>

<pre><code>$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
</code></pre>

<p>これで <code>cat-file</code> コマンドを呼んで新しいコミットオブジェクトを見ることができます。</p>

<pre><code>$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit
</code></pre>

<p>コミットオブジェクトの形式はシンプルです。それはプロジェクトのその時点のスナップショットに対して、トップレベルのツリーを指定します。その時点のスナップショットには、現在のタイムスタンプと共に <code>user.name</code> と <code>user.email</code> の設定から引き出された作者（author）／コミッター（committer）の情報、ブランクライン、そしてコミットメッセージが含まれます。</p>

<p>次に、あなたは二つのコミットオブジェクトを書き込みます。各コミットオブジェクトはその直前に来たコミットを参照しています。</p>

<pre><code>$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
</code></pre>

<p>三つのコミットオブジェクトは、それぞれ、あなたが作成した三つのスナップショットのツリーのひとつを指し示しています。面白いことに、あなたは本物のGitヒストリーを持っており、<code>git log</code> コマンドによってログをみることができます。もしも最後のコミットの SHA-1ハッシュを指定して実行すると、</p>

<pre><code>$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

    third commit

 bak/test.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

    second commit

 new.txt  |    1 +
 test.txt |    2 +-
 2 files changed, 2 insertions(+), 1 deletions(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
</code></pre>

<p>驚くべきことです。あなたは Git ヒストリーを形成するために、フロントエンドにある何かを利用することせずに、ただ下位レベルのオペレーションを行っただけなのです。これは <code>git add</code> コマンドと <code>git commit</code> コマンドを実行するときに Git が行う本質的なことなのです。それは変更されたファイルに対応して、ブロブを格納し、インデックスを更新し、ツリーを書き出します。そして、トップレベルのツリーとそれらの直前に来たコミットを参照するコミットオブジェクトを書きます。これらの三つの主要な Git オブジェクト - ブロブとツリーとコミットは、<code>.git/object</code> ディレクトリに分割されたファイルとして最初に格納されます。こちらは、例のディレクトリに今あるすべてのオブジェクトであり、それらが何を格納しているのかコメントされています。</p>

<pre><code>$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
</code></pre>

<p>もしすべての内部のポインタを辿ってゆけば、図9-3のようなオブジェクトグラフを得られます。</p>

<p><img src="figures/9.3.png" title="9.3 Gitレポジトリ内のすべてのオブジェクト" alt="9.3 Gitレポジトリ内のすべてのオブジェクト" /></p>

<h3>オブジェクトストレージ</h3>

<p>ヘッダはコンテンツと一緒に格納されることを、以前に述べました。少し時間を割いて、Git がどのようにしてオブジェクトを格納するのかを見ていきましょう。あなたはブロブオブジェクトがどのように格納されるのかを見ることになるでしょう。このケースでは "what is up, doc?" という文字列が Rubyスクリプト言語の中で対話的に格納されます。<code>irb</code> コマンドを使って対話的な Rubyモードを開始します。</p>

<pre><code>$ irb
&gt;&gt; content = "what is up, doc?"
=&gt; "what is up, doc?"
</code></pre>

<p>Git はオブジェクトタイプで開始するヘッダを構成します。このケースではブロブのタイプです。そして、コンテンツのサイズに従ってスペースを追加して、最後にヌルバイトを追加します。</p>

<pre><code>&gt;&gt; header = "blob #{content.length}\0"
=&gt; "blob 16\000"
</code></pre>

<p>Git はヘッダとオリジナルのコンテンツとを結合して、その新しいコンテンツの SHA-1チェックサムを計算します。Rubyスクリプト内に書かれた文字列のSHA-1のハッシュ値は、<code>require</code> を使用して SHA1ダイジェストライブラリをインクルードし、文字列を引数にして <code>Digest::SHA1.hexdigest()</code> 関数を呼ぶことで求めることができます。</p>

<pre><code>&gt;&gt; store = header + content
=&gt; "blob 16\000what is up, doc?"
&gt;&gt; require 'digest/sha1'
=&gt; true
&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
</code></pre>

<p>Gitは zlib を用いて新しいコンテンツを圧縮します。Rubyにある zlibライブラリをインクルードして使用します。まず、require を使用して zlib ライブラリをインクルードし、コンテンツに対して <code>Zlib::Deflate.deflate()</code> を実行します。</p>

<pre><code>&gt;&gt; require 'zlib'
=&gt; true
&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; "x\234K\312\311OR04c(\317H,Q\310,V(-\320QH\311O\266\a\000_\034\a\235"
</code></pre>

<p>最後に、zlibで圧縮された（zlib-deflated）コンテンツをディスク上のオブジェクトに書き込みます。オブジェクトの書き込み先のパスを決定します（SHA-1ハッシュ値の最初の2文字はサブディレクトリの名前で、残りの38文字はそのディレクトリ内のファイル名になります）。Rubyでは、<code>FileUtils.mkdir_p()</code> 関数を使用して（存在しない場合に）サブディレクトリを作成することができます。そして、<code>File.open()</code> によってファイルを開いて、前に zlib で圧縮された（zlib-compressed）コンテンツをファイルに書き出します。ファイルへの書き出しは、開いたファイルのハンドルに対して <code>write()</code> を呼ぶことで行います。</p>

<pre><code>&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=&gt; ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
&gt;&gt; require 'fileutils'
=&gt; true
&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; ".git/objects/bd"
&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
=&gt; 32
</code></pre>

<p>これで終わりです。あなたは妥当な Git ブロブオブジェクトを作りました。ただタイプが異なるだけで、Git オブジェクトはすべて同じ方法で格納されます。ブロブの文字列ではない場合には、ヘッダはコミットまたはツリーから始まります。また、ブロブのコンテンツはほぼ何にでもなれるのに対して、コミットとツリーのコンテンツはかなり特定的に形式付けられています。</p>

<h2>Gitの参照</h2>

<p>すべての履歴をひと通り見るには <code>git log 1a410e</code> のように実行します。しかしそれでも履歴を辿りながらそれらすべてのオブジェクトを見つけるためには、<code>1a410e</code> が最後のコミットであることを覚えていなければなりません。SHA-1ハッシュ値を格納できるファイルが必要です。ファイル名はシンプルなもので、未加工（raw）の SHA-1ハッシュ値ではなくポインタを使用することができます。</p>

<p>Git では、これらは "参照（references）" ないしは "refs" と呼ばれます。SHA-1のハッシュ値を含んでいるファイルは <code>.git/refs</code> ディレクトリ内に見つけることができます。現在のプロジェクトでは、このディレクトリに何もファイルはありませんが、シンプルな構成を持っています。</p>

<pre><code>$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
$
</code></pre>

<p>最後のコミットはどこにあるのかを覚えるのに役立つような参照を新しく作るには、これと同じぐらいシンプルなことを技術的にすることができます。</p>

<pre><code>$ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" &gt; .git/refs/heads/master
</code></pre>

<p>これであなたは、Git コマンドにある SHA-1のハッシュ値ではなく、たった今作成したヘッダの参照を使用することができます。</p>

<pre><code>$ git log --pretty=oneline  master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</code></pre>

<p>参照ファイルに対して直接、変更を行うことは推奨されません。Git はそれを行うためのより安全なコマンドを提供しています。もし参照を更新したければ <code>update-ref</code> というコマンドを呼びます。</p>

<pre><code>$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
</code></pre>

<p>Git にとって基本的にブランチとは何なのかをこれは示しているのです。すなわちそれはシンプルなポインタ、もしくは作業ライン（line of work）のヘッドへの参照なのです。二回目のコミット時にバックアップのブランチを作るには、次のようにします。</p>

<pre><code>$ git update-ref refs/heads/test cac0ca
</code></pre>

<p>これでブランチはそのコミットから下の作業のみを含むことになります。</p>

<pre><code>$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</code></pre>

<p>いま、Git のデータベースは概念的には図9-4のように見えます。</p>

<p><img src="figures/9.4.png" title="9.4 ブランチのヘッドへの参照を含むGitディレクトリオブジェクト" alt="9.4 ブランチのヘッドへの参照を含むGitディレクトリオブジェクト" /></p>

<p><code>git branch (ブランチ名)</code> のようにコマンドを実行すると基本的に Git は <code>update-ref</code> コマンドを実行します。そして、あなたが作りたいと思っている新しい参照は何であれ、いま自分が作業しているブランチ上のブランチの最後のコミットの SHA-1ハッシュを追加します。</p>

<h3>HEADブランチ</h3>

<p>では、<code>git branch (ブランチ名)</code> を実行したときに、どこから Git は最後のコミットの SHA-1ハッシュを知ることができるでしょうか？ 答えは、HEADファイルです。HEADファイルは、あなたが現在作業中のブランチに対するシンボリック参照（symbolic reference）です。通常の参照と区別する意図でシンボリック参照と呼びますが、それは、一般的にSHA-1ハッシュ値を持たずに他の参照へのポインタを持ちます。通常は以下のファイルが見えるでしょう。</p>

<pre><code>$ cat .git/HEAD
ref: refs/heads/master
</code></pre>

<p><code>git checkout test</code> を実行すると、Git はこのようにファイルを更新します。</p>

<pre><code>$ cat .git/HEAD
ref: refs/heads/test
</code></pre>

<p><code>git commit</code> を実行すると、コミットオブジェクトが作られます。HEADにある参照先の SHA-1ハッシュ値が何であれ、そのコミットオブジェクトの親が参照先に指定されます。</p>

<p>このファイルを直に編集することもできますが、<code>symbolic-ref</code> と呼ばれる、それを安全に行うためのコマンドが存在します。このコマンドを使ってHEADの値を読み取ることができます。</p>

<pre><code>$ git symbolic-ref HEAD
refs/heads/master
</code></pre>

<p>HEADの値を設定することもできます。</p>

<pre><code>$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test
</code></pre>

<p><code>refs</code> の形式以外では、シンボリック参照を設定することはできません。</p>

<pre><code>$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/
</code></pre>

<h3>タグ</h3>

<p>これまで Git の主要な三つのオブジェクトを見てきましたが、タグという四つ目のオブジェクトがあります。タグオブジェクトはコミットオブジェクトにとても似ています。それには、タガー（tagger）、日付、メッセージ、そしてポインタが含まれます。主な違いは、タグオブジェクトはツリーではなくコミットを指し示すことです。タグオブジェクトはブランチの参照に似ていますが、決して変動しません。そのため常に同じコミットを示しますが、より親しみのある名前が与えられます。</p>

<p>2章で述べましたが、タグには二つのタイプがあります。軽量 (lightweight) 版と注釈付き (annotated) 版です。あなたは、次のように実行して軽量 (lightweight) 版のタグを作ることができます。</p>

<pre><code>$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
</code></pre>

<p>これが軽量版のタグのすべてです。つまり決して変動しないブランチなのです。一方、注釈付き版のタグはもっと複雑です。注釈付き版のタグを作ろうとすると、Git はタグオブジェクトを作り、そして、コミットに対する直接的な参照ではなく、そのタグをポイントする参照を書き込みます。注釈付き版のタグを作ることで、これを見ることができます。（注釈付き版のタグを作るには <code>-a</code> オプションを指定して実行します）</p>

<pre><code>$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'
</code></pre>

<p>これで、作られたオブジェクトの SHA-1ハッシュ値を見ることができます。</p>

<pre><code>$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2
</code></pre>

<p>ここで、そのSHA-1ハッシュ値に対して <code>cat-file</code> コマンドを実行します。</p>

<pre><code>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag
</code></pre>

<p>オブジェクトエントリはあなたがタグ付けしたコミットの SHA-1 ハッシュ値をポイントすることに注意してください。またそれがコミットをポイントする必要がないことに注意してください。あらゆる Git オブジェクトに対してタグ付けをすることができます。例えば、Git のソースコードの保守では GPG 公開鍵をブロブオブジェクトとして追加して、それからタグ付けをします。Git ソースコードレポジトリで、以下のように実行することで公開鍵を閲覧することができます。</p>

<pre><code>$ git cat-file blob junio-gpg-pub
</code></pre>

<p>Linuxカーネルのリポジトリは、さらに、非コミットポインティング（non-commit-pointing）タグオブジェクトを持っています。このタグオブジェクトは、最初のタグが作られるとソースコードのインポートの最初のツリーをポイントします。</p>

<h3>リモート</h3>

<p>これから見ていく三つ目の参照のタイプはリモート参照です。リモートを追加してそれにプッシュを実行すると、Git は追加したリモートにあなたが最後にプッシュした値をを格納します。そのリモートは <code>refs/remotes</code> ディレクトリにある各ブランチを参照します。例えば、<code>origin</code> と呼ばれるリモートを追加して、それを <code>master</code> ブランチにプッシュすることができます。</p>

<pre><code>$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
   a11bef0..ca82a6d  master -&gt; master
</code></pre>

<p>そして、<code>origin</code> リモートに対してどの <code>master</code> ブランチが最後にサーバと通信したのかを、<code>refs/remotes/origin/master</code> ファイルをチェックすることで知ることができます。</p>

<pre><code>$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949
</code></pre>

<p>リモート参照は主にそれらがチェックアウトされ得ないという点において、ブランチ（<code>refs/heads</code> への参照）とは異なります。Git はそれらをブックマークとして、それらのブランチがかつてサーバー上に存在していた場所の最後に知られている状態に移し変えます。</p>

<h2>パックファイル</h2>

<p>Git レポジトリ test のオブジェクトデータベースに戻りましょう。この時点で、あなたは11個のオブジェクトを持っています。4つのブロブ、3つのツリー、3つのコミット、そして1つのタグです。</p>

<pre><code>$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
</code></pre>

<p>Git は zlib を使用してこれらのファイルのコンテンツを圧縮するため、多くを格納していません。これらすべてのファイルを集めても 925バイトにしかならないのです。Git の興味深い機能を実際に見るために、幾つか大きなコンテンツをレポジトリに追加してみましょう。前に作業したGritライブラリから <code>repo.rb</code> ファイルを追加します。これは約 12Kバイトのソースコードファイルです。</p>

<pre><code>$ curl https://raw.github.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb
$ git add repo.rb
$ git commit -m 'added repo.rb'
[master 484a592] added repo.rb
 3 files changed, 459 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)
</code></pre>

<p>結果のツリーを見ると、ブロブオブジェクトから取得した <code>repo.rb</code> ファイルの SHA-1ハッシュ値を見ることができます。</p>

<pre><code>$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
</code></pre>

<p>それから､そのオブジェクトのディスク上のサイズがどのくらいか調べることもできます｡</p>

<pre><code>$ du -b .git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e
4102    .git/objects/9b/c1dc421dcd51b4ac296e3e5b6e2a99cf44391e
</code></pre>

<p>ここで、ファイルに少し変更を加えたらどうなるのか見てみましょう。</p>

<pre><code>$ echo '# testing' &gt;&gt; repo.rb
$ git commit -am 'modified repo a bit'
[master ab1afef] modified repo a bit
 1 files changed, 1 insertions(+), 0 deletions(-)
</code></pre>

<p>このコミットによって作られたツリーをチェックすると、興味深いことがわかります。</p>

<pre><code>$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 05408d195263d853f09dca71d55116663690c27c      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
</code></pre>

<p>そのブロブは今では当初とは異なるブロブです。つまり、400行あるファイルの最後に1行だけ追加しただけなのに、Git はその新しいコンテンツを完全に新しいオブジェクトとして格納するのです。</p>

<pre><code>$ du -b .git/objects/05/408d195263d853f09dca71d55116663690c27c
4109    .git/objects/05/408d195263d853f09dca71d55116663690c27c
</code></pre>

<p>これだとディスク上にほとんど同一の 4Kバイトのオブジェクトを二つ持つことになります。もし Git がそれらのひとつは完全に格納するが二つ目のオブジェクトはもうひとつとの差分（delta）のみを格納するのだとしたら、どんなに素晴らしいことかと思いませんか？</p>

<p>それが可能になったのです。Git がディスク上にオブジェクトを格納する初期のフォーマットは、緩いオブジェクトフォーマット（loose object format）と呼ばれます。しかし Git はこれらのオブジェクトの中の幾つかをひとつのバイナリファイルに詰め込む（pack up）ことがあります。そのバイナリファイルは、空きスペースを保存してより効率的にするための、パックファイル（packfile）と呼ばれます。あまりにたくさんの緩いオブジェクトがそこら中にあるときや、<code>git gc</code> コマンドを手動で実行したとき、または、リモートサーバにプッシュしたときに、Git はこれを実行します。何が起こるのかを知るには、<code>git gc</code> コマンドを呼ぶことで、Git にオブジェクトを詰め込むように手動で問い合わせることができます。</p>

<pre><code>$ git gc
Counting objects: 17, done.
Delta compression using 2 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)
</code></pre>

<p>オブジェクトディレクトリの中を見ると、大半のオブジェクトは消えて、新しいファイルのペアが現れていることがわかります。</p>

<pre><code>$ find .git/objects -type f
.git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack
</code></pre>

<p>残りのオブジェクトは、どのコミットにもポイントされていないブロブです。このケースでは、以前に作成した "what is up, doc?" の例と "test content" のブロブの例がそれにあたります。それらに対していかなるコミットも加えられてないので、それらは遊離（dangling）しているとみなされ新しいパックファイルに詰め込まれないのです。</p>

<p>他のファイルは新しいパックファイルとインデックスです。パックファイルは、ファイルシステムから取り除かれたすべてのオブジェクトのコンテンツを含んでいる単一のファイルです。インデックスは、特定のオブジェクトを速く探し出せるようにパックファイルの中にあるオフセットを含むファイルです。素晴らしいことに、<code>gc</code> を実行する前のディスク上のオブジェクトを集めると約 8Kバイトのサイズであったのに対して、新しいパックファイルは 4Kバイトになっています。オブジェクトをパックすることで、ディスクの使用量が半分になったのです。</p>

<p>Git はどうやってこれを行うのでしょうか？ Git はオブジェクトをパックするとき、似たような名前とサイズのファイルを探し出し、ファイルのあるバージョンから次のバージョンまでの増分のみを格納します。パックファイルの中を見ることで、スペースを確保するために Git が何を行ったのかを知ることができます。<code>git verify-pack</code> という配管コマンドを使用して、何が詰め込まれたのかを知ることができます。</p>

<pre><code>$ git verify-pack -v \
  .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 5400
05408d195263d853f09dca71d55116663690c27c blob   12908 3478 874
09f01cea547666f58d6a8d809583841a7c6f0130 tree   106 107 5086
1a410efbd13591db07496601ebc7a059dd55cfe9 commit 225 151 322
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 5381
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   101 105 5211
484a59275031909e19aadb7c92262719cfcdf19a commit 226 153 169
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 5362
9585191f37f7b0fb9444f35a9bf50de191beadc2 tag    136 127 5476
9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e blob   7 18 5193 1 \
  05408d195263d853f09dca71d55116663690c27c
ab1afef80fac8e34258ff41fc1b867c702daa24b commit 232 157 12
cac0cab538b970a37ea1e769cbbde608743bc96d commit 226 154 473
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 5316
e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4352
f8f51d7d8a1760462eca26eebafde32087499533 tree   106 107 749
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 856
fdf4fc3344e67ab068f836878b6c4951e3b15f3d commit 177 122 627
chain length = 1: 1 object
pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack: ok
</code></pre>

<p>ここで、<code>9bc1d</code> というブロブを覚えてますでしょうか、これは <code>repo.rb</code> ファイルの最初のバージョンですが、このブロブは二つ目のバージョンである <code>05408</code> というブロブを参照しています。出力にある三つ目のカラムはオブジェクトの実体のサイズを示しており、<code>05408</code> の実体は 12Kバイトを要しているが、<code>9bc1d</code> の実体はたったの 7バイトしか要していないことがわかります。さらに興味深いのは、最初のバージョンは増分として格納されているのに対して、二つ目のバージョンのファイルは完全な状態で格納されているということです。これは直近のバージョンのファイルにより速くアクセスする必要があるであろうことに因ります。</p>

<p>これに関する本当に素晴らしいことは、いつでも再パックが可能なことです。Git は時折データベースを自動的に再パックして、常により多くのスペースを確保しようと努めます。また、あなたはいつでも <code>git gc</code> を実行することによって手動で再パックをすることができるのです。</p>

<h2>参照仕様（Refspec）</h2>

<p>本書の全体に渡って、リモートブランチからローカルの参照へのシンプルなマッピングを使用してきました。しかし、それらはもっと複雑なものです。以下のようにリモートを追加したとしましょう。</p>

<pre><code>$ git remote add origin git@github.com:schacon/simplegit-progit.git
</code></pre>

<p><code>.git/config</code> ファイルにセクションを追加して、リモート（<code>origin</code>）の名前、リモートレポジトリのURL、そしてフェッチするための参照仕様（refspec）を指定します。</p>

<pre><code>[remote "origin"]
       url = git@github.com:schacon/simplegit-progit.git
       fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>

<p>参照仕様はコロン（:）で分割した <code>&lt;src&gt;:&lt;dst&gt;</code> の形式で、オプションとして先頭に <code>+</code> を付けます。<code>&lt;src&gt;</code> はリモート側への参照に対するパターンで、<code>&lt;dst&gt;</code> はそれらの参照がローカル上で書かれる場所を示します。<code>+</code> の記号は Git にそれが早送り（fast-forward）でない場合でも参照を更新することを伝えます。</p>

<p>デフォルトのケースでは <code>git remote add</code> コマンドを実行することで自動的に書かれます。このコマンドを実行すると、Git はサーバ上の <code>refs/heads/</code> 以下にあるすべての参照をフェッチして、ローカル上の <code>refs/remotes/origin/</code> にそれらを書きます。そのため、もしもサーバ上に <code>master</code> ブランチがあると、ローカルからそのブランチのログにアクセスすることができます。</p>

<pre><code>$ git log origin/master
$ git log remotes/origin/master
$ git log refs/remotes/origin/master
</code></pre>

<p>これらはすべて同じ意味を持ちます。なぜなら、Git はそれら各々を <code>refs/remotes/origin/master</code> に拡張するからです。</p>

<p>その代わりに、Git に毎回 <code>master</code> ブランチのみを引き出して、リモートサーバ上のそれ以外のすべてのブランチは引き出さないようにしたい場合は、フェッチラインを以下のように変更します。</p>

<pre><code>fetch = +refs/heads/master:refs/remotes/origin/master
</code></pre>

<p>これはまさにリモートへの <code>git fetch</code> に対する参照仕様のデフォルトの振る舞いです。
もし何かを一度実行したければ、コマンドライン上の参照仕様を指定することもできます。
リモート上の <code>master</code> ブランチをプルして、ローカル上の <code>origin/mymaster</code> に落とすには、以下のように実行します。</p>

<pre><code>$ git fetch origin master:refs/remotes/origin/mymaster
</code></pre>

<p>複数の参照仕様を指定することも可能です。コマンドライン上で、幾つかのブランチをこのように引き落とす（pull down）ことができます。</p>

<pre><code>$ git fetch origin master:refs/remotes/origin/mymaster \
   topic:refs/remotes/origin/topic
From git@github.com:schacon/simplegit
 ! [rejected]        master     -&gt; origin/mymaster  (non fast forward)
 * [new branch]      topic      -&gt; origin/topic
</code></pre>

<p>このケースでは、master ブランチのプルは早送りの参照ではなかったため拒否されました。<code>+</code> の記号を参照仕様の先頭に指定することで、それを上書きすることができます。</p>

<p>さらに設定ファイルの中のフェッチ設定に複数の参照仕様を指定することができます。もし master と実験用のブランチを常にフェッチしたいならば、二行を追加します。</p>

<pre><code>[remote "origin"]
       url = git@github.com:schacon/simplegit-progit.git
       fetch = +refs/heads/master:refs/remotes/origin/master
       fetch = +refs/heads/experiment:refs/remotes/origin/experiment
</code></pre>

<p>ブロブの一部をパターンに使用することはできません。これは無効となります。</p>

<pre><code>fetch = +refs/heads/qa*:refs/remotes/origin/qa*
</code></pre>

<p>しかし、似たようなことを達成するのに名前空間を使用することができます。もし一連のブランチをプッシュしてくれる QAチームがいて、master ブランチと QAチームのブランチのみを取得したいならば、設定ファイルのセクションを以下のように使用することができます。</p>

<pre><code>[remote "origin"]
       url = git@github.com:schacon/simplegit-progit.git
       fetch = +refs/heads/master:refs/remotes/origin/master
       fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*
</code></pre>

<p>QAチームと開発チームがローカルのブランチにプッシュして、結合チームがリモートのブランチ上でプッシュして、共同で開発するような、複雑なワークフローのプロセスであるならば、このように、名前空間によってそれらを簡単に分類することができます。</p>

<h3>参照仕様へのプッシュ</h3>

<p>その方法で名前空間で分類された参照をフェッチできることは素晴らしいことです。しかし、そもそもどうやって QAチームは、彼らのブランチを <code>qa/</code> という名前空間の中で取得できるのでしょうか?
参照仕様にプッシュすることによってそれが可能です。</p>

<p>QAチームが彼らの <code>master</code> ブランチをリモートサーバ上の <code>qa/master</code> にプッシュしたい場合、以下のように実行します。</p>

<pre><code>$ git push origin master:refs/heads/qa/master
</code></pre>

<p>もし彼らが <code>git push origin</code> を実行する都度、Git に自動的にそれを行なってほしいならば、設定ファイルに <code>push</code> の値を追加することで目的が達成されます。</p>

<pre><code>[remote "origin"]
       url = git@github.com:schacon/simplegit-progit.git
       fetch = +refs/heads/*:refs/remotes/origin/*
       push = refs/heads/master:refs/heads/qa/master
</code></pre>

<p>再度、これは <code>git push origin</code> の実行をローカルの <code>master</code> ブランチに、リモートの <code>qa/master</code> ブランチに、デフォルトで引き起こします。</p>

<h3>参照の削除</h3>

<p>また、リモートサーバから以下のように実行することによって、参照仕様を参照を削除する目的で使用することもできます。</p>

<pre><code>$ git push origin :topic
</code></pre>

<p>参照仕様は <code>&lt;src&gt;:&lt;dst&gt;</code> という形式であり、<code>&lt;src&gt;</code> の部分を取り除くことは、要するに何もないブランチをリモート上に作ることであり、それを削除することになるのです。</p>

<h2>トランスファープロトコル</h2>

<p>Git は2つのレポジトリ間を二つの主要な方法によってデータを移行することができます。ひとつは HTTPによって、もうひとつは、<code>file://</code> や <code>ssh://</code>、また、<code>git://</code> によるトランスポートに使用される、いわゆるスマートプロトコルによって。このセクションでは、これらの主要なプロトコルがどのように機能するのかを駆け足で見ていきます。</p>

<h3>無口なプロトコル</h3>

<p>Git の over HTTPによる移行は、しばしば無口なプロトコル（dumb protocol）と言われます。なぜなら、トランスポートプロセスの最中に、サーバ側に関する Git 固有のコードは何も必要としないからです。フェッチプロセスは、一連の GET リクエストであり、クライアントはサーバ上の Gitレポジトリのレイアウトを推測することができます。simplegit ライブラリに対する <code>http-fetch</code> のプロセスを追ってみましょう。</p>

<pre><code>$ git clone http://github.com/schacon/simplegit-progit.git
</code></pre>

<p>最初にこのコマンドが行うことは <code>info/refs</code> ファイルを引き出す（pull down）ことです。このファイルは <code>update-server-info</code> コマンドによって書き込まれます。そのために、HTTPトランスポートが適切に動作するための <code>post-receive</code> フックとして、そのコマンドを有効にする必要があります。</p>

<pre><code>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master
</code></pre>

<p>いまあなたはリモート参照と SHAのハッシュのリストを持っています。
次に、終了時に何をチェックアウトするのかを知るために、HEAD参照が何かを探します。</p>

<pre><code>=&gt; GET HEAD
ref: refs/heads/master
</code></pre>

<p>プロセスの完了時に、<code>master</code> ブランチをチェックアウトする必要があります。この時点で、あなたは参照を辿るプロセス（the walking process）を開始する準備ができています。開始時点はあなたが <code>info/refs</code> ファイルの中に見た <code>ca82a6</code> のコミットオブジェクトなので、それをフェッチすることによって開始します。</p>

<pre><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)
</code></pre>

<p>オブジェクトバック（object back）を取得します。それは、サーバ上の緩い形式のオブジェクトで、静的な HTTP GETリクエストを超えてそれをフェッチします。zlib-uncompress を使ってそれを解凍することができます。ヘッダを剥ぎ取り（strip off）それからコミットコンテンツを見てみます。</p>

<pre><code>$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number
</code></pre>

<p>次に、取り戻すためのオブジェクトがもう二つあります。それは、たった今取り戻したコミットがポイントするコンテンツのツリーである <code>cfda3b</code> と、親のコミットである <code>085bb3</code> です。</p>

<pre><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)
</code></pre>

<p>それは次のコミットオブジェクトを与えます。ツリーオブジェクトをつかみます。</p>

<pre><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)
</code></pre>

<p>おっと、どうやらそのツリーオブジェクトはサーバ上の緩い形式には存在しないようです。そのため404のレスポンスを受け取っています。これには二つの理由があります。ひとつは、オブジェクトは代替のレポジトリ内に存在し得るため、もうひとつは、このレポジトリ内のパックファイルの中に存在し得るため。Git はまずリストにあるあらゆる代替の URLをチェックします。</p>

<pre><code>=&gt; GET objects/info/http-alternates
(empty file)
</code></pre>

<p>代替の URLのリストと一緒にこれが戻ってくるなら、Git はそこにある緩いファイルとパックファイルをチェックします。これは、ディスク上のオブジェクトを共有するために互いにフォークし合っているプロジェクトにとって素晴らしい機構（mechanism）です。しかし、このケースではリスト化された代替は存在しないため、オブジェクトはパックファイルの中にあるに違いありません。サーバー上の何のパックファイルが利用可能かを知るには、<code>objects/info/packs</code> のファイルを取得することが必要です。そのファイルには（さらに <code>update-server-info</code> によって生成された）それらの一覧が含まれています。</p>

<pre><code>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
</code></pre>

<p>サーバー上にはパックファイルがひとつしかないので、あなたのオブジェクトは明らかにそこにあります。しかし念の為にインデックスファイルをチェックしてみましょう。これが便利でもあるのは、もしサーバー上にパックファイルを複数持つ場合に、どのパックファイルにあなたが必要とするオブジェクトが含まれているのかを知ることができるからです。</p>

<pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)
</code></pre>

<p>パックファイルのインデックスを持っているので、あなたのオブジェクトがその中にあるのかどうかを知ることができます。なぜならインデックスにはパックファイルの中にあるオブジェクトの SHAハッシュとそれらのオブジェクトに対するオフセットがリストされているからです。あなたのオブジェクトはそこにあります。さあ、すべてのパックファイルを取得してみましょう。</p>

<pre><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)
</code></pre>

<p>あなたはツリーオブジェクトを持っているのでコミットを辿ってみましょう。それらすべてはまた、あなたが丁度ダウンロードしたパックファイルの中にあります。そのため、もはやサーバーに対していかなるリクエストも不要です。Git は <code>master</code> ブランチの作業用コピーをチェックアウトします。そのブランチは最初にダウンロードした HEAD への参照によってポイントされています。</p>

<p>このプロセスのすべての出力はこのように見えます。</p>

<pre><code>$ git clone http://github.com/schacon/simplegit-progit.git
Initialized empty Git repository in /private/tmp/simplegit-progit/.git/
got ca82a6dff817ec66f44342007202690a93763949
walk ca82a6dff817ec66f44342007202690a93763949
got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Getting alternates list for http://github.com/schacon/simplegit-progit.git
Getting pack list for http://github.com/schacon/simplegit-progit.git
Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835
Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835
 which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf
walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
walk a11bef06a3f659402fe7563abf99ad00de2209e6
</code></pre>

<h3>スマートプロトコル</h3>

<p>HTTPメソッドはシンプルですが少し非効率です。スマートプロトコルを使用することはデータ移行のより一般的な手段です。これらのプロトコルは Git をよく知っているリモートエンド上にプロセスを持っています。そのリモートエンドは、ローカルのデータを読んで、クライアントが何を持っているか、または、必要としているか、そして、それに対するカスタムデータを生成するのか知ることができます。データを転送するためのプロセスが2セットあります。データをアップロードするペア、それと、ダウンロードするペアです。</p>

<h4>データのアップロード</h4>

<p>リモートプロセスにデータをアップロードするため、Git は <code>send-pack</code> と <code>receive-pack</code> のプロセスを使用します。<code>send-pack</code> プロセスはクライアント上で実行されリモートサイド上の <code>receive-pack</code> プロセスに接続します。</p>

<p>例えば、あなたのプロジェクトで <code>git push origin master</code> を実行したとしましょう。そして <code>origin</code> は SSHプロトコルを使用する URLとして定義されているとします。Git はあなたのサーバーへの SSHによる接続を開始する <code>send-pack</code> プロセスを実行します。リモートサーバ上で以下のようなSSHの呼び出しを介してコマンドを実行しようとします。</p>

<pre><code>$ ssh -x git@github.com "git-receive-pack 'schacon/simplegit-progit.git'"
005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs
003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
0000
</code></pre>

<p><code>git-receive-pack</code> コマンドは現在持っている各々の参照に対してひとつの行をすぐに返します。このケースでは、<code>master</code> ブランチとその SHAハッシュのみです。最初の行はサーバーの可能性（ここでは、<code>report-status</code> と <code>delete-refs</code>）のリストも持っています。</p>

<p>各行は 4バイトの 16進数で始まっており、その残りの行がどれくらいの長さなのかを示しています。最初の行は 005b で始まっていますが、これは16進数では 91 であり、その行には 91バイトが残っていることを意味します。次の行は 003e で始まっていて、これは 62 です。そのため残りの 62バイトを読みます。次の行は 0000 であり、サーバーはその参照のリスト表示を終えたことを意味します。</p>

<p>サーバーの状態がわかったので、あなたの <code>send-pack</code> プロセスはサーバーが持っていないのは何のコミットかを決定します。このプッシュが更新する予定の各参照に対して、<code>send-pack</code> プロセスは <code>receive-pack</code> プロセスにその情報を伝えます。例えば、もしもあなたが <code>master</code> ブランチを更新していて、さらに、<code>experiment</code> ブランチを追加しているとき、<code>send-pack</code> のレスポンスは次のように見えるかもしれません。</p>

<pre><code>0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment
0000
</code></pre>

<p>すべてが <code>'0'</code> の SHA-1ハッシュ値は以前そこには何もなかったことを意味します。それはあなたが experiment の参照を追加しているためです。もしもあなたが参照を削除していたとすると、あなたは逆にすべての <code>'0'</code> が右側にあるのを見るでしょう。</p>

<p>Git はあなたが古い SHA1ハッシュで更新している各々の古い参照、新しい参照、そして更新されている参照に対して行を送信します。最初の行はまたクライアントの性能（capabilities）を持っています。次に、クライアントはサーバーが未だ持ったことのないすべてのオブジェクトのパックファイルをアップロードします。最後に、サーバーは成功（あるいは失敗）の表示を返します。</p>

<pre><code>000Aunpack ok
</code></pre>

<h4>データのダウンロード</h4>

<p>データをダウンロードするときには、<code>fetch-pack</code> と <code>upload-pack</code> プロセスが伴います。クライアントは <code>fetch-pack</code> プロセスを開始します。何のデータが移送されてくるのかを取り決める（negotiate）ため、それはリモートサイド上の <code>upload-pack</code> プロセスに接続します。</p>

<p>リモートリポジトリ上の <code>upload-pack</code> プロセスを開始する異なった方法があります。あなたは <code>receive-pack</code> プロセスと同様に SSH経由で実行することができます。さらに、Git デーモンを介してプロセスを開始することもできます。そのデーモンは、デフォルトではサーバ上の 9418ポートを使用します。<code>fetch-pack</code> プロセスはデータを送信します。そのデータは接続後のデーモンに対して、以下のように見えます。</p>

<pre><code>003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0
</code></pre>

<p>どれくらい多くのデータが続いているのかを示す 4バイトから始まります。それから、ヌルバイトに続いて実行コマンド、そして最後のヌルバイトに続いてサーバーのホスト名が来ます。Git デーモンはコマンドが実行でき、レポジトリが存在して、それがパブリックのパーミッションを持っていることをチェックします。もしすべてが素晴らしいなら、<code>upload-pack</code> プロセスを発行して、それに対するリクエストを渡します。</p>

<p>もし SSHを介してフェッチを行っているとき、<code>fetch-pack</code> は代わりにこのように実行します。</p>

<pre><code>$ ssh -x git@github.com "git-upload-pack 'schacon/simplegit-progit.git'"
</code></pre>

<p>いずれケースでも、<code>fetch-pack</code> の接続のあと、<code>upload-pack</code> はこのように送り返します。</p>

<pre><code>0088ca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \
  side-band side-band-64k ofs-delta shallow no-progress include-tag
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic
0000
</code></pre>

<p>これは <code>receive-pack</code> が返答する内容にとても似ていますが、性能は異なります。加えて、これがクローンの場合はクライアントが何をチェックアウトするのかを知るために HEAD への参照を送り返します。</p>

<p>この時点で、<code>fetch-pack</code> プロセスは何のオブジェクトがそれを持っているかを見ます。そして "want" とそれが求める SHA1ハッシュを送ることによって、それが必要なオブジェクトを返答します。"have" とその SHA1ハッシュで既に持っているオブジェクトすべてを送ります。このリストの最後で、それが必要とするデータのパックファイルを送信する <code>upload-pack</code> プロセスを開始するために "done" を書き込みます。</p>

<pre><code>0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0000
0009done
</code></pre>

<p>これはトランスファープロトコルのとても基本的なケースです。より複雑なケースでは、クライアントは <code>multi_ack</code> または <code>side-band</code> の性能をサポートします。しかしこの例ではスマートプロトコルのプロセスによって使用される基本の部分を示します。</p>

<h2>メインテナンスとデータリカバリ</h2>

<p>時々、幾らかのお掃除をする必要があるかもしれません。つまり、レポジトリをよりコンパクトにすること、インポートしたリポジトリをクリーンアップすること、あるいは失った作業をもとに戻すことです。このセクションではこれらのシナリオの幾つかをカバーします。</p>

<h3>メインテナンス</h3>

<p>Git は時々 "<code>auto gc</code>" と呼ばれるコマンドを自動的に実行します。大抵の場合、このコマンドは何もしません。もし沢山の緩いオブジェクト（パックファイルの中にないオブジェクト）があったり、あまりに多くのパックファイルがあると、Git は完全な（full-fledged）<code>git gc</code> コマンドを開始します。<code>gc</code> はガベージコレクト（garbage collect）を意味します。このコマンドは幾つものことを行います。まず、すべての緩いオブジェクトを集めてそれらをパックファイルの中に入れます。複数のパックファイルをひとつの大きなパックファイルに統合します。どのコミットからも到達が不可能なオブジェクトや数ヶ月の間何も更新がないオブジェクトを削除します。</p>

<p>次のように手動で <code>auto gc</code> を実行することができます。</p>

<pre><code>$ git gc --auto
</code></pre>

<p>繰り返しますが、これは通常は何も行いません。約 7,000個もの緩いオブジェクトがあるか、または50以上のパックファイルがないと、Gitは実際に gc コマンドを開始しません。これらのリミットは設定ファイルの <code>gc.auto</code> と <code>gc.autopacklimit</code> によってそれぞれ変更することができます。</p>

<p>他にも <code>gc</code> が行うこととしては、あなたが持つ参照を1つのファイルにまとめて入れることが挙げられます。あなたのレポジトリには、次のようなブランチとタグが含まれているとしましょう。</p>

<pre><code>$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1
</code></pre>

<p><code>git gc</code> を実行すると、<code>refs</code> ディレクトリにはこれらのファイルはもはや存在しなくなります。効率性のために Git はそれらを、以下のような <code>.git/packed-refs</code> という名前のファイルに移します。</p>

<pre><code>$ cat .git/packed-refs
# pack-refs with: peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9
</code></pre>

<p>もし参照を更新すると、Git はこのファイルを編集せず、その代わりに <code>refs/heads</code> に新しいファイルを書き込みます。与えられた参照に対する適切な SHA1ハッシュを得るために、Git は <code>refs</code> ディレクトリ内でその参照をチェックし、それから予備（fallback）として <code>packed-refs</code> ファイルをチェックします。ところがもし <code>refs</code> ディレクトリ内で参照が見つけられない場合は、それはおそらく <code>packed-refs</code> ファイル内にあります。</p>

<p>ファイルの最後の行に注意してください。それは <code>^</code> という文字で始まっています。これはタグを意味し、そのすぐ上にあるのはアノテートタグ（annotated tag）であり、その行はアノテートタグがポイントするコミットです。</p>

<h3>データリカバリ</h3>

<p>Git を使っていく過程のある時点で、誤ってコミットを失ってしまうことがあるかもしれません。これが起こるのは一般的には、作業後のブランチを <code>force-delete</code> して、その後結局そのブランチが必要になったとき、あるいはブランチを <code>hard-reset</code> したために、そこから何か必要とするコミットが破棄されるときです。これが起きたとしたら、あなたはどうやってコミットを元に戻しますか?</p>

<p>こちらの例では、あなたの test リポジトリ内の master ブランチを古いコミットに hard-reset して、それから失ったコミットを復元します。まず、ここであなたのレポジトリがどこにあるのか調べてみましょう。</p>

<pre><code>$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</code></pre>

<p>ここで、<code>master</code> ブランチを移動させて、中間のコミットに戻します。</p>

<pre><code>$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</code></pre>

<p>あなたはトップにある二つのコミットを手際よく失いました。それらのコミットからはどのブランチからも到達され得ません。最後のコミットの SHA1ハッシュを見つけて、それにポイントするブランチを追加する必要があります。その最後のコミットの SHA1ハッシュを見つけるコツは、記憶しておくことではないですよね？</p>

<p>大抵の場合、最も手っ取り早いのは、<code>git reflog</code> と呼ばれるツールを使う方法です。あなたが作業をしているとき、変更する度に Git は HEAD が何であるかを黙って記録します。ブランチをコミットまたは変更する度に <code>reflog</code> は更新されます。<code>reflog</code> はまた <code>git update-ref</code> コマンドによっても更新されます。このチャプターの前の "Gitの参照" のセクションでカバーしましたが、これは、<code>ref</code> ファイルに SHA1ハッシュ値を直に書くのではなくコマンドを使用する別の理由です。<code>git reflog</code> を実行することで自分がどこにいたのかをいつでも知ることができます。</p>

<pre><code>$ git reflog
1a410ef HEAD@{0}: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD
ab1afef HEAD@{1}: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD
</code></pre>

<p>ここでチェックアウトした2つのコミットを見つけることができますが、ここに多くの情報はありません。もっと有効な方法で同じ情報を見るためには、<code>git log -g</code> を実行することができます。これは reflog に対する通常のログ出力を提供してくれます。</p>

<pre><code>$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:22:37 2009 -0700

    third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

     modified repo a bit
</code></pre>

<p>一番下にあるコミットがあなたが失ったコミットのようです。そのコミットの新しいブランチを作成することでそれを復元することができます。例えば、そのコミット（ab1afef）から <code>recover-branch</code> という名前でブランチを開始することができます。</p>

<pre><code>$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
</code></pre>

<p>素晴らしい。<code>master</code> ブランチがかつて存在した場所に、最初の二つのコミットを再び到達可能にして、あなたはいま <code>recover-branch</code> という名前のブランチを持っています。次に、損失の原因は reflog の中にはないある理由によるものだったと想定しましょう。<code>recover-branch</code> を取り除いて reflog を削除することによって、それをシミュレートすることができます。最初の二つのコミットは今いかなるものからも到達不能な状態です。</p>

<pre><code>$ git branch -D recover-branch
$ rm -Rf .git/logs/
</code></pre>

<p>なぜなら reflog データは <code>.git/logs/</code> ディレクトリに残っているため、あなたは効率的に reflog を持たない状態です。この時点でそのコミットをどうやって復元できるのでしょうか? ひとつの方法は <code>git fsck</code> ユティリティーを使用することです。それはあなたのデータベースの完全性（integrity）をチェックします。もし <code>--full</code> オプションを付けて実行すると、別のオブジェクトによってポイントされていないすべてのオブジェクトを表示します。</p>

<pre><code>$ git fsck --full
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293
</code></pre>

<p>このケースでは、あなたは浮遊コミットの後に見失ったコミットを見つけることができます。その SHA1ハッシュにポイントするブランチを加えることによって、同様にそれを復元することができます。</p>

<h3>オブジェクトの除去</h3>

<p>Git には素晴らしいものたくさんあります。しかし問題が生じる可能性がある機能がひとつあります。<code>git clone</code> がすべてのファイルのすべてのバージョンを含んだプロジェクトの履歴全体をダウンロードしてしまうということです。すべてがソースコードならこれは申し分のないことです。なぜなら Git はそのデータを効率良く圧縮することに高度に最適化されているからです。しかし、もし誰かがある時点であなたのプロジェクトの履歴に1つ非常に大きなファイルを加えると、すべてのクローンは以後ずっと、その大きなファイルのダウンロードを強いられることになります。たとえ、まさに次のコミットでそれをプロジェクトから取り除かれたとしても。なぜなら常にそこに存在して、履歴から到達可能だからです。</p>

<p>Subversion または Perforce のレポジトリを Git に変換するときに、これは大きな問題になり得ます。なぜなら、それらのシステムではすべての履歴をダウンロードする必要がないため、非常に大きなファイルを追加してもほとんど悪影響がないからです。もし別のシステムからインポートを行った場合、あるいはあなたのレポジトリがあるべき状態よりもずっと大きくなっている場合、大きなオブジェクトを見つけて取り除く方法があります。</p>

<p>注意: このテクニックはあなたのコミット履歴を壊すことになります。大きなファイルへの参照を取り除くために修正が必要な一番前のツリーからすべての下流のコミットオブジェクトに再書き込みをします。もしインポートした後そのコミット上での作業を誰かが開始する前にすぐにこれを行った場合は問題ないです。その他の場合は、あなたの新しいコミット上に作業をリベースしなければならないことをすべての関係者（contributors）に知らせる必要があります。</p>

<p>実演するために、あなたの <code>test</code> リポジトリに大きなファイルを追加して、次のコミットでそれを取り除き、それを見つけて、そしてレポジトリからそれを永久に取り除きます。まず、あなたの履歴に大きなオブジェクトを追加します。</p>

<pre><code>$ curl http://kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2 &gt; git.tbz2
$ git add git.tbz2
$ git commit -am 'added git tarball'
[master 6df7640] added git tarball
 1 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tbz2
</code></pre>

<p>おっと、誤ってプロジェクトに非常に大きなターボールを追加してしまいました。取り除いたほうがいいでしょう。</p>

<pre><code>$ git rm git.tbz2
rm 'git.tbz2'
$ git commit -m 'oops - removed large tarball'
[master da3f30d] oops - removed large tarball
 1 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tbz2
</code></pre>

<p>ここで、データベースに対して <code>gc</code> を実行して、どれくらい多くのスペースを使用しているのかを見てみます。</p>

<pre><code>$ git gc
Counting objects: 21, done.
Delta compression using 2 threads.
Compressing objects: 100% (16/16), done.
Writing objects: 100% (21/21), done.
Total 21 (delta 3), reused 15 (delta 1)
</code></pre>

<p><code>count-objects</code> コマンドを実行してどれくらい多くのスペースを使用しているのかをすぐに見ることができます。</p>

<pre><code>$ git count-objects -v
count: 4
size: 16
in-pack: 21
packs: 1
size-pack: 2016
prune-packable: 0
garbage: 0
</code></pre>

<p><code>size-pack</code> エントリにはパックファイルのサイズがキロバイトで記されていて、2MB使用していることがわかります。最後のコミットの前は、2KB近くを使用していました。明らかに前のコミットからファイルが取り除かれましたが、そのファイルは履歴からは取り除かれませんでした。このレポジトリを誰かがクローンする都度、彼らはこの小さなプロジェクトを取得するだけに 2MBすべてをクローンする必要があるでしょう。なぜならあなたは誤って大きなファイルを追加してしまったからです。それを取り除きましょう。</p>

<p>最初にあなたはそれを見つけなければなりません。このケースでは、あなたはそれが何のファイルかを既に知っています。しかし、もし知らなかったとします。その場合どうやってあなたは多くのスペースを占めているファイルを見分けるのでしょうか？ もし <code>git gc</code> を実行したとき、すべてのプロジェクトはパックファイルのなかにあります。大きなオブジェクトは別の配管コマンドを実行することで見分けることができます。それは <code>git verify-pack</code> と呼ばれ、ファイルサイズを意味する三つ目の出力フィールドに対して並び替えを行います。それを <code>tail</code> コマンドと通してパイプすることもできます。なぜなら最後の幾つかの大きなファイルのみが関心の対象となるからです。</p>

<pre><code>$ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k 3 -n | tail -3
e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4667
05408d195263d853f09dca71d55116663690c27c blob   12908 3478 1189
7a9eb2fba2b1811321254ac360970fc169ba2330 blob   2056716 2056872 5401
</code></pre>

<p>大きなオブジェクトは一番下の 2MBのものです。それが何のファイルなのかを知るには7章で少し使用した <code>rev-list</code> コマンドを使用します。<code>--objects</code> を <code>rev-list</code> に渡すと、すべてのコミットの SHA1ハッシュとブロブの SHA1ハッシュをそれらに関連するファイルパスと一緒にリストします。ブロブの名前を見つけるためにこれを使うことができます。</p>

<pre><code>$ git rev-list --objects --all | grep 7a9eb2fb
7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2
</code></pre>

<p>ここで、あなたは過去のすべてのツリーからこのファイルを取り除く必要があります。このファイルを変更したのは何のコミットなのか知ることは簡単です。</p>

<pre><code>$ git log --pretty=oneline --branches -- git.tbz2
da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball
6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball
</code></pre>

<p>Git レポジトリから完全にこのファイルを取り除くためには、<code>6df76</code> から下流のすべてのコミットを書き直さなければなりません。そのためには、6章で使用した <code>filter-branch</code> を使用します。</p>

<pre><code>$ git filter-branch --index-filter \
   'git rm --cached --ignore-unmatch git.tbz2' -- 6df7640^..
Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm 'git.tbz2'
Rewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)
Ref 'refs/heads/master' was rewritten
</code></pre>

<p><code>--index-filter</code> オプションは、ディスク上のチェックアウトされたファイルを変更するコマンドを渡すのではなく、ステージングエリアまたはインデックスを毎度変更することを除けば、6章で使用した <code>--tree-filter</code> オプションに似ています。特定のファイルに対して <code>rm file</code> を実行するように取り除くよりもむしろ、<code>git rm --cached</code> を実行して取り除かなければなりません。つまりディスクではなくインデックスからそれを取り除くのです。このようにする理由はスピードです。Git はあなたの除去作業の前にディスク上の各リビジョンをチェックアウトする必要がないので、プロセスをもっともっと速くすることができます。同様のタスクを <code>--tree-filter</code> を使用することで達成することができます。<code>git rm</code> に渡す <code>--ignore-unmatch</code> オプションは取り除こうとするパターンがそこにない場合にエラーを出力しないようにします。最後に、<code>filter-branch</code> に <code>6df7640</code> のコミットから後の履歴のみを再書き込みするように伝えます。なぜならこれが問題が生じた場所であることをあなたは知っているからです。さもなければ、最初から開始することになり不必要に長くかかるでしょう。</p>

<p>履歴にはもはやそのファイルへの参照が含まれなくなります。しかしあなたの reflog と <code>.git/refs/original</code> の下で <code>filter-branch</code> を行ったときに Git が追加した新しいセットの refs には、参照はまだ含まれているので、それらを取り除いてそしてデータベースを再パックしなければなりません。再パックの前にそれら古いコミットへのポインタを持ついかなるものを取り除く必要があります。</p>

<pre><code>$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 19, done.
Delta compression using 2 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (19/19), done.
Total 19 (delta 3), reused 16 (delta 1)
</code></pre>

<p>どれくらいのスペースが節約されたかを見てみましょう。</p>

<pre><code>$ git count-objects -v
count: 8
size: 2040
in-pack: 19
packs: 1
size-pack: 7
prune-packable: 0
garbage: 0
</code></pre>

<p>パックされたレポジトリのサイズは 7KBに下がりました。当初の 2MBよりもずっとよくなりました。サイズの値から大きなオブジェクトが未だ緩いオブジェクトの中にあることがわかります。そのため、それは無くなったわけではないのです。ですが、それはプッシュや後続するクローンで移送されることは決してありません。これは重要なことです。本当にそれを望んでいたのなら、<code>git prune --expire</code> を実行することでオブジェクトを完全に取り除くことができました。</p>

<h2>要約</h2>

<p>Git がバックグラウンドで何を行うのかについて、また、ある程度までの Git の実装の方法について、かなり良い理解が得られたことでしょう。この章では幾つかの配管コマンドを取り扱いました。このコマンドは、本書の残りで学んだ磁器コマンドよりもシンプルでもっと下位レベルのコマンドです。下位レベルで Git がどのように機能するのかを理解することは、なぜ行うのか、何を行うのかを理解して、さらに、あなた自身でツールを書いて、あなた固有のワークフローが機能するようにスクリプト利用することをより容易にします。</p>

<p>連想記憶ファイル・システムとしての Git は単なるバージョン管理システム（VCS）以上のものとして簡単に使用できる、とても強力なツールです。望むらくは、あなたが Git の内側で見つけた新しい知識を使うことです。その知識は、このテクノロジーを利用するあなた自身の素晴らしいアプリケーションを実装するための知識、また、より進歩した方法で Git を使うことをより快適に感じるための知識です。</p>
</body></html>